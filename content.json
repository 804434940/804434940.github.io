{"pages":[{"title":"文章分类","text":"","link":"/categories/index.html"},{"title":"","text":"图片搜集于互联网，侵权请留言，马上处理😊。","link":"/gallery/index.html"},{"title":"相册","text":"","link":"/photo/index.html"},{"title":"标签","text":"","link":"/tags/index.html"}],"posts":[{"title":"docker安装ES","text":"123456789101112131415161718192021222324docker pull elasticsearch:6.4.0 //再低就是5.x了1.vim /etc/security/limits.d/90-nproc.conf 添加：soft nproc 40962. vim /etc/sysctl.conf 添加vm.max_map_count=655360 执行sysctl -p刷新配置//根据自己的内存大小适当调整，太大会启动失败3.docker run -e ES_JAVA_OPTS=\"-Xms512m -Xmx512m\" -d -p 9200:9200 -p 9300:9300 --name=myES 容器id4.docker exec -it 容器名 /bin/bash 进入容器命令行5.vim config/elasticsearch.yml 地址改为0.0.0.0可能会vim不可用 执行 yum update yum install -y vim6.安装ik分词器先上传到宿主机，再使用以下命令copy到容器中docker cp 宿主机ik分词器地址 容器名:/usr/share/elasticsearch/plugins/ik","link":"/posts/20200106-docker_es.html"},{"title":"centos7查看防火墙以及开放和关闭端口","text":"查看某个端口是否开放 1firewall-cmd --query-port=22122/tcp yes/no 开放/未开放 开放指定端口1firewall-cmd --add-port=22122/tcp --permanent firewall-cmd –zone=public –add-port=80/tcp –permanent-zone #作用域-permanent 没有该参数重启后失效 重新加载端口： 1firewall-cmd --reload 3.关闭某个端口 1firewall-cmd --permanent --remove-port=22122/tcp 重新加载 4. 查看防火墙状态 123firewall-cmd --state或者:systemctl status firewalld 打开/关闭防火墙 启动：systemctl start firewalld关闭： systemctl stop firewalld开机启用 ： systemctl enable firewalld禁止firewall开机启动 ：systemctl disable firewalld.service启动服务：systemctl start firewalld.service关闭服务：systemctl stop firewalld.service重启服务：systemctl restart firewalld.service 查看端口占用情况 1netstat -anp 查看防火墙已开放的端口 1firewall-cmd --list-ports","link":"/posts/20200107-centos7_firewall.html"},{"title":"hexo压缩静态资源","text":"1.安装gulp1.1首先全局安装gulp1npm install gulp -g 1.2 再局部安装相关插件1npm install gulp-imagemin gulp gulp-minify-css gulp-minify-html gulp-uglify -- 1234567# 解决【Gulp打包问题】 GulpUglifyError: unable to minify JavaScript# 解决 gulp-uglify 压缩JavaScript 不兼容 es5 语法的问题npm install babel-core@6.26.3 --savenpm install gulp-babel@7.0.1 --savenpm install babel-preset-es2015@6.24.1 --save# gulp-babel 取消严格模式方法(\"use strict\")npm install babel-plugin-transform-remove-strict-mode --save 2.在网站根目录创建gulpfile.js文件，用来配置压缩1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859var gulp = require('gulp');//Plugins模块获取var minifycss = require('gulp-minify-css');var uglify = require('gulp-uglify');var minifyhtml = require('gulp-minify-html');var imagemin = require('gulp-imagemin')var babel = require('gulp-babel');// 压缩 public 目录 css文件gulp.task('minify-css', function () { return gulp.src('./public/**/*.css') .pipe(minifycss()) .pipe(gulp.dest('./public'));});// 压缩 public 目录 html文件gulp.task('minify-html', function () { return gulp.src('./public/**/*.html') .pipe(minifyhtml()) .pipe(gulp.dest('./public'))});// 压缩js文件gulp.task('minify-js', function (done) { return gulp.src(['./public/**/*.js', '!./public/**/*.min.js','!./public/js/src/snow.js']) .pipe(babel({ //将ES6代码转译为可执行的JS代码 presets: [['es2015',{strict:false}]] // es5检查机制 })) .pipe(uglify()) .pipe(gulp.dest('./public')); done();});// 压缩public/posts 目录 图片文件gulp.task('minify-img', function () { return gulp.src(['./public/images/**/*.*','./source/gallery/**']) .pipe(imagemin( [ imagemin.gifsicle({ 'optimizationLevel': 3 }), imagemin.jpegtran({ 'progressive': true }), imagemin.optipng({ 'optimizationLevel': 7 }), imagemin.svgo() ], { 'verbose': true })) .pipe(gulp.dest('./public'))});// 分别执行css、heml、js和图片的压缩任务gulp.task('build', gulp.series('minify-css', 'minify-html', 'minify-js', 'minify-img')); 3.在网站根目录创建.babelrc1234{ 'presets': ['es2015'], \"plugins\": [\"transform-remove-strict-mode\"]} 4.执行压缩1hexo clean&amp;&amp;hexo g &amp;&amp;gulp build 不兼容ES5的解决参考:https://segmentfault.com/a/1190000019842178?utm_source=tag-newest","link":"/posts/20200111-hexo-gulp.html"},{"title":"jib打包项目到阿里镜像","text":"​ Jib 将处理将应用打包到容器镜像过程中的所有步骤，它直接与 Maven 和 Gradle Java 开发环境集成，不需要你编写 Dockerfile 或安装 Docker（但想要运行还是要本地安装docker） ，只需将其作为插件添加到你的构建中，就可以立即将 Java 应用容器化。 图片来源于https://www.oschina.net/news/97892/google-opensource-jib 一、在pom文件中引入jib插件1234567891011121314151617181920212223242526272829303132333435363738394041424344&lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt; &lt;/plugin&gt; &lt;plugin&gt; &lt;groupId&gt;com.google.cloud.tools&lt;/groupId&gt; &lt;artifactId&gt;jib-maven-plugin&lt;/artifactId&gt; &lt;version&gt;1.7.0&lt;/version&gt; &lt;configuration&gt; &lt;!--拉取的镜像的配置，默认为gcr.io/distroless/java--&gt; &lt;from&gt; &lt;image&gt;基础镜像地址&lt;/image&gt; &lt;auth&gt; &lt;username&gt;阿里云用户名&lt;/username&gt; &lt;password&gt;阿里云密码&lt;/password&gt; &lt;/auth&gt; &lt;/from&gt; &lt;to&gt; &lt;image&gt;基础镜像地址&lt;/image&gt; &lt;auth&gt; &lt;username&gt;阿里云用户名&lt;/username&gt; &lt;password&gt;阿里云密码&lt;/password&gt; &lt;/auth&gt; &lt;tags&gt; &lt;tag&gt;版本号&lt;/tag&gt; &lt;/tags&gt; &lt;/to&gt; &lt;allowInsecureRegistries&gt;true&lt;/allowInsecureRegistries&gt; &lt;/configuration&gt; &lt;executions&gt; &lt;execution&gt; &lt;phase&gt;package&lt;/phase&gt; &lt;goals&gt; &lt;goal&gt;build&lt;/goal&gt; &lt;/goals&gt; &lt;/execution&gt; &lt;/executions&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/build&gt; 版本号这里一开始指定的自定义版本，但是使用jib:build时报错，说找不到latest版本，不知道是不是默认拉取latest，但是网上其他博主好像并没有这个情况，这里就只好将tag设为latest了 二、github创建仓库添加Dockerfile文件 三、阿里云创建镜像仓库3.1 创建仓库点击下一步，根据提示选择Dockerfile所在仓库 进入新创建的仓库，点击添加规则这里版本起名latest，原因上面解释了，有知道的伙伴还请告知 感谢~ 点击构建，等待一会，下方日志中会显示构建的镜像和状态 最后返回基本信息，复制公网地址，放在from和to的image中，一定要填写username和password最后执行 jib:build即可成功 成功! 最后在docker中拉取就可以了 1docker run -d --name testjib-p 8081:8081 刚刚复制的公网地址:latest(对应的镜像版本号)","link":"/posts/20200106-jib_ali.html"},{"title":"mavon-editor+springboot+fdfs上传文件","text":"一、安装mavon直接npm install下就可以了，然后在main.js引入：12import mavonEditor from 'mavon-editor'Vue.use(mavonEditor) 二、页面使用1234567891011&lt;mavon-editor v-show=\"!articleModal\" id=\"editor\" v-model=\"value\" fontSize=\"16px\" ref=\"md\" @imgAdd=\"$imgAdd\" @imgDel=\"$imgDel\" @change=\"handleChange\" @fullScreen=\"handleFullScreen\" /&gt; 这里只需要关注@imgAdd，为添加图片的事件 三、上传文件这里使用的是批量上传，所以每触发一次@imgAdd就向文件集合添加一次 1234567/** * 添加文件到文件集合中 */ $imgAdd(pos, $file) { // 缓存图片信息 this.img_file[pos] = $file; }, data中定义如下： 1img_file: {}, //文件集合 上传文件方法： 123456789101112131415161718192021222324/** * 上传文件 */ uploadimg($e) { var formdata = new FormData(); for (var _img in this.img_file) { formdata.append(\"files\", this.img_file[_img]); } uploadApi.uploadFileList(formdata).then(res =&gt; { console.log(res); const resData = res.data.data; /** * 例如：返回数据为 res = [[pos, url], [pos, url]...] * pos 为原图片标志（0） * url 为上传后图片的url地址 */ // 第二步.将返回的url替换到文本原位置![...](0) -&gt; ![...](url) for (var i = 0; i &lt; resData.length; i++) { this.$refs.md.$img2Url(i + 1, resData[i]); } }); } 然后在需要上传的时候调用一下这个方法就可以啦 四、后台进行上传4.1Controller123456789101112131415/** * 文章多文件上传 * @param files * @return 返回图片地址 */ @PostMapping(value = \"/files\",produces = MediaType.APPLICATION_JSON_UTF8_VALUE) public Result uploadMultiFiles(@RequestParam(\"files\") MultipartFile[] files){ try { List&lt;String&gt; resultList = uploadService.uploadMultiFiles(files); return new Result(true,StatusCode.OK,\"上传成功\",resultList); }catch (Exception e){ return new Result(false,StatusCode.ERROR,\"啊哦~图片上传出现了点小错误，请稍后再上传\"); } } 4.2、Service123456789101112131415161718192021222324252627282930313233343536/** * 批量上传 * @param files */ public List&lt;String&gt; uploadMultiFiles(MultipartFile[] files) { List&lt;String&gt; resultList=new ArrayList&lt;&gt;(); for (MultipartFile file : files) { try { //校验文件内容 BufferedImage image = ImageIO.read(file.getInputStream()); if (image == null) { throw new MyException(ExceptionEnum.INVALID_FILE_TYPE); } //获取拓展名 String extension = StringUtils.substringAfterLast(file.getOriginalFilename(), \".\"); //上传到FastDFS StorePath storePath = storageClient.uploadFile(file.getInputStream(), file.getSize(), extension, null); //不加http://前端无法显示 resultList.add(\"http://\"+uploadProperties.getBaseUrl() + storePath.getFullPath()); //返回路径 } catch (IOException e) { //上传失败 LOGGER.error(\"[文件上传]文件\"+file.getOriginalFilename()+\"上传失败!\", e); throw new MyException(ExceptionEnum.UPLOAD_FILE_ERROR); } } return resultList; } Fdfs的相关配置在这篇文章写啦(不好意思比较懒)：https://blog.csdn.net/weixin_43696529/article/details/102727220","link":"/posts/20200106-mavon_boot_fdfs.html"},{"title":"冒泡排序---------java实现","text":"一、冒泡排序 平均时间复杂度: O(n²)最差时： O(n²)是否稳定： 稳定空间开销：O（1）适合n较小时 原始数组：3 ， 9， -1， 8, 2 第一趟排序：（1） 3， 9， -1， 8，2（2） 3， -1， 9，8， 2（3） 3， -1， 8， 9， 2（4）3， -1， 8， 2， 9 9确定 第二趟排序：（1）-1，3， 8， 2， 9（2）-1, 3， 8， 2， 9（3）-1，3，2， 8， 9 8 , 9确定第三趟排序：（1）-1，3 ，2 ，8 ， 9（2）-1， 2， 3 ，8 ，9 3， 8， 9确定第四趟排序：（1）-1， 2， 3， 8， 9 (2， 3， 8， 9确定) 实现： 123456789101112131415161718int[] array = {3, 9, -1, 8, 2}; int temp=0; for (int i=0; i&lt; array.length-1;i++){ System.out.println(\"开始第\"+(i+1)+\"趟排序\"); for (int j=0;j&lt;array.length-1-i;j++){ if (array[j]&gt;array[j+1]){ temp=array[j]; array[j]=array[j+1]; array[j+1]=temp; } System.out.println(Arrays.toString(array)); } System.out.println(\"第\"+(i+1)+\"趟排序结果：\"); System.out.println(Arrays.toString(array)); System.out.println(\"------------------\"); } 结果：1234567891011121314151617181920212223242526开始第1趟排序[3, 9, -1, 8, 2][3, -1, 9, 8, 2][3, -1, 8, 9, 2][3, -1, 8, 2, 9]第1趟排序结果：[3, -1, 8, 2, 9]------------------开始第2趟排序[-1, 3, 8, 2, 9][-1, 3, 8, 2, 9][-1, 3, 2, 8, 9]第2趟排序结果：[-1, 3, 2, 8, 9]------------------开始第3趟排序[-1, 3, 2, 8, 9][-1, 2, 3, 8, 9]第3趟排序结果：[-1, 2, 3, 8, 9]------------------开始第4趟排序[-1, 2, 3, 8, 9]第4趟排序结果：[-1, 2, 3, 8, 9]------------------ 总结：1.共进行数组大小-1次循环2.每次排序的次数逐渐减少 优化：若一趟排序中没有一次交换，则停止循环增加标志变量flag=false，发生交换时，置flag为true，一次循环后判断flag，若为true，则重置flag为false继续循环，否则break； 1234567891011121314151617181920212223242526272829int[] array = {3, 9, -1, 8, 2}; boolean flag=false; int temp=0; for (int i=0; i&lt; array.length-1;i++){ System.out.println(\"开始第\"+(i+1)+\"趟排序\"); for (int j=0;j&lt;array.length-1-i;j++){ if (array[j]&gt;array[j+1]){ temp=array[j]; array[j]=array[j+1]; array[j+1]=temp; flag=true; } System.out.println(Arrays.toString(array)); } System.out.println(\"第\"+(i+1)+\"趟排序结果：\"); System.out.println(Arrays.toString(array)); System.out.println(\"------------------\"); if (!flag){ //未发生一次交换，flag为false break; }else { //发生了交换，flag被置为true flag=false; //重置flag，继续循环 } } 这里因为数据原因仍然执行了4次可以换一组数据:{3,9,-1,8,10}结果： 123456789101112131415161718192021开始第1趟排序[3, 9, -1, 8, 10][3, -1, 9, 8, 10][3, -1, 8, 9, 10][3, -1, 8, 9, 10]第1趟排序结果：[3, -1, 8, 9, 10]------------------开始第2趟排序[-1, 3, 8, 9, 10][-1, 3, 8, 9, 10][-1, 3, 8, 9, 10]第2趟排序结果：[-1, 3, 8, 9, 10]------------------开始第3趟排序[-1, 3, 8, 9, 10][-1, 3, 8, 9, 10]第3趟排序结果：[-1, 3, 8, 9, 10]------------------ 可以看到只执行了三次排序 测试十万条数据执行时间:12345678910111213//创建50000个随机数组 int[] array =new int[100000]; for (int i=0;i&lt;100000;i++){ array[i]=(int)(Math.random()*100000); } long begintime=System.currentTimeMillis(); System.out.println(\"开始时间\"+begintime); bubbleSort(array); long endtime=System.currentTimeMillis(); System.out.println(\"结束时间\"+endtime); System.out.println(\"用时：\"+(endtime-begintime)+\"ms\"); 结果： 123开始时间1572061280770结束时间1572061302883用时：22113ms 当然每次执行时间不一样，但当数据大的时候总体效率还是很低的","link":"/posts/20200107-bubbleSort.html"},{"title":"基数排序-------------java实现","text":"一、基本思想1.基数排序(Radix Sort)属于分配式排序（distribution sort），又称”桶子法”(Bucket Sort或Bin Sort)，它是通过键值的各个位的值，将要排序的元素分配至某些“桶”中，达到排序的作用。2.基数排序属于稳定的排序，基数排序法的是效率高的稳定性排序法 3.基数排序(Radix Sort)是桶排序的扩展4.将所有待比较数值统一为同样的数位长度，数位较短的数前面补零。然后，从最低位开始，依次进行一次排序。这样从最低位排序一直到最高位排序完成以后, 数列就变成一个有序序列。 平均时间复杂度： O(n+k) 最优情况： O(n+k) 最坏情况： O(n²) 空间复杂度: O(n+k) 稳定性： 稳定 二、举例说明现有一组数据：{43,3,535,738,14,21,0} 第一轮排序： 第1轮排序后：0,21,43,4,14,535,738 第二轮排序：第二轮排序结果：0,4，14,21,535,738,43 第三轮排序：第三轮排序结果：0,4，14,21,43,535,738 三、代码实现1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768package com.wml.sort;import java.util.Arrays;/** * @author MaoLin Wang * @date 2019/10/3012:53 */public class RadixSort { public static void main(String[] args) { int[] arr={53,3,542,748,14,21,0}; radixSort(arr); } public static void radixSort(int[] arr){ //求最大数的位数 int max = arr[0]; for (int i = 1;i &lt; arr.length; i++){ if (arr[i] &gt;max){ max = arr[i]; } } //得到最大数的位数 int maxLength = (max+\"\").length(); //为防止数据溢出，应将列数设为数组长度 int [][] bucket=new int[10][arr.length]; //记录每个桶中实际存放了多少数据 int[] bucketElementCounts=new int[10]; /** * n代表位数，初始化为1，代表个位 */ for (int i=0 ,n = 1;i&lt; maxLength;i++,n *=10){ for (int j=0;j&lt;arr.length;j++){ //取出个位的值 int value= arr[j] /n %10; //放入个位值为value的桶的第bucketElementCounts[value]个位置，刚开始bucketElementCounts[value]为0，每放入一个数据就+1 bucket[value][bucketElementCounts[value]]=arr[j]; bucketElementCounts[value]++; } int index = 0;//原始数组下边，初始为0 // System.out.println(Arrays.toString(bucketElementCounts)); //遍历每个桶，将桶中数据放回原来数组 for (int k=0;k&lt;bucketElementCounts.length;k++){ //第k个桶 不等于0，即该桶有数据 if (bucketElementCounts[k] !=0){ //遍历该桶数据，放入原数组 for (int m=0;m&lt;bucketElementCounts[k];m++){ //取出元素放到arr arr[index++] = bucket[k][m]; } } //第i+1轮处理后，需要将每个bucketElementCounts[k] = 0 bucketElementCounts[k]=0; } System.out.println(\"第\"+(i+1)+\"轮结果\"+ Arrays.toString(arr)); } }} 结果：第1轮结果[0, 21, 542, 53, 3, 14, 748]第2轮结果[0, 3, 14, 21, 542, 748, 53]第3轮结果[0, 3, 14, 21, 53, 542, 748] 测试80w条数据耗时12345678910111213int[] arr =new int[800000]; for (int i=0;i&lt;800000;i++){ arr[i]=(int)(Math.random()*800000); } long begintime=System.currentTimeMillis(); System.out.println(\"开始时间\"+begintime); radixSort(arr); long endtime=System.currentTimeMillis(); System.out.println(\"结束时间\"+endtime); System.out.println(\"用时：\"+(endtime-begintime)+\"ms\"); 结果：开始时间1572416316975结束时间1572416317084用时：109ms 很明显比之前的归并、快速排序都快的多，但是其缺点也是很明显的，对于任何位数上的基数进行“装桶”操作时，都需要n+k个临时空间(k为桶数)，非常耗费空间","link":"/posts/20200107-jishuSort.html"},{"title":"希尔排序-----------java实现","text":"首先看一下之前使用简单插入排序存在的问题： 当存在一个数组，其最后一个数据为最小值，如：arr={5,6,16,34,33,2} 这样的话需要循环到最后一次，也就是第6次的时候，才可以将2排到前边，效率非常低 但是希尔排序（基于插入排序）可以很好的解决这个问题，其是简单插入排序改进后的一个效率较高的排序方式 ，也叫缩小增量排序 复杂度： 平均时间： O（nlogn） 最差: O(n²) 最优: O(n^1/3) 空间复杂度：O(1) 稳定性： 不稳定 比插入和选择排序快得多，且数组越大，优势越大 一、基本思想希尔排序按某个增量分组，对每个分组使用直接插入排序实现，随着增量逐渐减小，每组数据逐渐增加，当增量减少至1时，仅剩下完整的一组，排序结束。 二、排序分析) 图片引用自https://blog.csdn.net/qq_28081081/article/details/80598960 三、代码实现1234567891011121314151617181920212223242526272829303132/** * 希尔排序 * @author MaoLin Wang * @date 2019/10/2817:43 */public class ShellSort { public static void main(String[] args) { int[] arr={214,32,11,2,3,2,66,33,54,12}; shellSort(arr); } public static void shellSort(int[]arr){ int temp=0; int count=0; for (int group =arr.length/2;group&gt;0;group/=2){ for (int i=group;i&lt;arr.length;i++){ for (int j=i-group;j&gt;=0;j-=group){ if (arr[j]&gt;arr[j+group]){ temp=arr[j]; arr[j]=arr[j+group]; arr[j+group]=temp; } } } System.out.println(\"第\"+(++count)+\"次排序结果：\"); System.out.println(Arrays.toString(arr)); } }} 结果： 123456第1次排序结果：[2, 32, 11, 2, 3, 214, 66, 33, 54, 12]第2次排序结果：[2, 2, 3, 12, 11, 32, 54, 33, 66, 214]第3次排序结果：[2, 2, 3, 11, 12, 32, 33, 54, 66, 214] 测试100000条数据耗时： 123456789101112int[] arr =new int[100000];for (int i=0;i&lt;100000;i++){ arr[i]=(int)(Math.random()*100000);}long begintime=System.currentTimeMillis();System.out.println(\"开始时间\"+begintime);shellSort(arr);long endtime=System.currentTimeMillis();System.out.println(\"结束时间\"+endtime);System.out.println(\"用时：\"+(endtime-begintime)+\"ms\"); 结果： 123开始时间1572260920132结束时间1572260930389用时：10257ms 发现用了10000多ms，不但没有提高效率，反而低了非常多，这是为什么呢？ 仔细看我们的代码进行交换的条件，发现只要满足arr[j]&gt;arr[j+group]就要进行交换，无疑增加了系统开销 接下来对代码进行优化： 123456789101112131415161718192021222324252627282930313233public static void shellSort2(int arr[]) { for (int group = arr.length / 2; group &gt; 0; group /= 2) { for (int i = group; i &lt; arr.length; i++) { int j = i; int temp = arr[j]; if (arr[j] &lt; arr[j - group]) { while ((j - group) &gt;= 0 &amp;&amp; temp &lt; arr[j - group]) { /** * 开始移动，将比arr[j]大的arr[j-group]、arr[j-group-group]......按顺序移动到后一个增量的位置 * 如 3, 2, 11, 21, 66, 32, 214, 4 * 在group减少到2，比较32和4的时候 * 1. 4&lt;32 且满足while条件， 所以将32移动到4,temp=4，j=5，指向32的位置 * 此时的数据为:3, 2, 11, 21, 66, 32, 214, 32 * 2.继续while循环 * j-group=3&gt;0 temp=4&lt;arr[3]=21，满足while条件 * 执行arr[j]=arr[j-group] -&gt; 将21的位置移动到32,temp仍然为一开始的4,j=3，指向21的位置 * 此时数据为：3, 2, 11, 21, 66, 21, 214, 32 * 3.继续循环while * j-group=1&gt;0 temp=4&gt;arr[1]=2 不满足while条件，退出循环 * 4.此时j=3，将temp=4赋值给arr[j] * 此时数据为：3, 2, 11, 4, 66, 21, 214, 32 */ arr[j] = arr[j - group]; j -= group; } //结束while循环后，将temp插入到arr[j] arr[j] = temp; } } } } 或用for循环： 1234567891011121314public static void shellSort(int[] arr){ int j; for (int gap = arr.length/2; gap &gt;0 ; gap/=2) { for (int i = gap; i &lt; arr.length; i++) { int temp=arr[i]; for ( j = i; j -gap &gt;=0&amp;&amp;temp&lt;arr[j-gap] ; j-=gap) { arr[j]=arr[j-gap]; } arr[j]=temp; } } } 同样测试10000条数据排序的耗时： 123开始时间1572264172662结束时间1572264172692用时：30ms 耗时从1w多ms减小到30ms，多次测试上下波动也不会超过20ms","link":"/posts/20200107-shellSort.html"},{"title":"快速排序-------------java实现","text":"一、基本思想选择一个基准数，通过一趟排序将待排序数据分成两个独立的部分，其中一部分的所有数都比基准数小，另一部分都比基准数大，然后再使用此方法递归对两部分数据进行快排，最终实现整个数据的有序。 二、详解排序过程现有待排序数据： 1{-21, 312, 44, 11, -23, 2, 10}; 左哨兵记为left，右哨兵记为right 基数=取第一个位置的元素 先取-21作为基数： 第一轮排序： ​ ↓ ↓ ​ -21， 312， 44， 11， -23， 2， 10 ​ 左哨兵找到第一个比基数-21大的数停止，即在312停止，此时left=1 ​ 右哨兵找到第一个比基数小的数停止，即在-23停止，此时right=4 ​ 此时两个哨兵尚未相遇，交换 312 和 -23 交换后： ​ ↓ ↓ ​ -21， -23， 44， 11， 312， 2， 10 左哨兵继续移动，到比-21大的44时停止，此时left=2 右哨兵继续移动，到比-21小的-23处停止，此时right=1 但因为left&gt;right，表示二者已经相遇，终止本次循环，将pivot与right位置元素交换 三、代码实现：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475/** * 快速排序 * @author * @date 2019/10/2917:06 */public class QuickSort { public static void main(String[] args) { int[] arr={-21,312,44,11,-23,2,10}; quickSort(arr,0,arr.length-1); System.out.println(Arrays.toString(arr)); } public static &lt;T extends Comparable&lt;? super T&gt;&gt; void quickSort(T[] arr) { if (arr.length==0||arr.length==1){ return; } quickSort(arr, 0, arr.length - 1); } private static &lt;T extends Comparable&lt;? super T&gt;&gt; void quickSort(T[] arr, int left, int right) { if (right&lt;=left){ return; } //此时j左边的元素已全部小于arr[j],j右边的元素全部小于arr[j] int j=partition(arr,left,right); quickSort(arr,left,j-1); quickSort(arr,j+1,right); } /** * 快速排序的切分 * @param arr * @param left * @param right * @param &lt;T&gt; * @return */ public static &lt;T extends Comparable&lt;? super T&gt;&gt; int partition(T[] arr, int left, int right) { int i=left,j=right+1; T pivot = arr[left]; while (true){ //循环直到找到一个比pivot大的值，或到达尾部 while (arr[++i].compareTo(pivot)&lt;0){ if (i==right){ break; } } //循环直到找到一个比pivot小的值，或到达首部 while (pivot.compareTo(arr[--j])&lt;0){ if (j==left){ break; } } //如果i和j相遇，则终止循环 if (i&gt;=j){ break; } //交换i和j的元素 swapReferences(arr,i,j); } //将pivot换到j的位置 swapReferences(arr,left,j); return j; } public static &lt;T&gt; void swapReferences(T[] arr,int index1,int index2){ T temp=arr[index1]; arr[index1]=arr[index2]; arr[index2]=temp; }} 结果： [-23, -21, 2, 10, 11, 44, 312] 四、测试10W条数据耗时123456789101112int[] arr =new int[100000];for (int i=0;i&lt;100000;i++){ arr[i]=(int)(Math.random()*100000);}long begintime=System.currentTimeMillis();System.out.println(\"开始时间\"+begintime);quickSort(arr,0,arr.length-1);long endtime=System.currentTimeMillis();System.out.println(\"结束时间\"+endtime);System.out.println(\"用时：\"+(endtime-begintime)+\"ms\"); 结果： 123开始时间1572344644967结束时间1572344645031用时：64ms 此时与希尔排序看不出很大的差距，将数据增加到80W条测试结果： 希尔： 开始时间1572344777821结束时间1572344778134用时：313ms 快速： 开始时间1572344758536结束时间1572344758711用时：175ms 经过多次测试，偶尔会有希尔排序比快速快的情况，但是多数情况下还是快速比希尔快 五、优化改进—三取样切分：在有大量重复元素的情况下，假如一个元素的子数组全部重复时，我们的快速排序还会继续将其切分为更小的数组，如果我们不对它进行排序，那么性能会提升很多，从当前的线性对数级别提高到线性级别。 此时我们可以将数组切分为三部分，分别对应小于、等于和大于切分元素的数组。 思路如下： 维护一个指针lt，使得a[left]到a[lt-1]都小于切分元素v 一个指针gt，使得a[gt+1]到a[right]都大于切分元素v 一个指针i，使用a[lt]到a[i-1]都等于切分元素v 而a[i]到a[gt]元素尚未确定。 当i&lt;=gt时循环： 1.a[i] &lt; v: 将a[i]与a[lt]交换，并让 i 和 lt 加一，此时lt左边的一定小于v 2.a [i] &gt; v: 将a[i]与a[gt]交换，并让 gt 减一，此时gt右边的一定大于v 3. a[i] = v : 直接让 i 加以 此时 lt 到 i-1 都等于v 实现如下： 1234567891011121314151617181920212223242526272829303132/** * 三取样切分 * @param arr * @param left * @param right * @param &lt;T&gt; */ public static &lt;T extends Comparable&lt;? super T&gt;&gt; void quickSort3Way(T[] arr, int left, int right) { if (right&lt;=left){ return; } if (left+1&lt;=right){ //初始化三个指针 int lt=left,i=lt+1,gt=right; T v = arr[left]; while (i&lt;=gt){ int result=arr[i].compareTo(v); if (result&lt;0){ swapReferences(arr,lt++,i++); }else if (result&gt;0){ swapReferences(arr,i,gt--); }else { i++ ; } } quickSort3Way(arr,left,lt-1); quickSort3Way(arr,gt+1,right); }else { insertSort(arr,left,right); } } 但是该算法在重复元素不多的普通情况下比标准的算法多用了很多次交换。而解决该问题的快速三向排序的最优解法由J.Bently和D.McIlroy给出答案。 算法第四版中2.3节课后练习2.3.22题给出了相关解读。 有时间再解读，相关实现如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152package com.datastructures2.sort;import edu.princeton.cs.algs4.StdIn;import edu.princeton.cs.algs4.StdOut;public class Quick3Way { // cutoff to insertion sort, must be &gt;= 1 private static final int INSERTION_SORT_CUTOFF = 8; // cutoff to median-of-3 partitioning private static final int MEDIAN_OF_3_CUTOFF = 40; // This class should not be instantiated. private Quick3Way() { } /** * Rearranges the array in ascending order, using the natural order. * * @param a * the array to be sorted */ public static void sort(Comparable[] a) { sort(a, 0, a.length - 1); } private static void sort(Comparable[] a, int lo, int hi) { int length = hi - lo + 1; // cutoff to insertion sort if (length &lt;= INSERTION_SORT_CUTOFF) { insertionSort(a, lo, hi); return; } // use median-of-3 as partitioning element else if (length &lt;= MEDIAN_OF_3_CUTOFF) { int m = median3(a, lo, lo + length / 2, hi); exch(a, m, lo); } // use Tukey ninther as partitioning element else { int eps = length / 8; int mid = lo + length / 2; int m1 = median3(a, lo, lo + eps, lo + eps + eps); int m2 = median3(a, mid - eps, mid, mid + eps); int m3 = median3(a, hi - eps - eps, hi - eps, hi); int ninther = median3(a, m1, m2, m3); exch(a, ninther, lo); } // Bentley-McIlroy 3-way partitioning int i = lo, j = hi + 1; int p = lo, q = hi + 1; Comparable v = a[lo]; while (true) { while (less(a[++i], v)) if (i == hi) break; while (less(v, a[--j])) if (j == lo) break; // pointers cross if (i == j &amp;&amp; eq(a[i], v)) exch(a, ++p, i); if (i &gt;= j) break; exch(a, i, j); if (eq(a[i], v)) exch(a, ++p, i); if (eq(a[j], v)) exch(a, --q, j); } i = j + 1; for (int k = lo; k &lt;= p; k++) exch(a, k, j--); for (int k = hi; k &gt;= q; k--) exch(a, k, i++); sort(a, lo, j); sort(a, i, hi); } private static void insertionSort(Comparable[] a, int lo, int hi) { for (int i = lo; i &lt;= hi; i++) for (int j = i; j &gt; lo &amp;&amp; less(a[j], a[j - 1]); j--) exch(a, j, j - 1); } // 返回a [left]，a [mid]和a [right]之间的中值元素的索引 private static int median3(Comparable[] a, int left, int mid, int right) { return (less(a[left], a[mid]) ? (less(a[mid], a[right]) ? mid : less(a[left], a[right]) ? right : left) : (less(a[right], a[mid]) ? mid : less(a[right], a[left]) ? right : left)); } // is v &lt; w ? private static boolean less(Comparable v, Comparable w) { return v.compareTo(w) &lt; 0; } // does v == w ? private static boolean eq(Comparable v, Comparable w) { return v.compareTo(w) == 0; } // exchange a[i] and a[j] private static void exch(Object[] a, int i, int j) { Object swap = a[i]; a[i] = a[j]; a[j] = swap; } /*************************************************************************** * Check if array is sorted - useful for debugging. ***************************************************************************/ private static boolean isSorted(Comparable[] a) { for (int i = 1; i &lt; a.length; i++) if (less(a[i], a[i - 1])) return false; return true; } // print array to standard output private static void show(Comparable[] a) { for (int i = 0; i &lt; a.length; i++) { StdOut.println(a[i]); } } /** * Reads in a sequence of strings from standard input; quicksorts them * (using an optimized version of quicksort); and prints them to standard * output in ascending order. * * @param args * the command-line arguments */ public static void main(String[] args) { String[] a = StdIn.readAllStrings(); Quick3Way.sort(a); assert isSorted(a); show(a); }}","link":"/posts/20200107-quickSort.html"},{"title":"插入排序-----------java实现","text":"一、复杂度123456平均时间复杂度： O(n²)最差时： O(n²)是否稳定： 稳定空间开销： O(1)在大部分数据已经排好序时性能较好也很适合小规模数组 二、基本思想将n个待排序元素看成一个有序表和一个无序表，开始有序表只有一个元素，每次排序从无需表中取第一个元素，将它的值依此和有序表元素的数据比较，插入到有序表的适当位置，形成新的有序表 详解： 初始数据：18, 5, 54, 2, 33, 12 第一次排序：5， 18， 54， 2， 33，12 第二次排序：2，5， 18， 54， 33，12 第三次排序：2，5，12 18， 54， 33 第四次排序：2，5，12 18，33， 54 第五次排序：2，5，12 18，33，54 三、代码实现123456789101112131415161718192021222324252627282930313233343536373839404142434445/** * @author MaoLin Wang * @date 2020/2/1814:35 */public class InsertSort{ /** * 插入排序 * @param arr */ public static &lt;T extends Comparable&lt;? super T&gt;&gt; void insertSort(T [] arr){ int j; for (int i = 1; i &lt; arr.length; i++) { T temp=arr[i]; for ( j = i; j &gt;0&amp;&amp;temp.compareTo(arr[j-1])&lt;0 ; j--) { arr[j]=arr[j-1]; } arr[j]=temp; } } /** * 插入排序 对arr的left到right位置排序 * @param arr * @param &lt;T&gt; */ public static &lt;T extends Comparable&lt;? super T&gt;&gt; void insertSort(T [] arr,int left,int right){ int j; for (int i = left; i &lt;= right; i++) { T temp=arr[i]; for ( j = i; j &gt;left&amp;&amp;temp.compareTo(arr[j-1])&lt;0 ; j--) { arr[j]=arr[j-1]; } arr[j]=temp; } } public static void main(String[] args) { Integer [] arr={2,44,1,2,6,4}; insertSort(arr); for(Integer i:arr){ System.out.println(i); } }} 结果： 123456789101112第1次排序结果：[43, 213, 22, 11, 324, 11, 4]第2次排序结果：[22, 43, 213, 11, 324, 11, 4]第3次排序结果：[11, 22, 43, 213, 324, 11, 4]第4次排序结果：[11, 22, 43, 213, 324, 11, 4]第5次排序结果：[11, 11, 22, 43, 213, 324, 4]第6次排序结果：[4, 11, 11, 22, 43, 213, 324] 四、测试100000条数据耗时123456789101112131415161718192021222324252627282930313233343536373839404142434445464748package com.wml.sort;import java.util.Arrays;/** * @author *** * @date 2019/10/2816:55 */public class InsertSort { public static void main(String[] args) { int[] array =new int[100000]; for (int i=0;i&lt;100000;i++){ array[i]=(int)(Math.random()*100000); } long begintime=System.currentTimeMillis(); System.out.println(\"开始时间\"+begintime); insertSort(array); long endtime=System.currentTimeMillis(); System.out.println(\"结束时间\"+endtime); System.out.println(\"用时：\"+(endtime-begintime)+\"ms\"); } public static void insertSort(int[] arr){ for (int i=1;i&lt;arr.length;i++){ //待插入数据 int insertVal=arr[i]; //待插入位置下标 int insertIndex=i-1; /** * 如果待插入下标小于零，说明待插入数据最小，应放在第一个位置 * 如果待插入值大于arr[inserIndex]，则停止循环，说明待插入值在有序表中是最大的，应插入到当前insertIndex后一个位置 */ while (insertIndex&gt;=0 &amp;&amp; insertVal&lt;arr[insertIndex]){ arr[insertIndex+1]=arr[insertIndex]; insertIndex--; } arr[insertIndex+1]=insertVal; } }} 结果： 123开始时间1572254640158结束时间1572254641586用时：1428ms 相比上一篇的选择排序的5811ms总体又快了许多","link":"/posts/20200107-insertSort.html"},{"title":"选择排序  ------java实现","text":"一、选择排序的思想第一次从arr[0]~arr[n-1]中选取最小值与arr[0]交换，第二次从arr[1]到arr[n-1]中选取最小值与arr[1]交换，第三次从arr[2]到arr[n-1]中选取最小值与arr[2]交换，以此类推，总共循环n-1次，得到一个从小到大的有序序列。 二、思路详解待排序元素： ==[34]== 54 123 55 11 22 第一次排序： ==[11,34]== 54 123 55 22第二次排序 : ==[11,22,34]== 54 123 55第三次排序： ==[11,22,34,54]== 123 55第四次排序： ==[11,22,34,54,55]== 123 说明(这里按从小到大)： 1.选择排序共进行数组大小-1次排序2.每次排序中，先设当前的数是最小值，然后依次和后面的数进行比较，如果发现有比这个数小的，就让最小的数为这个数，得到最小值下标，遍历一个循环后，得到最小值和下标3.如果该小标与一开始的不一样，说明存在比开始设定的最小的数还小的数，将二者交换，进行下一次循环 三、代码实现12345678910111213141516171819202122232425public static void selectSort(int[] arr){ for (int i=0;i&lt;arr.length-1;i++){ int minIndex=i; int min=arr[i]; for (int j=i+1;j&lt;arr.length;j++){ if (min&gt;arr[j]){ min=arr[j]; minIndex=j; } } //将最小值放在arr[0]。即交换 if (minIndex!=i){ arr[minIndex]=arr[i]; arr[i]=min; } System.out.println(\"第\"+(i+1)+\"轮后结果\"); System.out.println(Arrays.toString(arr)); } } public static void main(String[] args) { int[] array={101,222,119,1}; SelectSort.selectSort(array); } 结果： 123456第1轮后结果[1, 222, 119, 101]第2轮后结果[1, 101, 119, 222]第3轮后结果[1, 101, 119, 222] 测试100000条数据执行时间： 12345678910111213141516171819202122232425262728package com.wml.sort;import java.util.Arrays;/** * 选择排序 * @author MaoLin Wang * @date 2019/10/2811:24 */public class SelectSort { public static void main(String[] args) { //int[] array={101,222,119,1}; int[] array =new int[100000]; for (int i=0;i&lt;100000;i++){ array[i]=(int)(Math.random()*100000); } long begintime=System.currentTimeMillis(); System.out.println(\"开始时间\"+begintime); SelectSort.selectSort(array); long endtime=System.currentTimeMillis(); System.out.println(\"结束时间\"+endtime); System.out.println(\"用时：\"+(endtime-begintime)+\"ms\"); } } 结果：用时： 123开始时间1572251978745结束时间1572251984556用时：5811ms 相比上一篇冒泡排序的22113ms快了许多 使用泛型： 12345678910111213141516public static &lt;T extends Comparable&lt;? super T&gt;&gt;void selectSort(T[]arr){ for (int i = 0; i &lt; arr.length; i++) { int minIndex=i; T min=arr[i]; for (int j =i+1; j &lt;arr.length ; j++) { if (arr[j].compareTo(min)&lt;0){ minIndex=j; min=arr[j]; } } if (minIndex!=i){ arr[minIndex]=arr[i]; arr[i]=min; } } } 平均时间： O(n²)最差： O（n²）是否稳定： 不稳定空间复杂度： O（1）备注： n小时较好","link":"/posts/20200107-selectSort.html"},{"title":"Linux命令整理-------------文件管理相关(一)","text":"cat说明：用来显示文本内容(小文件)，对于大文件推荐使用more命令 格式： cat +选项+指定文件 ​ 选项： 123&gt; -n 或 --number：显示行号；&gt; -b 或 --number-nonblank：编号时忽略空白行&gt; -A：显示不可打印字符，行尾显示“$”； 如： 1234567echo xxx&gt;test 若test不存在，则自动创建test并写入xxx，否则直接写入cat 123.txt 屏幕显示123.txt内容cat 文本1 文本2 ... 显示多个文本内容cat 文本1 文本2 &gt; 文本3 将文本1和2的内容合并到文本3中cat 文本1 &gt; 文本2 将文本1内容拷贝到文本2cat /dev/null &gt; 文本1 清空文本1的内容cat &gt;test1.txt &lt;&lt;stop 向test1.txt写入内容，输入stop结束 注意：每次合并时，文本3的内容会被重新覆盖 more全屏幕显示文本文件内容 选项：12345-数字：每屏显示指定行-c：不进行滚屏操作。每次刷新这个屏幕；-s：将多个空行压缩成一行显示；-u：禁止下划线；+数字：从指定数字的行开始显示。 查看时可用命令： Space键：显示文本的下一屏内容。 Enter键：每次刷新一行 H键：显示相关的帮助信息 B键：查看上一屏 q键：退出 ​​ cd1.cd : 进入目录 2.cd ~: 进入用户目录 3.cd - : 进入历史上一级目录，即进此目录之前的那个目录 4.cd .. ：返回上级目录 cd ../../ 有几个.../就返回上几级目录 ls 显示目标列表 选项 -a 显示所有文件（在linux中以.开头的文件为隐藏文件） -l 显示文本的详情包括(权限、拥有者、文件大小、最后修改时间等) -r 将文件反序显示(默认按照英文字母顺序) -t 按照创建时间列出 -A 同 -a ，但不列出 &quot;.&quot; (目前目录) 及 &quot;..&quot; (父目录) -F 在文件名称后加一个符号： *：代表可执行档 /： 代表目录 -R 有文件的目录，也会将其子文件列出 ​ -R举例： -F举例：test2是一个目录。所以在后边显示了一个/ pwd 显示当前工作目录（绝对路径） head 显示指定文件前N行 选项： -n：指定显示前n行 -v：显示文件名的头信息； -q：不显示文件名的头信息。 tail 显示指定文件的末尾N行，默认10行 选项： -c,–bytes=：显示文件尾部的N（N为整数）个字节内 -f&lt;name/descriptor&gt;：动态显示文件尾部内容，如某个动态更新的日志，可以使用-f查看最新的内容 -n：输出文件的尾部N（N位数字）行内容。 –pid=&lt;进程号&gt;：与“-f”选项连用，当指定的进程号的进程终止时退出该命令-q,–quiet,–silent：当有多个文件参数时，不输出各个文件名； -s&lt;秒数&gt;,–sleep-interal=&lt;秒数&gt;：与“-f”连用，指定文件变化时间隔(s) -v,–verbose：当有多个文件参数时，总是输出各个文件名； –help：帮助信息 –version：指令版本 举例： 12345tail test 不指定行数默认显示文件test的最后10行tail -n +10 test 从第10行到最后tail -c 10 test 显示该文件的最后10个字符tail -25 nginx.log 显示最后的 25 行tail -f nginx.log 动态刷新该文件最后的内容 chmod修改文件或目录的权限 权限范围：u: –&gt; User ，当前文件/目录的拥有者g: –&gt; Group ， 所属组o: –&gt; Other ， 除User和所属群组之外的所有用户a: –&gt; All ， 所有用户r: –&gt; 读权限，数字 4w:–&gt; 写权限，数字 2x: 执行/切换权限，数字 1- 无权限，数字 0 语法： chmod [options][参数] 选项： 1234567891011121314151617+ 添加某些权限- 取消某些权限= 指定文件权限r 读权限w 写权限x 可执行权限- 无权限X 给可执行文件设置可执行权限t 只有目录或文件的所有者才可以删除目录下的文件-c ,--changes 效果类似“-v”参数，但仅回报更改的部分，如果文件权限已经改变，显示其操作信息；-f , --quiet, --silent 操作过程中不显示任何错误信息；-R, --recursive 以递归更改其本身及子目录-v, --verbose 显示详情信息--reference=&lt;参考文件或目录&gt; 指定参考文件，非自定义权限--help 显示帮助信息--version 显示版本信息 权限结构： 1-rwxr--r-- 1 user staff 651 Nov 11 11:02 .ignore 第一个 -: 代表是普通文件，若是 d，则代表目录 第一组rwx：即上边的rw-,表示u属组 第二组rwx: 即上边中间的r–，表示g属组 第三组rwx: 即上边最后的r–， 表示其他人的权限 r:读 4 w：写 2 x：执行 1 举例: 1234567chmod u+w,g+r test1 为test1设置当前用户可写，组可读的权限chmod u=rwx,g=rw,o=r test1 当前用户可读写执行，组可读写，其他用户只能读chmod 764 test1 当前用户读写执行，组读写，其他只可读chmod a+r test1 所有用户都只可读test1chmod ugo-r test1 所有用户减掉可读权限 chmod -R 755 /usr/local/test/ 递归修改test目录下的子文件的权限为 755,7即4+2+1，5即4+1chown john:student test1 把test1给John，添加到student组 chown 改变文件或目录的拥有者或所属群组 可以给某个用户授权，使该用户变成指定文件的所有者或者改变文件所属的组。 语法： chown [options][参数] 选项： 12345-c，--changes：显示修改的部分；-f ：不显示错误信息；-h：只对符号连接的文件作修改，而不更改其他任何相关文件；-R：递归处理指定目录下的所有文件及子目录-v：显示指令执行过程信息 123chown -R wml:mygroup /usr/local/test1 将/usr/local/test下面的所有文件以及子目录的文件拥有者改为wml,群组为mygroup - ## cmp 比较两个二进制文件是否有差异，若无差异则不显示任何信息，若有差异则显示第一个不同的地方的字符和列数 **语法：** cmp [options][参数] **选项：** 12-l：对于每处不同，显示十进制的字节数和八进制的不同字节。；-s，--quit，--silent：不显示错误信息； **举例:** 123.txt ： 我是123 222 222.txt: 我是222 222 1cmp 123.txt 222.txt --结果--&gt;123.txt 222.txt differ: byte 1, line 1 - ## diff 比较两个文件的不同，该命令是采取逐行比较的方式， **选项：** 12345678910111213-&lt;行数&gt;：指定显示多少行的文本-a，--text：将文件当做文本文件处理-b：忽略空格字符造成的不同；-B，--ignore-blank-lines：忽略空白行；-c：显示两个文件的全部内容，并标出不同之处-H，--speed-large-files：加速大文件检索-i，--ignore-case：忽略大小写不同-l或——paginate：分页-q或--brief：仅显示有无差异，不显示详细的信息 有不同的结果:Files 123.txt and 222.txt differ-r，--recursive：比较子目录中的文件-T：每行对齐输出-y：并列打印 举例： ![在这里插入图片描述](https://img-blog.csdnimg.cn/20191028231857879.png) - ## file 检测目标文件类型 **选项：** 1234-b：不显示文件名称L-L：直接显示符号连接所指向的文件类别；-v：显示版本信息；-z：尝试去解读压缩文件的内容。 **举例：** 123[admin@ test]$ file 123.txt 222.txt123.txt: UTF-8 Unicode text222.txt: UTF-8 Unicode text find查询指定目录下的文件选项： 123456789101112131415161718192021-depth：从指定目录的最深层的子目录开始查找-maxdepth&lt;目录深度&gt;：最大目录深度-mindepth&lt;目录深度&gt;：最小目录层级；-empty：查找大小为0 的文件或空目录-exec&lt;要执行的指令&gt;：若find指令返回True，就执行目标指令(如找到空的就执行rm删除目标文件)-fstype&lt;文件系统类型&gt;：只寻找该文件系统类型下的文件或目录；-ls：将文件或目录名称列出到标准输出(权限信息，所属用户、组，时间信息等)-name&lt;inputname&gt;，-iname：查询名称符合inputname的文件，-iname忽略大小写-anewer test : 比文件 file 更晚被读取过的文件-path&lt;testPath&gt;，-ipath&lt;testPath&gt;：路径符合testPath的文件,-ipath 忽略大小写-perm&lt;权限值&gt;：查找符合指定的权限数值的文件-print：将文件或目录名称列出到标准输出。格式为每列一个名称，每个名称前皆有“./”字符串；-printf&lt;输出格式&gt;：自定义格式输出-size&lt;文件大小&gt;：查找符合指定大小的文件-type&lt;文件类型&gt;：指定的文件类型的文件-user&lt;拥有者名称&gt;：指定用户拥有的文件 举例： 1.find. 列出当前目录的所有文件及其子文件 123456789 find . 结果：../333.txt./222.txt./test2./test2/123.txt./123.txt./empty.txt 2.find /usr/test -name “*.txt”：查找test目录下后缀名为txt的文件 1234567find /usr/test -name \"*.txt\"结果：/usr/test/333.txt/usr/test/222.txt/usr/test/test2/123.txt/usr/test/123.txt/usr/test/empty.txt 3.find /usr/test ! -name “*.txt”：查找test目录下后缀名不是txt的文件 4.根据文件类型查找 -type: 1find . -type 参数 类型参数： f ：普通文件 l ：符号连接 d ：目录 c ：字符设备 b ：块设备 s ：套接字 p ：Fifo 5.查找小于3k的文件 1find . -size -3k 结果： ./333.txt ./222.txt ./test2/123.txt ./123.txt ./empty.txt 6.查找大小为0的文件 12[root@ test] find -empty./empty.txt 7.查找指定权限的文件 首先给123.txt赋予77权限： 1chmod 777 123.txt 查看下结果： 12345-rwxrwxrwx 1 777 root 21 Oct 28 23:08 123.txt-rw-r--r-- 1 root root 15 Oct 28 22:57 222.txt-rw-r--r-- 1 root root 23 Oct 27 22:46 333.txt-rw-r--r-- 1 root root 0 Oct 29 15:20 empty.txtdrwxr-xr-x 2 root root 4096 Oct 27 19:52 test2 只有123.txt的权限为777, 执行查找： 1find -perm 777 结果： 1./123.txt ​ 持续更新………","link":"/posts/20200106-linux_file_1.html"},{"title":"（复习）二叉树的三种遍历方式、查找和删除----------Java实现","text":"一、概念：二叉树二叉树的每个节点最多只能由两个子节点 性质： 二叉树的第 i 层最多有 2 ^ (i-1) 个节点 深度为 k （ k≥0 ）的二叉树最少有 k 个节点(一层一个)，最多有 （2^k ）-1 个节点 （空树k=0，只有一个根节点k=1） 对于任意一个非空二叉树，若其 叶子节点数为 n，度为2的非叶子节点数为 m，则 ==n=m+1==，（度 即节点所拥有的子树的个数） 如果节点总数为 2^n-1 且所有叶子节点都在最后一层，则该树为==满二叉树== 如果该二叉树的所有叶子节点都在最后一层或者倒数第二层，而且最后一层的叶子节点在左边连续，倒数第二层的叶子节点在右边连续，则称为==完全二叉树==。如下： 二、三种遍历方式2.1前序遍历根节点 —&gt; 左孩子 —&gt; 右孩子以上图为例，前序遍历结果为：11，21,14,81,91,15,31，61,71 2.2 中序遍历左孩子 –&gt; 根节点 —&gt; 右孩子 上图为例，结果为：81,14,91,21,15,11,61,31,71 2.3 后序遍历左孩子 –&gt; 右孩子 —&gt; 根节点 上图为例，结果为：81,91,14,15,21,61,71,31,11 三、代码实现遍历3.1首先创建TreeNode类作为数节点这里方便使用直接都设为了public 12345678910111213141516171819class TreeNode { public int no;//节点编号 public TreeNode lchild;//左孩子 public TreeNode rchild;//右孩子 public TreeNode() { } public TreeNode(int no) { this.no = no; } @Override public String toString() { return \"TreeNode{\" + \"no=\" + no + '}'; }} 3.2 创建二叉树类12345678//定义二叉树class BinaryTree { private TreeNode root; public void setRoot(TreeNode root) { this.root = root; }} 3.3 前序遍历方法： 1.首先输出根节点 2.左孩子非空时，递归遍历左孩子 3.右孩子非空时，递归遍历右孩子 1234567891011121314/** * 前序遍历： 根节点-&gt;左节点-&gt;右节点 */ public void preOrder() { System.out.println(this);//先输出父节点 //向左递归 if (this.lchild != null) { this.lchild.preOrder(); } //向右递归 if (this.rchild != null) { this.rchild.preOrder(); } } 3.4 中序遍历方法： 1.左孩子非空时，递归遍历左孩子 2.首先输出根节点 3.右孩子非空时，递归遍历右孩子 123456789101112131415/** * 中序遍历： 左节点-&gt;根节点-&gt;右节点 */ public void midOrder() { //向左递归 if (this.lchild != null) { this.lchild.midOrder(); } System.out.println(this);//输出根节点 //向右递归 if (this.rchild != null) { this.rchild.midOrder(); } } 3.5 后序遍历方法： 1.左孩子非空时，递归遍历左孩子 2.右孩子非空时，递归遍历右孩子 3.首先输出根节点 12345678910111213141516/** * 后序遍历： 左节点-&gt;右节点-&gt;根节点 */ public void postOrder() { //向左递归 if (this.lchild != null) { this.lchild.postOrder(); } //向右递归 if (this.rchild != null) { this.rchild.postOrder(); } System.out.println(this);//输出根节点 } 其实就是把输出根节点的位置按先中后的顺序换来换去 3.6 在二叉树中调用一下方法应先判断根节点是否为空，不为空时才遍历 123456789101112131415161718192021222324//前序遍历 public void preOrder(){ if (this.root!=null){ this.root.preOrder(); }else { System.out.println(\"二叉树为空\"); } } //中序遍历 public void midOrder(){ if (this.root!=null){ this.root.midOrder(); }else { System.out.println(\"二叉树为空\"); } } //后续遍历 public void postOrder(){ if (this.root!=null){ this.root.postOrder(); }else { System.out.println(\"二叉树为空\"); } } 测试按照一开始的那个图创建二叉树： 12345678910111213141516171819202122232425262728293031BinaryTree binaryTree=new BinaryTree(); //创建根节点 TreeNode root = new TreeNode(11); TreeNode treeNode2 = new TreeNode(21); TreeNode treeNode3 = new TreeNode(31); TreeNode treeNode4 = new TreeNode(14); TreeNode treeNode5 = new TreeNode(15); TreeNode treeNode6 = new TreeNode(61); TreeNode treeNode7 = new TreeNode(71); TreeNode treeNode8 = new TreeNode(81); TreeNode treeNode9 = new TreeNode(91); root.lchild =treeNode2; root.rchild =treeNode3; treeNode3.rchild =treeNode7; treeNode3.lchild =treeNode6; treeNode2.lchild =treeNode4; treeNode2.rchild =treeNode5; treeNode4.lchild =treeNode8; treeNode4.rchild =treeNode9; binaryTree.setRoot(root); System.out.println(\"中序-------\"); binaryTree.midOrder(); System.out.println(\"前序--------\"); binaryTree.preOrder(); System.out.println(\"后续--------\"); binaryTree.postOrder(); 结果： 123456789101112131415161718192021222324252627282930中序-------TreeNode{no=81}TreeNode{no=14}TreeNode{no=91}TreeNode{no=21}TreeNode{no=15}TreeNode{no=11}TreeNode{no=61}TreeNode{no=31}TreeNode{no=71}前序--------TreeNode{no=11}TreeNode{no=21}TreeNode{no=14}TreeNode{no=81}TreeNode{no=91}TreeNode{no=15}TreeNode{no=31}TreeNode{no=61}TreeNode{no=71}后续--------TreeNode{no=81}TreeNode{no=91}TreeNode{no=14}TreeNode{no=15}TreeNode{no=21}TreeNode{no=61}TreeNode{no=71}TreeNode{no=31}TreeNode{no=11} 四、三种遍历查询某个节点返回节点编号4.1 前序遍历方法：1.判断当前节点是否满足，满足的话返回该节点，不满足进行 22.判断当前节点的左孩子是否为空，不为空的话递归前序遍历左孩子3.判断当前节点的右孩子是否为空，不为空的话递归前序遍历右孩子实现： 1234567891011121314151617181920212223242526272829303132/** * 前序遍历查找 * @param no * @return */ public TreeNode preOrderFind(int no){ if (this.no==no){ return this; } TreeNode treeNode=null; /** * 判断当前当前节点的左孩子是否为空，不为空 -&gt; 递归前序遍历查找， * 若找到，就返回 */ if (this.lchild !=null){ treeNode=this.lchild.preOrderFind(no); } if (treeNode!=null){ return treeNode; } /** * 判断右孩子是否为空，不为空-&gt;递归前序遍历，无论找没找到都返回treeNode */ if (this.rchild !=null){ treeNode=this.rchild.preOrderFind(no); } return treeNode; } 4.2 中序遍历方法：将当前节点放在左孩子和右孩子中间就好了，其他同上实现： 1234567891011121314151617181920212223242526272829303132/** * 中序遍历查找 * @param no * @return */ public TreeNode midOrderFind(int no){ TreeNode treeNode=null; /** * 判断当前当前节点的左孩子是否为空，不为空 -&gt; 递归前序遍历查找， * 若找到，就返回 */ if (this.lchild !=null){ treeNode=this.lchild.midOrderFind(no); } if (treeNode!=null){ return treeNode; } if (this.no==no){ return this; } /** * 判断右孩子是否为空，不为空-&gt;递归前序遍历，无论找没找到都返回treeNode */ if (this.rchild !=null){ treeNode=this.rchild.midOrderFind(no); } return treeNode; } 4.3 后序遍历方法：将当前节点的比较放在最后就好了，其他同上实现： 1234567891011121314151617181920212223242526272829303132333435363738/** * 后序遍历查找 * @param no * @return */ public TreeNode postOrderFind(int no){ TreeNode treeNode=null; /** * 判断当前当前节点的左孩子是否为空，不为空 -&gt; 递归前序遍历查找， * 若找到，就返回 */ if (this.lchild !=null){ treeNode=this.lchild.postOrderFind(no); } if (treeNode!=null){ return treeNode; } /** * 判断右孩子是否为空，不为空-&gt;递归前序遍历，无论找没找到都返回treeNode */ if (this.rchild !=null){ treeNode=this.rchild.postOrderFind(no); } if (treeNode!=null){ return treeNode; } //左右孩子都没找到，找根节点 if (this.no==no){ return this; } return treeNode; } 4.4 二叉树调用查找方法12345678910111213141516171819202122232425262728293031323334353637/** * 前序遍历查找 * @param no * @return */ public TreeNode preOrderFind(int no){ if (root!=null){ return root.preOrderFind(no); }else { return null; } } /** * 中序遍历查找 * @param no * @return */ public TreeNode midOrderFind(int no){ if (root!=null){ return root.midOrderFind(no); }else { return null; } } /** * 后序遍历查找 * @param no * @return */ public TreeNode postOrderFind(int no){ if (root!=null){ return root.postOrderFind(no); }else { return null; } } 测试：查找6112345678910111213141516171819202122232425//前序遍历查找 System.out.println(\"前序遍历查找==============\"); TreeNode treeNode = binaryTree.preOrderFind(61); if (treeNode!=null){ System.out.println(\"找到了：编号为\"+treeNode.no); }else { System.out.println(\"没找到\"); } //中序遍历查找 System.out.println(\"中序遍历查找====================\") TreeNode midOrderFind = binaryTree.midOrderFind(61); if (midOrderFind!=null){ System.out.println(\"找到了：编号为：\"+midOrderFind.no); }else { System.out.println(\"没找到\"); } //后序遍历查找 System.out.println(\"后序遍历查找=============\"); TreeNode postOrderFind = binaryTree.postOrderFind(61); if (postOrderFind!=null){ System.out.println(\"找到了：编号为\"+postOrderFind.no); }else { System.out.println(\"没找到\"); } 结果： 123456前序遍历查找==============找到了：编号为61中序遍历查找====================找到了：编号为：61后序遍历查找=============找到了：编号为61 五、删除节点当节点为叶子节点时直接删除当节点为非叶子节点时连同其子树一起删除；(不删除子树的方法后续补充)方法：每次的比较对象为当前节点的左右孩子，当左孩子非空且编号与目标节点相同，让左孩子为null当右孩子非空且编号与目标节点相同，让右孩子为null当左右孩子非空时，递归遍历 12345678910111213141516171819/** * 递归删除 */ public void deleteNode(int no){ if (this.lchild !=null &amp;&amp; this.lchild.no==no){ this.lchild =null; return; } if (this.rchild !=null &amp;&amp;this.rchild.no==no){ this.rchild =null; return; } if (this.lchild !=null){ this.lchild.deleteNode(no); } if (this.rchild !=null){ this.rchild.deleteNode(no); } }","link":"/posts/20200107-binarytree.html"},{"title":"模拟先来先服务、短作业优先、时间片轮转以及最高响应比优先调度算法的JAVA实现","text":"这里记录一下操作系统的实验，几个调度算法的原理很好理解，网上也有很多解释，这里不再解释，直接上代码。 一、JCB类1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950public class JCB { public int id; /** * 剩余服务时间 */ public int leftTime; /** * 要求服务时间 */ public int serviceTime; /** * 到达时间 */ public int arriveTime; /** * 开始时间 */ public int beginTime; /** * 结束时间 */ public int finishTime; /** * 优先权 */ public float priority; public JCB(int id, int serviceTime, int arriveTime,float priority) { this.id = id; this.leftTime = serviceTime; this.serviceTime = serviceTime; this.arriveTime = arriveTime; beginTime =0; this.priority=priority; finishTime=0; } @Override public String toString() { return \"JCB{\" + \"id=\" + id + \", serviceTime=\" + serviceTime + \", arriveTime=\" + arriveTime + \", priority=\" + priority + '}'; }} 二、定义所需数据结构1234567891011121314151617181920212223242526272829303132333435363738394041424344454647/** * 时间片轮转算法 * * @author MaoLin Wang * @date 2019/11/3020:03 */public class SchedulingAlgorithm { /** * 就绪队列 */ LinkedList&lt;JCB&gt; readyQueue = null; /** * 结束调度队列 */ LinkedList&lt;JCB&gt; finishQueue = null; /** * 时间段 */ private int cpuTime; /** * 时间片大小 */ private int timeSize; /** * 作业数 */ private int jobNum; private String dispatchName;//调度算法名 /** * 作业周转时间 */ private int[] turnoverTime; /** * 作业带权周转时间· */ private float[] turnoverTimeWithWeight; /** * 平均带权周转时间 */ private float ave;} 三、初始化这里将最高响应比的初始化拉了出来，因为要设置响应比 12345678910111213141516171819202122232425262728293031323334353637383940414243444546/** * 初始化 */ public void init(int jobNum, int timeSize, String dispatchName) { System.out.println(\"开始\" + dispatchName + \"调度\"); readyQueue = new LinkedList&lt;&gt;(); finishQueue = new LinkedList&lt;&gt;(); this.turnoverTime = new int[jobNum]; this.turnoverTimeWithWeight = new float[jobNum]; this.cpuTime = 0; JCB jcb; for (int i = 1; i &lt;= jobNum; i++) { jcb = new JCB(i, (int) (Math.random() * 10 + 1), i - 1, 0); readyQueue.offer(jcb); } this.timeSize = timeSize; this.jobNum = jobNum; this.dispatchName = dispatchName; printInitQueue(); } /** * 初始化高响应比优先队列 * * @param jobNum * @param timeSize * @param dispatchName */ public void HRNInit(int jobNum, int timeSize, String dispatchName) { System.out.println(\"开始\" + dispatchName + \"调度\"); readyQueue = new LinkedList&lt;&gt;(); finishQueue = new LinkedList&lt;&gt;(); this.turnoverTime = new int[jobNum]; this.turnoverTimeWithWeight = new float[jobNum]; this.cpuTime = 0; JCB jcb; for (int i = 1; i &lt;= jobNum; i++) { float v = (float) (Math.random() * 5 + 1); jcb = new JCB(i, (int) (Math.random() * 10 + 1), i - 1, (float) (Math.random() * 5 + 1)); readyQueue.offer(jcb); } this.timeSize = timeSize; this.jobNum = jobNum; this.dispatchName = dispatchName; printInitQueue(); } 作业id默认为序号i，所需服务时间随机生成，到达时间默认从0开始，响应比其他调度算法为0，高响应比算法为随机生成。 四、高响应比优先算法实现逻辑很简单，使用递归实现，参数初始为0，每次取出对头作业，因为这里所有的作业在初始化时数据都初始化好了，所以需判断作业到达时间是否小于cpu时间片，因为只有小于时间片，说明其实际是到达的。 如果小于，则设置其开始时间为cpu当前时间，结束时间为开始时间+服务时间，剩余时间设为0，同时增加cpu时间，将该作业加入已完成队列中，否则，递归调用该算法，参数为index+1，一轮结束后，对作业按响应比排序，继续递归，知道就绪队列为空。 12345678910111213141516171819202122232425262728293031323334 /** * 最高响应比优先算法 */public void HRNAlgorithm(int index) { if (readyQueue.size() == 0) { System.out.println(\"就绪队列为空，调度完毕!\"); return; } JCB head = readyQueue.get(index); if (head.arriveTime &lt;= cpuTime) { readyQueue.poll(); System.out.println(\"-----------------------------------------------------\"); System.out.println(\"时间片: \" + cpuTime + \"开始调度作业:\" + head.id + \", 剩余服务时间: \" + head.leftTime); head.beginTime = cpuTime; head.finishTime = head.beginTime + head.serviceTime; head.leftTime = 0; cpuTime += head.serviceTime; finishQueue.offer(head); System.out.println(\"时间片: \" + cpuTime + \"结束调度作业:\" + head.id + \", 剩余服务时间: \" + head.leftTime); } else { HRNAlgorithm(index++); } sortByPriority(); HRNAlgorithm(0);}/** * 根据响应比排序 */private void sortByPriority() { readyQueue.sort((o1, o2) -&gt; o1.priority &gt; o2.priority ? -1 : 1);} 五、短作业优先调度算法同高响应比优先类似，只是按照要求服务时间排序。 123456789101112131415161718192021222324252627282930313233343536/** * 短作业优先调度算法 */ public void SJFAlgorithm(int index) { if (readyQueue.size() == 0) { System.out.println(\"就绪队列为空，调度完毕！\"); return; } JCB head = readyQueue.get(index); if (head.arriveTime &lt;= cpuTime) { readyQueue.poll(); System.out.println(\"-----------------------------------------------------\"); System.out.println(\"时间片: \" + cpuTime + \"开始调度作业:\" + head.id + \", 剩余服务时间: \" + head.leftTime); head.beginTime = cpuTime; head.finishTime = head.beginTime + head.serviceTime; head.leftTime = 0; cpuTime += head.serviceTime; finishQueue.offer(head); System.out.println(\"时间片: \" + cpuTime + \"结束调度作业:\" + head.id + \", 剩余服务时间: \" + head.leftTime); } else { sortByServiceTime(); SJFAlgorithm(index++); } sortByServiceTime(); SJFAlgorithm(0); } /** * 根据要求服务时间从小到大排序 */ private void sortByServiceTime() { readyQueue.sort((o1, o2) -&gt; o1.serviceTime &lt; o2.serviceTime ? -1 : 1); } 六、先来先服务 最简单的一个算法，直接按顺序取出队头作业执行。 12345678910111213141516171819202122/** * 先来先服务调度算法 */ public void FCFSAlgorithm() { if (readyQueue.size() == 0) { System.out.println(\"就绪队列为空，调度完毕！\"); return; } JCB head = readyQueue.poll(); System.out.println(\"-----------------------------------------------------\"); System.out.println(\"时间片: \" + cpuTime + \"开始调度作业:\" + head.id + \", 剩余服务时间: \" + head.leftTime); head.beginTime = cpuTime; head.leftTime = 0; head.finishTime = head.beginTime + head.serviceTime; cpuTime += head.serviceTime; finishQueue.offer(head); System.out.println(\"时间片: \" + cpuTime + \"结束调度作业:\" + head.id + \", 剩余服务时间: \" + head.leftTime); FCFSAlgorithm(); } 七、时间片轮转算法 这里需要根据作业剩余需要服务的时间跟时间片大小做对比，代码很好理解。 123456789101112131415161718192021222324252627282930313233343536/** * 时间片轮转算法 */ public void RRAlgorithm() { if (readyQueue.size() == 0) { System.out.println(\"就绪队列为空，调度完毕！\"); return; } JCB head = readyQueue.poll(); System.out.println(\"-----------------------------------------------------\"); System.out.println(\"时间片: \" + cpuTime + \"开始调度作业:\" + head.id + \", 剩余服务时间: \" + head.leftTime); head.beginTime = cpuTime; if (head.leftTime &gt; timeSize) { //服务时间大于时间片大小 head.leftTime -= timeSize; //重新加入到就绪队列尾部 readyQueue.offer(head); cpuTime += timeSize; } else if (head.leftTime == timeSize) { //服务时间等于时间片大小 cpuTime += timeSize; head.finishTime = cpuTime; head.leftTime = 0; //加入结束队列 finishQueue.offer(head); } else { //服务时间小于时间片大小 head.finishTime = cpuTime + head.leftTime; head.leftTime = 0; cpuTime += head.leftTime; finishQueue.offer(head); } System.out.println(\"时间片: \" + cpuTime + \"结束调度作业:\" + head.id + \", 剩余服务时间: \" + head.leftTime); RRAlgorithm(); } 八、计算周转时间和带权周转时间12345678910111213141516171819/** * 计算周转时间和带权周转时间 * @param finishQueue */ public void R_Dis(Queue&lt;JCB&gt; finishQueue) { Queue&lt;JCB&gt;temp=finishQueue; JCB tempJcb; float sum = 0; for (int i = 0; i &lt; jobNum; i++) { tempJcb=temp.poll(); turnoverTime[i] = tempJcb.finishTime - tempJcb.arriveTime; turnoverTimeWithWeight[i] =(float) turnoverTime[i] / tempJcb.serviceTime; sum += turnoverTimeWithWeight[i]; temp.offer(tempJcb); } float ave = sum / jobNum; this.ave = ave; } 九、打印结果123456789101112131415161718192021222324252627282930313233343536public void printResult(boolean isHRN) { R_Dis(this.finishQueue); System.out.println(\"=====================\" + this.dispatchName + \"调度结果为=========================\"); if (isHRN) { System.out.println(\"进程名\\t\" + \"到达时间\\t\" + \"要求服务时间\\t\" + \"响应比\\t\" + \"开始时间\\t\" + \"完成时间\\t\" + \"周转时间\\t\" + \"带权周转时间\\t\"+\"平均带权周转时间\\t\"); } else { System.out.println(\"进程名\\t\" + \"到达时间\\t\" + \"要求服务时间\\t\" + \"开始时间\\t\" + \"完成时间\\t\" + \"周转时间\\t\" + \"带权周转时间\\t\"+\"平均带权周转时间\\t\"); } int count = 0; for (JCB jcb : this.finishQueue) { if (isHRN) { System.out.println(\" \" + jcb.id + \"\\t\\t\\t\" + jcb.arriveTime + \"\\t\\t\" + jcb.serviceTime + \"\\t\\t\" + jcb.priority + \"\\t\\t\" + jcb.beginTime + \"\\t\\t\" + jcb.finishTime + \"\\t\\t\" + turnoverTime[count] + \"\\t\\t\" + turnoverTimeWithWeight[count]+\"\\t\\t\"+this.ave); count = count + 1; } else { System.out.println(\" \" + jcb.id + \"\\t\\t\\t\" + jcb.arriveTime + \"\\t\\t\" + jcb.serviceTime + \"\\t\\t\" + jcb.beginTime + \"\\t\\t\" + jcb.finishTime + \"\\t\\t\" + turnoverTime[count] + \"\\t\\t\" + turnoverTimeWithWeight[count]+\"\\t\\t\"+this.ave); count = count + 1; } } } /** * 打印初始化队列 */ private void printInitQueue() { System.out.println(\"当前就绪队列为:\"); for (JCB jcb2 : readyQueue) { System.out.println(jcb2); } } 测试1234567891011121314151617181920212223public class Test { public static void main(String[] args) { SchedulingAlgorithm schedulingAlgorithm = new SchedulingAlgorithm(); schedulingAlgorithm.init(5, 2,\"轮转\"); schedulingAlgorithm.RRAlgorithm(); schedulingAlgorithm.printResult(false); schedulingAlgorithm.init(5,3,\"先来先服务\"); schedulingAlgorithm.FCFSAlgorithm(); schedulingAlgorithm.printResult(false); schedulingAlgorithm.init(5,3,\"短作业优先服务\"); schedulingAlgorithm.SJFAlgorithm(0); schedulingAlgorithm.printResult(false); schedulingAlgorithm.HRNInit(5,3,\"高响应比优先\"); schedulingAlgorithm.HRNAlgorithm(0); schedulingAlgorithm.printResult(true); }} 结果：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141开始轮转调度当前就绪队列为:JCB{id=1, serviceTime=1, arriveTime=0, priority=0.0}JCB{id=2, serviceTime=5, arriveTime=1, priority=0.0}JCB{id=3, serviceTime=4, arriveTime=2, priority=0.0}JCB{id=4, serviceTime=6, arriveTime=3, priority=0.0}JCB{id=5, serviceTime=6, arriveTime=4, priority=0.0}-----------------------------------------------------时间片: 0开始调度作业:1, 剩余服务时间: 1时间片: 0结束调度作业:1, 剩余服务时间: 0-----------------------------------------------------时间片: 0开始调度作业:2, 剩余服务时间: 5时间片: 2结束调度作业:2, 剩余服务时间: 3-----------------------------------------------------时间片: 2开始调度作业:3, 剩余服务时间: 4时间片: 4结束调度作业:3, 剩余服务时间: 2-----------------------------------------------------时间片: 4开始调度作业:4, 剩余服务时间: 6时间片: 6结束调度作业:4, 剩余服务时间: 4-----------------------------------------------------时间片: 6开始调度作业:5, 剩余服务时间: 6时间片: 8结束调度作业:5, 剩余服务时间: 4-----------------------------------------------------时间片: 8开始调度作业:2, 剩余服务时间: 3时间片: 10结束调度作业:2, 剩余服务时间: 1-----------------------------------------------------时间片: 10开始调度作业:3, 剩余服务时间: 2时间片: 12结束调度作业:3, 剩余服务时间: 0-----------------------------------------------------时间片: 12开始调度作业:4, 剩余服务时间: 4时间片: 14结束调度作业:4, 剩余服务时间: 2-----------------------------------------------------时间片: 14开始调度作业:5, 剩余服务时间: 4时间片: 16结束调度作业:5, 剩余服务时间: 2-----------------------------------------------------时间片: 16开始调度作业:2, 剩余服务时间: 1时间片: 16结束调度作业:2, 剩余服务时间: 0-----------------------------------------------------时间片: 16开始调度作业:4, 剩余服务时间: 2时间片: 18结束调度作业:4, 剩余服务时间: 0-----------------------------------------------------时间片: 18开始调度作业:5, 剩余服务时间: 2时间片: 20结束调度作业:5, 剩余服务时间: 0就绪队列为空，调度完毕！=====================轮转调度结果为=========================进程名 到达时间 要求服务时间 开始时间 完成时间 周转时间 带权周转时间 平均带权周转时间 1 0 1 0 1 1 1.0 2.3733335 3 2 4 10 12 10 2.5 2.3733335 2 1 5 16 17 16 3.2 2.3733335 4 3 6 16 18 15 2.5 2.3733335 5 4 6 18 20 16 2.6666667 2.3733335开始先来先服务调度当前就绪队列为:JCB{id=1, serviceTime=3, arriveTime=0, priority=0.0}JCB{id=2, serviceTime=10, arriveTime=1, priority=0.0}JCB{id=3, serviceTime=7, arriveTime=2, priority=0.0}JCB{id=4, serviceTime=1, arriveTime=3, priority=0.0}JCB{id=5, serviceTime=1, arriveTime=4, priority=0.0}-----------------------------------------------------时间片: 0开始调度作业:1, 剩余服务时间: 3时间片: 3结束调度作业:1, 剩余服务时间: 0-----------------------------------------------------时间片: 3开始调度作业:2, 剩余服务时间: 10时间片: 13结束调度作业:2, 剩余服务时间: 0-----------------------------------------------------时间片: 13开始调度作业:3, 剩余服务时间: 7时间片: 20结束调度作业:3, 剩余服务时间: 0-----------------------------------------------------时间片: 20开始调度作业:4, 剩余服务时间: 1时间片: 21结束调度作业:4, 剩余服务时间: 0-----------------------------------------------------时间片: 21开始调度作业:5, 剩余服务时间: 1时间片: 22结束调度作业:5, 剩余服务时间: 0就绪队列为空，调度完毕！=====================先来先服务调度结果为=========================进程名 到达时间 要求服务时间 开始时间 完成时间 周转时间 带权周转时间 平均带权周转时间 1 0 3 0 3 3 1.0 8.154286 2 1 10 3 13 12 1.2 8.154286 3 2 7 13 20 18 2.5714285 8.154286 4 3 1 20 21 18 18.0 8.154286 5 4 1 21 22 18 18.0 8.154286开始短作业优先服务调度当前就绪队列为:JCB{id=1, serviceTime=8, arriveTime=0, priority=0.0}JCB{id=2, serviceTime=10, arriveTime=1, priority=0.0}JCB{id=3, serviceTime=1, arriveTime=2, priority=0.0}JCB{id=4, serviceTime=10, arriveTime=3, priority=0.0}JCB{id=5, serviceTime=1, arriveTime=4, priority=0.0}-----------------------------------------------------时间片: 0开始调度作业:1, 剩余服务时间: 8时间片: 8结束调度作业:1, 剩余服务时间: 0-----------------------------------------------------时间片: 8开始调度作业:3, 剩余服务时间: 1时间片: 9结束调度作业:3, 剩余服务时间: 0-----------------------------------------------------时间片: 9开始调度作业:5, 剩余服务时间: 1时间片: 10结束调度作业:5, 剩余服务时间: 0-----------------------------------------------------时间片: 10开始调度作业:2, 剩余服务时间: 10时间片: 20结束调度作业:2, 剩余服务时间: 0-----------------------------------------------------时间片: 20开始调度作业:4, 剩余服务时间: 10时间片: 30结束调度作业:4, 剩余服务时间: 0就绪队列为空，调度完毕！=====================短作业优先服务调度结果为=========================进程名 到达时间 要求服务时间 开始时间 完成时间 周转时间 带权周转时间 平均带权周转时间 1 0 8 0 8 8 1.0 3.72 3 2 1 8 9 7 7.0 3.72 5 4 1 9 10 6 6.0 3.72 2 1 10 10 20 19 1.9 3.72 4 3 10 20 30 27 2.7 3.72开始高响应比优先调度当前就绪队列为:JCB{id=1, serviceTime=1, arriveTime=0, priority=5.41018}JCB{id=2, serviceTime=6, arriveTime=1, priority=5.1338425}JCB{id=3, serviceTime=6, arriveTime=2, priority=3.1670618}JCB{id=4, serviceTime=6, arriveTime=3, priority=2.0463989}JCB{id=5, serviceTime=1, arriveTime=4, priority=4.711568}-----------------------------------------------------时间片: 0开始调度作业:1, 剩余服务时间: 1时间片: 1结束调度作业:1, 剩余服务时间: 0-----------------------------------------------------时间片: 1开始调度作业:2, 剩余服务时间: 6时间片: 7结束调度作业:2, 剩余服务时间: 0-----------------------------------------------------时间片: 7开始调度作业:5, 剩余服务时间: 1时间片: 8结束调度作业:5, 剩余服务时间: 0-----------------------------------------------------时间片: 8开始调度作业:3, 剩余服务时间: 6时间片: 14结束调度作业:3, 剩余服务时间: 0-----------------------------------------------------时间片: 14开始调度作业:4, 剩余服务时间: 6时间片: 20结束调度作业:4, 剩余服务时间: 0就绪队列为空，调度完毕!=====================高响应比优先调度结果为=========================进程名 到达时间 要求服务时间 响应比 开始时间 完成时间 周转时间 带权周转时间 平均带权周转时间 1 0 1 5.41018 0 1 1 1.0 2.1666665 2 1 6 5.1338425 1 7 6 1.0 2.1666665 5 4 1 4.711568 7 8 4 4.0 2.1666665 3 2 6 3.1670618 8 14 12 2.0 2.1666665 4 3 6 2.0463989 14 20 17 2.8333333 2.1666665","link":"/posts/20200107-OS_dispatch.html"},{"title":"java并发编程之Fork-Join分治编程","text":"一、Fork-Join框架 forkjoin即分而治之，在几大排序算法中，快速排序、归并排序、二分查找均用到了分治的思想，即将一个大问题，逐一分解为一个个小问题，将各个子问题的解最终合并为最终解。这里也是如此，将一个大任务分解成若干个小任务（fork），再将这若干的小任务的执行结果进行合并（join）。 二、工作密取fork-join采用工作密取的方式实现线程的工作负载。forkjoinPool中维护了多个线程执行分下的小任务，当当前线程的任务结束后，会自动获取其他线程的任务继续执行，同时也会根据当前工作线程的空闲情况去获取任务较多的线程的task，以达到线程间的平衡，提供CPU利用率。 三、fork-join的实现forkjoin框架提供了两个子类供我们继承使用。分别是：1.RecursiveAction此类主要用于没有返回值的任务。2.RecursiveTask此类主要用于有返回值的任务 两个类都提供了compute的方法，用于生成、调用子任务，完成分治运算。在compute方法中，需要判断当前任务是否达到设置的阈值，如果小于该值，则直接执行，否则，将该任务分割成两个小任务，再让两个小任务调用invokeAll方法，会再次进入compute方法，重复以上工作。最后使用join方法等到子任务执行结束获取其运行的结果，合并即可。 这里使用invokeAll而不是用invoke主要是因为，如果使用invoke会使任务分离开，两个任务中只工作一个任务，而使用invokeAll可以让两个任务同时工作，提高效率。 fork-join的任务是通过ForkJoinPool池来执行，其提供了两种提交方式，submit和invoke，其中，submit是异步提交，不需要等待任务运行完毕即可运行sumbit之后的代码；相反，invoke是同步执行，必须等待任务完成才会执行invoke之后的代码。 四、使用Foke-Join实现数组求和 4.1创建求和任务类自定义阈值，当任务低于该阈值时直接执行，否则进行分割，任务执行完毕后返回子任务合并的结果。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556public class AddTask extends RecursiveTask&lt;Integer&gt; { /** * 阈值 */ private static final int THRESHOLD=10; private int[] nums; //左边界 private int left; //右边界 private int right; public AddTask(int[] nums, int left, int right) { this.nums = nums; this.left = left; this.right = right; } /** * 生成随机数组 * @return */ public static int[] randomNum(){ Random r = new Random(); int[] nums = new int[100]; for(int i=0;i&lt;100;i++){ nums[i] = r.nextInt(100); } return nums; } @Override protected Integer compute() { if (right-left&lt;THRESHOLD){ //任务在阈值范围内，符合要求，执行执行任务 int sum=0; for (int i = left; i &lt;= right; i++) { try { TimeUnit.MILLISECONDS.sleep(1); } catch (InterruptedException e) { e.printStackTrace(); } sum+=nums[i]; } return sum; }else { //任务太大，需要分割成小任务 int mid=(left+right)/2; AddTask leftTask=new AddTask(nums,left,mid); AddTask rightTask=new AddTask(nums,mid+1,right); invokeAll(leftTask,rightTask); //返回子任务合并的结果 return leftTask.join()+rightTask.join(); } }} 4.2创建Add类调用任务类12345678910111213141516 */public class Add { public static void main(String[] args) { ForkJoinPool forkJoinPool=new ForkJoinPool(); int[] nums = AddTask.randomNum(); System.out.println(\"待求和数组:\"+ Arrays.toString(nums)); //创建求和任务 AddTask addTask=new AddTask(nums,0,nums.length-1); forkJoinPool.invoke(addTask); System.out.println(\"求和中。。\"); System.out.println(\"和为:\"+addTask.join()); }} 结果：待求和数组:[34, 38, 71, 98, 38, 51, 35, 67, 59, 58, 33, 64, 65, 40, 30, 49, 67, 15, 4, 3, 5, 10, 94, 17, 24, 43, 94, 52, 53, 81, 7, 70, 25, 90, 96, 3, 84, 73, 54, 11, 42, 97, 18, 11, 95, 28, 14, 74, 95, 91, 53, 48, 69, 71, 91, 64, 25, 72, 3, 74, 77, 90, 22, 36, 77, 86, 41, 53, 92, 15, 30, 5, 51, 86, 60, 49, 76, 91, 15, 38, 55, 37, 24, 58, 53, 58, 75, 77, 34, 41, 88, 50, 91, 25, 56, 83, 14, 3, 75, 7]求和中。。和为:5134 而如果使用submit提交，将数组大小改为10000，就可看到求和中一句话是在任务执行完毕后才会打印，体现同步性。","link":"/posts/20200123-ForkJoin.html"},{"title":"java并发编程之CountDownLatch,CyclicBarrier和Semaphore","text":"一、CountDownLatch CountDownLatch能够让一个线程在等待其他线程全部完成各自任务后再执行。而CountDownLatch是通过计数器来实现的，计数器的初始值即为任务的总数。 举个例子，如，同学聚会结束回家，每个人都要回各自的家，此时计数器的初始值为参加聚会的总人数，而每个人都是一个线程，每个同学到家后，都需要调用countDown方法，对计数器减一，表示完成回家的任务，当所有同学都到家后，主线程才可以执行通知班长全部到家的任务。再比如，所编写的应用程序，希望等待启动框架的线程启动完毕后再执行。 1.1 构造方法1234public CountDownLatch(int count) { if (count &lt; 0) throw new IllegalArgumentException(\"count &lt; 0\"); this.sync = new Sync(count); } CountDownLatch的构造方法需要一个count参数，代表初始任务的数量，往后每当调用一次（CountDownLatch.countDown()方法，count都减一，当count减到0的时候，调用CountDownLatch.await()方法的线程就可以执行其任务。 除此之外，CountDownLatch还有以下几个方法： 1.await(long timeout,TimeUnit unit) 1234public boolean await(long timeout, TimeUnit unit) throws InterruptedException { return sync.tryAcquireSharedNanos(1, unit.toNanos(timeout)); } 此方法在await()的基础上添加了时间限制，如果调用await的线程在到达该时间后，count仍然没有0，其会继续执行，不再等到count到0。 2. public long getCount() 123public long getCount() { return sync.getCount(); } 即获取该CountDownLatch当前的count值 二、Demo应用12345678910111213141516171819202122232425262728293031323334353637383940414243package com.wml.test1.countdownlatch;import java.util.concurrent.CountDownLatch;/** * @author Wang * @date 2020/1/2317:27 */public class CountDownLatchTest { //1. private static CountDownLatch finishEat=new CountDownLatch(1); //2. private static CountDownLatch friends=new CountDownLatch(10); public static void main(String[] args) throws InterruptedException { //3. for (int i = 0; i &lt;10; i++) { new Thread(()-&gt;{ try { //4. finishEat.await(); System.out.println(Thread.currentThread().getName()+\"正在回家\"); //5. friends.countDown(); System.out.println(Thread.currentThread().getName()+\"到家啦\"); } catch (InterruptedException e) { e.printStackTrace(); } },\"同学\"+(i+1)).start(); } System.out.println(\"聚会结束，同学们准备回家\"); //6. finishEat.countDown(); //7. friends.await(); //8. System.out.println(\"同学全部到家\"); }} 说明：1.代码1创建一个结束聚餐的CountDownLatch，finishEat。初始值为1，代表正在聚餐，当主线程调用countDown()时（代码6），count值从1变为0，代表结束聚餐。这时，其他调用finishEat.await();的线程（各个同学回家的线程）由阻塞状态变为执行。2.代码2创建一个同学回家的CountDownLatch，friends。初始值为10，代表参加聚会的10个同学，即10个同学需要执行回家任务。回家的任务需要在代码4finishEat.await();后执行。3.代码3创建10个回家的线程，每个线程中都执行一次friends.countDown();，让friends的count减一4.代码7friends.await();主线程阻塞等待friends的count变为0时开始执行下面的代码。结果： 1234567891011121314聚会结束，同学们准备回家同学1正在回家同学1到家啦同学2正在回家同学2到家啦同学4正在回家同学4到家啦同学3正在回家同学3到家啦同学5正在回家同学5到家啦同学6正在回家同学6到家啦同学全部到家 三、CyclicBarrierCyclic（循环的）Barrier（屏障），该工具做的事情是，当一个线程到达一个屏障（同步点/临界点）时会被阻塞，等待到最后一个线程到达该点后，被拦截阻塞的线程才可以继续执行。比如：同学聚餐，不会是到一个就吃一个，而是到的人先等待，直到所有人都达到饭桌后，才开始吃饭。这里餐桌就类似barrier，每个同学都是一个线程，每个人到饭桌后都被阻塞，直到最后一个同学到达。而因为CyclicBarrier是可循环的，当一组线程到达后，其仍然有效，可以继续下一组循环。 3.1构造方法1.默认构造方法 123public CyclicBarrier(int parties) { this(parties, null); } 传入的参数表示需要拦截的线程总数，每当一个线程调用CyclicBarrier.await()方法后，会通知CyclicBarrier该线程已到达屏障。与CountDownLatch一样，CyclicBarrier也为await提供了超时时间设置。 123456public int await(long timeout, TimeUnit unit) throws InterruptedException, BrokenBarrierException, TimeoutException { return dowait(true, unit.toNanos(timeout)); } 线程阻塞直到到达超时时间。2.高级构造方法 1public CyclicBarrier(int parties, Runnable barrierAction) 该方法使得线程到达障碍后，优先执行barrierAction的操作。 3.2 CyclicBarrier的方法3.2.1 await1234567public int await() throws InterruptedException, BrokenBarrierException { try { return dowait(false, 0L); } catch (TimeoutException toe) { throw new Error(toe); // cannot happen } } 该方法等待所有的线程都到达指定的临界点。但如果当前线程不是最后到达的线程，则出于线程调度目的将其禁用，并使其处于休眠状态，直到发生以下情况之一： 最后一个线程到达 其他线程中断当前线程 其他线程中断等待线程之一 在屏障等待时其他线程超时 其他线程在此屏障上调用reset方法 在await方法中调用的dowait方法以下是dowait源码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566private int dowait(boolean timed, long nanos) throws InterruptedException, BrokenBarrierException, TimeoutException { final ReentrantLock lock = this.lock; lock.lock(); try { final Generation g = generation; if (g.broken) throw new BrokenBarrierException(); //代码1 if (Thread.interrupted()) { breakBarrier(); throw new InterruptedException(); } //代码2 int index = --count; if (index == 0) { // tripped boolean ranAction = false; try { final Runnable command = barrierCommand; if (command != null) command.run(); ranAction = true; nextGeneration(); return 0; } finally { if (!ranAction) breakBarrier(); } } // 代码3 for (;;) { try { if (!timed) trip.await(); else if (nanos &gt; 0L) nanos = trip.awaitNanos(nanos); } catch (InterruptedException ie) { if (g == generation &amp;&amp; ! g.broken) { breakBarrier(); throw ie; } else { // We're about to finish waiting even if we had not // been interrupted, so this interrupt is deemed to // \"belong\" to subsequent execution. Thread.currentThread().interrupt(); } } if (g.broken) throw new BrokenBarrierException(); if (g != generation) return index; if (timed &amp;&amp; nanos &lt;= 0L) { breakBarrier(); throw new TimeoutException(); } } } finally { lock.unlock(); } } 说明：代码1：如果当前线程被中断，会调用breakBarrier方法并抛出InterruptedException异常。breakBarrier方法如下： 12345private void breakBarrier() { generation.broken = true; count = parties; trip.signalAll(); } 1.breakBarrier首先将该代的broken设置为true，代表其被打破。2.generation是CyclicBarrier的一个静态内部类Generation的对象，该对象代表屏障的当前代，可以实现循环等待。broken为true，则该循环结束。3.同时将count重置为parties； count为计数器，parties是CyclicBarrier的构造参数，代表拦截的线程数4.调用trip的signalAll()方法，将所有阻塞的线程唤醒 trip是成员变量Condition的对象，可见是使用Condition实现阻塞队列的。代码2：计数器count减一并赋值给int变量index，如果此时index值为0，则判断当前barrierCommand是否为空，（barrierCommand也是CyclicBarrier的成员变量，为换代前优先执行的任务，其在CyclicBarrier构造方法中传入，如下： 12345public CyclicBarrier(int parties, Runnable barrierAction) { .......... ........... this.barrierCommand = barrierAction; } ），如果不为空，则执行该操作的run()方法。最后置ranAction为true，个人理解代表继续执行，并执行nextGeneration()进入下一代（下一个循环）。nextGeneration()代码如下： 1234567private void nextGeneration() { // signal completion of last generation trip.signalAll(); // set up next generation count = parties; generation = new Generation(); } 在nextGeneration()中唤醒所有阻塞进程，重置计数器，并重新new了一个Generation。而在finally中，如果barrierCommand执行出错，或其他原因，会执行breakBa在这里插入代码片rrier()方法。代码3：无限循环直到发生tripped，断开，中断或超时。timed代表是否开启超时时间，nanos 为设定的超时时间 3.2.2 getNumberWaiting123456789public int getNumberWaiting() { final ReentrantLock lock = this.lock; lock.lock(); try { return parties - count; } finally { lock.unlock(); }} 返回当前有多少个线程阻塞等待在屏障上 3.3 isBroken1boolean isBroken() 返回查询阻塞等待的线程是否被中断打破 四、CyclicBarrier 例子12345678910111213141516171819202122232425262728293031323334353637package com.wml.test1.cyclicbarrier;import java.util.concurrent.*;/** * @author Wang * @date 2020/1/2317:44 */public class CyclicBarrierTest { //代码1 private static CyclicBarrier barrier=new CyclicBarrier(6,()-&gt;{ System.out.println(\"同学们都到齐了，咱们开饭\"); }); public static void main(String[] args) { ExecutorService pool = new ThreadPoolExecutor(6,100,0L,TimeUnit.MILLISECONDS, new LinkedBlockingDeque&lt;&gt;()); for (int i = 1; i &lt;= 6; i++) { pool.execute(() -&gt; { try { System.out.println(Thread.currentThread().getName() + \"到了\"); //代码2 barrier.await(); System.out.println(Thread.currentThread().getName() + \"开吃\"); } catch (InterruptedException e) { e.printStackTrace(); } catch (BrokenBarrierException e) { e.printStackTrace(); } }); } }} 说明：该例子为同学聚餐，每到一个同学便阻塞自己，当所有同学都到齐后，输出“开饭”，然后唤醒所有同学，执行“吃饭” 代码1：构造一个CyclicBarrier 屏障，拦截线程数为6，在进入下一代前执行System.out.println(&quot;同学们都到齐了，咱们开饭&quot;);这一barrierCommand，即当前代结束（所有线程都到达屏障时或其他原因）后优先执行该操作。代码2：每个线程到达屏障后执行await方法，直到所有线程都到达，await中会执行唤醒所有阻塞线程的方法，最后才会执行后面的代码。结果： 12345678910111213pool-1-thread-1到了pool-1-thread-2到了pool-1-thread-3到了pool-1-thread-4到了pool-1-thread-5到了pool-1-thread-6到了同学们都到齐了，咱们开饭pool-1-thread-6开吃pool-1-thread-2开吃pool-1-thread-3开吃pool-1-thread-5开吃pool-1-thread-4开吃pool-1-thread-1开吃 五、CountDownLatch和CyclicBarrier的异同1.CountDownLatch技术器只能使用一次，CyclicBarrier的可以循环使用。2.CountDownLatch是一个线程等待所有线程完成任务后才会执行自己的任务，是阻塞工作线程。CyclicBarrier是所有线程到达某个屏障（临界点）后互相等待，直到所有线程都到达后再共同进行下面的任务。3.CountDownLatch调用countDown方法可以继续执行后面的，只是调用await方法的线程会阻塞等待直到所有线程都调用countDown；CyclicBarrier是所有的线程调用await进行自阻塞，等到所有线程都调用一次await后一起继续执行后面操作。4.CyclicBarrier可以在所有线程都到达屏障后执行barrierAction操作，完成复杂的逻辑场景。 六、SemaphoreSemaphore即信号量，是用来控制同时访问特定资源的线程数量，或同时执行某个指定操作的数量。比如可以用来实现数据库的连接池等。如数据库的连接数为20个，这时只能有20个线程同时获取数据量连接，再多的线程只能阻塞等待，当一个线程归还连接后，阻塞的线程才能继续获取。 Semaphore的构造方法： 1public Semaphore(int permits) 传入一个整型permits，代表可用的许可证数量。操作时必须先获取许可证，才能继续操作，当操作完成后需释放许可证，其余没有获得许可证的便阻塞等待，直到有线程释放了许可证。线程使用Semaphore的acquire()方法获取许可证，使用release()方法释放许可证，使用tryAcquire()方法尝试获取许可证. 其他方法： 12345intavailablePermits() //返回此信号量中当前可用的许可证数。intgetQueueLength() //返回正在等待获取许可证的线程数。booleanhasQueuedThreads()//是否有线程正在等待获取许可证。void reducePermits（ int reduction） //减少 reduction 个许可证Collection getQueuedThreads() //返回所有等待获取许可证的线程集合 semaphore示例：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566package com.wml.test1.semphore;import java.sql.Connection;import java.util.LinkedList;import java.util.Random;import java.util.concurrent.*;/** * @author Wang * @date 2020/1/2416:31 */public class SemphoreTest { private final static int POOL_SIZE=10; private final Semaphore connections; //连接池 private static LinkedList&lt;Integer&gt;pool; public SemphoreTest() { pool=new LinkedList&lt;&gt;(); //初始化连接池 for (int i = 0; i &lt; POOL_SIZE; i++) { pool.addLast(i); } this.connections = new Semaphore(POOL_SIZE); } //释放连接 public void release(Integer conn){ if(conn!=null) { System.out.println(\"当前有\"+connections.getQueueLength()+\"个线程等待数据库连接!!\" +\"可用连接数：\"+connections.availablePermits()); synchronized (pool) { pool.addLast(conn); } connections.release(); } } //获取连接 public Integer acquire() throws InterruptedException { connections.acquire(); Integer conn; synchronized (pool){ conn=pool.removeFirst(); } return conn; } public static void main(String[] args) { SemphoreTest dbPool=new SemphoreTest(); ExecutorService pool = new ThreadPoolExecutor(50,100,0L, TimeUnit.MILLISECONDS, new LinkedBlockingDeque&lt;&gt;()); //50个线程获取连接 for (int i = 0; i &lt; 50; i++) { pool.execute(()-&gt;{ try { Integer conn=dbPool.acquire(); System.out.println(Thread.currentThread().getName() +\"--------获取数据库连接\"); Thread.sleep(1000); System.out.println(\"归还连接\"); dbPool.release(conn); } catch (InterruptedException e) { } }); } }}","link":"/posts/20200124-cdlcbs.html"},{"title":"java多线程之Callable+Future+FutureTask原理详解和简单使用","text":"一、Runnable和CallableRunnable是一个接口，只声明了一个run()方法，此方法为void类型，所以只能执行无返回值的任务。 123public interface Runnable { public abstract void run();} Callable是java.util.concurrent包下的一个接口，提供了一个call()方法: 12345678910@FunctionalInterfacepublic interface Callable&lt;V&gt; { /** * Computes a result, or throws an exception if unable to do so. * * @return computed result * @throws Exception if unable to compute a result */ V call() throws Exception;} 该方法返回的数据类型就是传进来的泛型类型，主要用于计算产生结果。如果没有计算出结果，则会抛出异常。 二、FutureFuture则是对于具体的Runnable或Callable任务的执行结果进行取消、判断是否完成、获取任务执行结果。Future接口声明了5个方法： 1boolean cancel(boolean mayInterruptIfRunning); 尝试取消此任务的执行。如果取消成功则返回true，取消失败则返回false。 如果任务已完成、已取消或由于其他原因无法取消，则此尝试将失败，返回false。传入的参数如果为true，则直接中断正在执行的任务，返回true；如果为false，则允许正在进行的任务完成。 1boolean isCancelled(); 任务是否被取消成功，如果此任务在正常工作之前被取消，则返回true。 1boolean isDone(); 如果此任务已完成，则返回true。完成可能是由于正常终止、异常或取消 - 在所有这些情况下，此方法将返回 true。 1V get() throws InterruptedException, ExecutionException; 以阻塞的方式获取任务执行结果，知道任务执行完毕返回。另外在以下情况会抛出异常：1.任务被取消：抛出 CancellationException 异常2.计算引发异常：抛出 ExecutionException 异常3.当前线程被中断：抛出 InterruptedException 异常 12V get(long timeout, TimeUnit unit) throws InterruptedException, ExecutionException, TimeoutException; 同上，但规定了超时时间，如果在规定时间内没有计算出结果，会抛出TimeoutException异常。 三、FutureTaskFutureTask类实现了RunnableFuture接口，而RunnableFuture继承了Runnable和Future接口，可知FutureTask可做Runnable和Future一样的事情。 123public class FutureTask&lt;V&gt; implements RunnableFuture&lt;V&gt; public interface RunnableFuture&lt;V&gt; extends Runnable, Future&lt;V&gt; 3.1 首先看FutureTask的成员变量1234567891011121314private volatile int state; private static final int NEW = 0; private static final int COMPLETING = 1; private static final int NORMAL = 2; private static final int EXCEPTIONAL = 3; private static final int CANCELLED = 4; private static final int INTERRUPTING = 5; private static final int INTERRUPTED = 6; private Callable&lt;V&gt; callable; private Object outcome; // non-volatile, protected by state reads/writes private volatile Thread runner; private volatile WaitNode waiters; 1.state：state保存了FutureTask任务的状态值，为volatile类型，保证了原子性，即任何一个线程修改了state的值，都可以保证其他线程看到修改后的值。state共有如下几个取值（对应的值依此为0到6）： NEW：为state的初始值。表示该任务是个新任务。COMPLETING:当前任务已经执行完毕或执行任务过程中出现了异常，但结果尚未保存到outcome（outcome用来保存计算结果或者是异常信息）中，属于中间状态。NORMAL: 任务执行完毕，且结果保存到outcome中。此为最终状态。EXCEPTIONAL: 任务执行过程中出现异常，且异常信息已保存到outcome中。此为最终状态。CANCELLED：任务尚未开始或任务执行时调用了cancel(false)方法。此为最终状态。INTERRUPTING：任务尚未开始或任务执行时调用了cancel(true)方法。此为中间状态。INTERRUPTED: 在调用cancel(true)时，会调用: 123Thread t = runner; if (t != null) t.interrupt(); state会变为INTERRUPTED，此为最终状态。但如果被终端的线程正在sleep()、wait()、或join()，则会抛出InterruptedException()异常，因此cancel(true)（注意：中间状态时间短暂，不代表任务仍在执行，而是任务执行完毕后尚未设置执行结果，因此除了NEW状态，其余状态都代表已经执行结束）可能出现的转变状态为： 1234NEW -&gt; COMPLETING -&gt; NORMALNEW -&gt; COMPLETING -&gt; EXCEPTIONALNEW -&gt; CANCELLEDNEW -&gt; INTERRUPTING -&gt; INTERRUPTED 2.callable：要执行的task任务。3.outcome: 保存执行结果或出现异常时保存异常信息4.runner:执行task的线程，在取消和中断线程时需要知道是哪个线程。5.waiters：为WaitNode 的对象。WaitNode 为一个简单的单向链表结构的队列，当任务执行过程中，有线程想要调用get()获取结果时，则该线程会被阻塞加入WaitNode，直到该任务执行完毕。以下为WaitNode的结构： 12345static final class WaitNode { volatile Thread thread; volatile WaitNode next; WaitNode() { thread = Thread.currentThread(); } } 仅由一个Thread和指向下一个节点的next组成，thread即为当前线程。其本质是一个Treiber栈。 3.2静态代码块中初始化需要CAS操作的属性的偏移量12345678910111213141516171819// Unsafe mechanics private static final sun.misc.Unsafe UNSAFE; private static final long stateOffset; private static final long runnerOffset; private static final long waitersOffset; static { try { UNSAFE = sun.misc.Unsafe.getUnsafe(); Class&lt;?&gt; k = FutureTask.class; stateOffset = UNSAFE.objectFieldOffset (k.getDeclaredField(\"state\")); runnerOffset = UNSAFE.objectFieldOffset (k.getDeclaredField(\"runner\")); waitersOffset = UNSAFE.objectFieldOffset (k.getDeclaredField(\"waiters\")); } catch (Exception e) { throw new Error(e); } } CAS操作调用的是compareAndSwap***方法 3.3 构造方法3.3.1 123456public FutureTask(Callable&lt;V&gt; callable) { if (callable == null) throw new NullPointerException(); this.callable = callable; this.state = NEW; // ensure visibility of callable } 将传入的callable赋值给上面说的成员变量callable，将state初始化为NEW；3.3.2 1234public FutureTask(Runnable runnable, V result) { this.callable = Executors.callable(runnable, result); this.state = NEW; // ensure visibility of callable } 传入Runnable对象，通过Executors.callable()方法将runnable转为callable保存给callable变量，同时会返回传入的result。将runnable转为callable的方法如下： 12345public static &lt;T&gt; Callable&lt;T&gt; callable(Runnable task, T result) { if (task == null) throw new NullPointerException(); return new RunnableAdapter&lt;T&gt;(task, result); } 这里调用RunnableAdapter()适配,代码如下： 12345678910111213static final class RunnableAdapter&lt;T&gt; implements Callable&lt;T&gt; { final Runnable task; final T result; RunnableAdapter(Runnable task, T result) { this.task = task; this.result = result; } public T call() { task.run(); return result; } } } RunnableAdapter实现了Callable接口，在call()中调用task.run()，将传入的result返回。 3.4 方法3.4.1 run()1234567891011121314151617181920212223242526272829303132333435public void run() { //代码1 if (state != NEW || !UNSAFE.compareAndSwapObject(this, runnerOffset, null, Thread.currentThread())) return; try { Callable&lt;V&gt; c = callable; if (c != null &amp;&amp; state == NEW) { //代码2 V result; boolean ran; try { result = c.call(); ran = true; } catch (Throwable ex) { result = null; ran = false; setException(ex); } if (ran) set(result); } } finally { // runner must be non-null until state is settled to // prevent concurrent calls to run() //代码3 runner = null; // state must be re-read after nulling runner to prevent // leaked interrupts int s = state; if (s &gt;= INTERRUPTING) handlePossibleCancellationInterrupt(s); } } 代码1：1.state!=NEW: 如果state不为NEW，即任务已经执行完毕或被取消，直接返回。2. 若state是NEW，则尝试将当前线程保存到runner中，即如果runner为空就将当前线程保存给runner，若runner不为空，则说明已经有线程在执行，直接return,否则进入try-catch。 代码2：1.定义V result保存callable的执行结果，置ran为true，代表执行成功。2.若出现异常，则在catch中捕获，将result置为null，ran置为false代表出现异常，同时通过setException(ex)设置异常。setException(ex)代码如下： 1234567protected void setException(Throwable t) { if (UNSAFE.compareAndSwapInt(this, stateOffset, NEW, COMPLETING)) { outcome = t; UNSAFE.putOrderedInt(this, stateOffset, EXCEPTIONAL); // final state finishCompletion(); } } 此方法中，尝试将state的值从NEW改为COMPLETING,如果成功，则将异常信息保存到outcome中，然后再将状态改为最终态EXCEPTIONAL，最后调用finishCompletion()移除并唤醒WaitNode中所有阻塞等待的线程，调用done()，并让callable无效，源码如下： 12345678910111213141516171819202122private void finishCompletion() { // assert state &gt; COMPLETING; for (WaitNode q; (q = waiters) != null;) { if (UNSAFE.compareAndSwapObject(this, waitersOffset, q, null)) { for (;;) { Thread t = q.thread; if (t != null) { q.thread = null; LockSupport.unpark(t); } WaitNode next = q.next; if (next == null) break; q.next = null; // unlink to help gc q = next; } break; } } done(); callable = null; } 如果ran为true，即正常执行，通过set(result)，set()源码如下： 1234567protected void set(V v) { if (UNSAFE.compareAndSwapInt(this, stateOffset, NEW, COMPLETING)) { outcome = v; UNSAFE.putOrderedInt(this, stateOffset, NORMAL); // final state finishCompletion(); } } 在set()中，尝试将状态从NEW变为COMPLETING中间态(这里再重新理解上面说的state的7个状态会更深刻一点)，并将结果保存给outcome，接着将state由COMPLETING转为NORMAL最终状态，同上调用 finishCompletion()。 代码3：1.在finally中重新将runner置空，表明当前线程运行完毕，在下一个线程进入到run()（代码1）方法时，便可通过CAS重新将线程保存到runner。2.若ran为false，即出现了异常，则调用handlePossibleCancellationInterrupt(state)处理异常， 1234567891011121314151617private void handlePossibleCancellationInterrupt(int s) { // It is possible for our interrupter to stall before getting a // chance to interrupt us. Let's spin-wait patiently. if (s == INTERRUPTING) while (state == INTERRUPTING) Thread.yield(); // wait out pending interrupt // assert state == INTERRUPTED; // We want to clear any interrupt we may have received from // cancel(true). However, it is permissible to use interrupts // as an independent mechanism for a task to communicate with // its caller, and there is no way to clear only the // cancellation interrupt. // // Thread.interrupted(); } 在该方法中，如果状态一直是INTERUPING，则一直进行yield()。 3.4.2 get()线程可调用get()方法获取任务执行的结果，如果当前任务尚未执行完毕，则阻塞调用get()方法的线程，直到任务执行结束。 123456789/** * @throws CancellationException {@inheritDoc} */ public V get() throws InterruptedException, ExecutionException { int s = state; if (s &lt;= COMPLETING) s = awaitDone(false, 0L); return report(s); } get()方法中首先判断当前的状态是否小于等于COMPLETING，即任务是否处于尚未开始或尚未结束或结果尚未保存到outcome的状态，如果是，则调用awaitDone(false, 0L);阻塞等待，否则调用report(s)返回执行结果。 report()12345678private V report(int s) throws ExecutionException { Object x = outcome; if (s == NORMAL) return (V)x; if (s &gt;= CANCELLED) throw new CancellationException(); throw new ExecutionException((Throwable)x); } 获取当前结果outcome，如果当前状态为NORMAL，则直接返回结果，如果当前状态大于等于CANCELLED，则抛出CancellationException()异常，其他状态则抛出ExecutionException()异常。 3.4.3 awaitDone()线程调用此方法阻塞等待任务执行结束。 123456789101112131415161718192021222324252627282930313233343536373839404142434445private int awaitDone(boolean timed, long nanos) throws InterruptedException { //若开启超时，则计算截止时间 final long deadline = timed ? System.nanoTime() + nanos : 0L; //创建一个WaitNode节点 WaitNode q = null; //是否进入阻塞队列 boolean queued = false; for (;;) { //代码1 if (Thread.interrupted()) { removeWaiter(q); throw new InterruptedException(); } int s = state; //代码2 if (s &gt; COMPLETING) { if (q != null) q.thread = null; return s; } //代码3 else if (s == COMPLETING) // cannot time out yet Thread.yield(); //代码4 else if (q == null) q = new WaitNode(); //代码5 else if (!queued) queued = UNSAFE.compareAndSwapObject(this, waitersOffset, q.next = waiters, q); //代码6 else if (timed) { nanos = deadline - System.nanoTime(); if (nanos &lt;= 0L) { removeWaiter(q); return state; } LockSupport.parkNanos(this, nanos); } else LockSupport.park(this); }} 方法的参数为 timed(是否开启超时时间)和nanos(若开启超时时间，则此参数为超时时间)（代码1到代码6在一个无限for循环中，不停的进行循环判断） 代码1：如果当前线程被中断，则将阻塞队列waitNode中的该节点给移除，并抛出InterruptedException()异常。代码2：判断当前阻塞线程的状态是否大于COMPLETING，如果大于，则该任务已经执行完毕，如果当前节点非空，则删除该节点的thread，并返回状态。代码3： 如果当前状态为COMPLETING，则说明任务执行完毕，但是执行结果尚未赋值给outcome，此时执行yield让出CPU。代码4：如果当前阻塞等待节点q为空，则新建一个节点。代码5：如果尚未入队列，则将上一个节点的next指向waiters，然后尝试让新的节点q替换waiters，如果尝试成功则queued为true，否则为false。代码6：如果开启了超时限制，则重新计算等待时间，如果 nanos&lt;=0L，即超时了，则移除等待队列中的该节点，并返回当前state；如果没有超时，则继续阻塞重新计算后的时间。如果没有开启超时限制，则直接阻塞等待直到被唤醒。 3.4.4 cancel()1234567891011121314151617181920212223public boolean cancel(boolean mayInterruptIfRunning) { //代码1 if (!(state == NEW &amp;&amp; UNSAFE.compareAndSwapInt(this, stateOffset, NEW, mayInterruptIfRunning ? INTERRUPTING : CANCELLED))) return false; try { //代码2 if (mayInterruptIfRunning) { try { Thread t = runner; if (t != null) t.interrupt(); } finally { // final state UNSAFE.putOrderedInt(this, stateOffset, INTERRUPTED); } } } finally { //代码3 finishCompletion(); } return true; } 代码1：1.如果state不等于NEW，则任务已经执行完毕或出现异常或被取消，直接返回false；2.如果任务尚未开始，则通过CAS尝试将状态从NEW改为mayInterruptIfRunning，若mayInterruptIfRunning为true，代表需要中断任务执行线程，则改为INTERRUPTING中间状态，否则改为CANCELLED最终状态，如果尝试更新成功，则返回true，否则返回false。代码2：如果进行了中断，则获取当前的线程runner，中断之。最后将状态由INTERRUPTING改为INTERRUPTED代码3：执行finishCompltion()(任务出现异常或正常执行完毕或成功取消任务都会调用该方法，上文已提到)，返回true 3.4.5 isCancelled()123public boolean isCancelled() { return state &gt;= CANCELLED; } 判断任务是否被取消。只要状态大于等于CANCELLED都返回true。 3.4.6 isDone()123public boolean isDone() { return state != NEW; } 只要不是NEW，都返回true，代表任务已完成。 四.Callable+Future示例12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455package com.wml.test2.future;import java.util.concurrent.*;/** * @author MaoLin Wang * @date 2020/1/2723:18 */public class FutureDemo { public static class Task implements Callable&lt;Integer&gt;{ private int sum; @Override public Integer call() throws Exception { System.out.println(\"Callable线程开始执行任务\"); Thread.sleep(1500); for (int i = 0; i &lt; 50; i++) { if (Thread.currentThread().isInterrupted()){ System.out.println(\"Callable线程计算任务中断\"); return null; } if (i%2==0){ sum=sum+i; System.out.println(\"sum=\"+sum); } } System.out.println(\"Callable线程执行完毕 计算结果为\"+sum); return sum; } } public static void main(String[] args) { Task task=new Task(); ExecutorService pool = new ThreadPoolExecutor(6,100,0L,TimeUnit.MILLISECONDS, new LinkedBlockingDeque&lt;&gt;()); Future&lt;Integer&gt;future=pool.submit(task); pool.shutdown(); try { Thread.sleep(3000L); System.out.println(\"主线程执行其他任务中.....\"); if (future.get()!=null){ System.out.println(\"主线程获取Callable执行结果:\"+future.get()); }else { System.out.println(\"尚未获取到结果\"); } } catch (InterruptedException e) { e.printStackTrace(); } catch (ExecutionException e) { e.printStackTrace(); } }} 结果： 1234567891011121314151617181920212223242526272829Callable线程开始执行任务sum=0sum=2sum=6sum=12sum=20sum=30sum=42sum=56sum=72sum=90sum=110sum=132sum=156sum=182sum=210sum=240sum=272sum=306sum=342sum=380sum=420sum=462sum=506sum=552sum=600Callable线程执行完毕 计算结果为600主线程执行其他任务中.....主线程获取Callable执行结果:600 五、Callable+FutureTask示例Task类同上 12345678910111213141516171819202122public static void main(String[] args) { ExecutorService pool = new ThreadPoolExecutor(6,100,0L, TimeUnit.MILLISECONDS, new LinkedBlockingDeque&lt;&gt;()); Task task=new Task(); //创建FutureTask任务 FutureTask futureTask=new FutureTask(task); pool.submit(futureTask); pool.shutdown(); try { Thread.sleep(3000L); System.out.println(\"主线程执行其他任务中.....\"); if (futureTask.get()!=null){ System.out.println(\"主线程获取Callable执行结果:\"+futureTask.get()); }else { System.out.println(\"尚未获取到结果\"); } } catch (InterruptedException e) { e.printStackTrace(); } catch (ExecutionException e) { e.printStackTrace(); } } 结果： 1234567891011Callable子线程开始计算！sum=0sum=1sum=3sum=6sum=10sum=15sum=21Cancel................. sum=28Callable子线程计算任务中断！","link":"/posts/20200127-runcalfutask.html"},{"title":"java多线程之CAS操作及相关原子操作类详解","text":"一、原子操作是什么原子操作即不可被中断（分割）的一个或一系列操作，如对于A,B两个操作，如果一个线程操作A，若另一个线程执行B操作时，要么将B执行到结束，要么完全不让B执行，此时对于A和B来说，就是原子的。 二、悲观锁和乐观锁如synchronized就是悲观锁，解决多线程并发问题，以保证事务的完整性。其是基于阻塞的锁机制，如果有一个线程拥有锁后，访问该资源的其他线程就需要阻塞等待，直到获得锁的线程释放锁。CAS操作即是乐观锁，每个线程都可以访问，只有在提交数据的时候检查是否违反了数据的完整性，即每次都尝试去完成某个操作，如果冲突和造成操作失败，就循环重试，直到操作成功为止。 使用synchronized会引出很多问题，如：获得锁的线程一直不释放锁；大量线程竞争资源，可能会造成死锁；被阻塞的线程可能优先级很高却一直无法获取锁。 因此实现原子操作可使用CAS指令。 三、CASCAS 即Compare and Swap，比较并交换。每个CAS操作过程都包括三个运算符：内存地址V、期望值A、新的值B如果操作的时候地址V上的值等于期望的值A，则将地址V上的值更新为B，否则不做任何操作，但要返回原值。循环CAS就是不断的进行CAS操作直到操作成功。可防止内存中共享变量出现脏读脏写的问题。CAS是通过硬件CPU和内存，利用CPU的多处理能力实现硬件层面的阻塞，再加上volatile变量的特性来实现基于原子操作的线程安全。 （1）get变量值(旧值)—–&gt;（2）计算后得到新值——&gt;（3）比较内存中变量值和旧值—–&gt;（4）如果（3）相等，则让新值替换旧值，否则继续（1） 四、CAS实现原子操作的三大问题4.1ABA问题由于CAS在操作值的时候需要检查旧值是否发生变化，如果未变化则更新值，但如果一个值原来是A，变成了B，然后又变为了A，这样虽然值已经发生了变化，但使用CAS进行检查时会发现它的旧值“未变化”。而要解决该问题，就是使用版本号。即给变量添加版本号，每次更新变量都去更新它的版本号，如刚刚A-&gt;B-&gt;A，便变成了 1A-&gt;2B-&gt;3A。就像在家里倒了一杯水，你还没来得及喝，但是被家人喝掉， 然后又给你接满了一杯水，这样如果在不知道的情况下，你会认为这仍然是之前那杯水。又或者你的资金被别人挪用了，然后又还给了你，虽然钱没有变，但造成的问题时那个人已经犯罪了。 4.2循环时间长，开销大如果CAS一直处于自旋不成功状态，CPU的开销会大大增加。 4.3只能保证一个共享变量的原子操作当对一个共享变量执行操作时，可使用循环 CAS 的方式来保证原子操作，但是对多个共享变量操作时，循环 CAS 就无法保证操作的原子性，当然可以用锁。也可以把多个共享变量合并成一个共享变量来操作。如，有两个共享变量 i＝a，j=b，合并一下 ij=ab，然后用 CAS 来操作 ij，然后通过AtomicReference 类来保证引用对象之间的原子性，便实现了多个变量放在一个对象里来进行 CAS 操作。 五、JDK中相关原子操作类的使用5.1概览更新基本类型类：AtomicBoolean，AtomicInteger，AtomicLong更新数组类：AtomicIntegerArray，AtomicLongArray，AtomicReferenceArray更新引用类型：AtomicReference，AtomicMarkableReference，AtomicStampedReference原子更新字段类： AtomicReferenceFieldUpdater，AtomicIntegerFieldUpdater，AtomicLongFieldUpdater 基本数据类型的原子操作类以AtomicInteger为例，其余差不多。 5.2 AtomicInteger常用方法如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112public class AtomicInteger extends Number implements java.io.Serializable { private static final long serialVersionUID = 6214790243416807050L; //获取指针类Unsafe private static final Unsafe unsafe = Unsafe.getUnsafe(); //内存偏移量 private static final long valueOffset; static { try { //通过objectFieldOffset()方法，获取对象属性的偏移量 valueOffset = unsafe.objectFieldOffset (AtomicInteger.class.getDeclaredField(\"value\")); } catch (Exception ex) { throw new Error(ex); } } //当前的变量值 private volatile int value; public AtomicInteger(int initialValue) { //初始化变量值 value = initialValue; } //value初始化为0 public AtomicInteger() { } //返回当前值 public final int get() { return value; } //设置当前值 public final void set(int newValue) { value = newValue; } //懒设置，使用Unsafe.putOrderedObject方法实现，实现非堵塞的写入，最终会将value置为newValue。 //该方法可能出现其他线程在未来很小的一段时间内无法获取到新值，但可获取到旧值 public final void lazySet(int newValue) { unsafe.putOrderedInt(this, valueOffset, newValue); } //以原子方式设置为给定值并返回旧值。 public final int getAndSet(int newValue) { return unsafe.getAndSetInt(this, valueOffset, newValue); } //以下是getAndSetInt源码，通过while循环重试更新值，直到成功，也是通过CAS实现(JDK8版本) /*public final int getAndSetInt(Object var1, long var2, int var4) { int var5; do { var5 = this.getIntVolatile(var1, var2); } while(!this.compareAndSwapInt(var1, var2, var5, var4)); return var5; }*/ //原子更新value，如果当前值等于expect，则设置为update public final boolean compareAndSet(int expect, int update) { return unsafe.compareAndSwapInt(this, valueOffset, expect, update); } //以原子方式将当前值增加一 //返回旧值，底层同getAndSetInt一样使用CAS操作 public final int getAndIncrement() { return unsafe.getAndAddInt(this, valueOffset, 1); } //以原子方式将当前值减一 //返回旧值，CAS操作 public final int getAndDecrement() { return unsafe.getAndAddInt(this, valueOffset, -1); } //以原子方式将给定值delta添加到当前值 //返回旧值，CAS操作 public final int getAndAdd(int delta) { return unsafe.getAndAddInt(this, valueOffset, delta); } //以原子方式将当前值加1，返回新值 public final int incrementAndGet() { return unsafe.getAndAddInt(this, valueOffset, 1) + 1; } //当前值减1，返回新值 public final int decrementAndGet() { return unsafe.getAndAddInt(this, valueOffset, -1) - 1; } //以原子方式将当前值增加delta，返回新值 public final int addAndGet(int delta) { return unsafe.getAndAddInt(this, valueOffset, delta) + delta; } //使用给定函数的结果以原子方式更新当前值，返回更新后的值。给的函数是无副作用的，因为当尝试更新由于线程之间的争用而失败时，它可能会重新应用 public final int updateAndGet(IntUnaryOperator updateFunction) { int prev, next; do { prev = get(); next = updateFunction.applyAsInt(prev); } while (!compareAndSet(prev, next)); return next; } //同上，使用给定函数的结果以原子方式更新当前值，返回更新前的值。应用该函数时，将当前值作为其第一个参数，并将给定的update作为第二个参数。 public final int getAndAccumulate(int x, IntBinaryOperator accumulatorFunction) { int prev, next; do { prev = get(); next = accumulatorFunction.applyAsInt(prev, x); } while (!compareAndSet(prev, next)); return prev; } //同getAndAccumulate，但返回更新后的值 public final int accumulateAndGet(int x, IntBinaryOperator accumulatorFunction) { int prev, next; do { prev = get(); next = accumulatorFunction.applyAsInt(prev, x); } while (!compareAndSet(prev, next)); return next; }} 使用演示： 123456789101112131415161718192021222324252627public class UseAtomicInt { static AtomicInteger atomicInteger = new AtomicInteger(10); public static void main(String[] args) { //返回旧值10 System.out.println(atomicInteger.getAndIncrement()); //返回新值12 System.out.println(atomicInteger.incrementAndGet()); atomicInteger.compareAndSet(12,1); //加24 返回25 System.out.println(atomicInteger.addAndGet(24)); //自定义函数 IntBinarOperImpl intBinarOper=new IntBinarOperImpl(); //传入自定义函数，传入更新值 atomicInteger.accumulateAndGet(1, intBinarOper); //返回26 System.out.println(atomicInteger.get()); }}//自定义函数，实现IntBinaryOperator接口public class IntBinarOperImpl implements IntBinaryOperator { @Override public int applyAsInt(int left, int right) { //简单定义原来的数加上要更新的数 return left+right; }} 5.3 AtomicIntegerArray是提供原子的方式更新数组里的整型，还包括高级原子操作。常用方法如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384public class AtomicIntegerArray implements java.io.Serializable { private static final long serialVersionUID = 2862133569453604235L; //同上 private static final Unsafe unsafe = Unsafe.getUnsafe(); //获取数组第一个元素的偏移地址 private static final int base = unsafe.arrayBaseOffset(int[].class); //存储移位个数 private static final int shift; //保存的数组 private final int[] array; static { //获取该类型的数组中元素的大小(字节)。 int scale = unsafe.arrayIndexScale(int[].class); //scale如果不是2的次幂则抛出异常 if ((scale &amp; (scale - 1)) != 0) throw new Error(\"data type scale not a power of two\"); //计算得到需要移位的个数，即scale的次幂数 shift = 31 - Integer.numberOfLeadingZeros(scale); } //返回第i个元素的地址 private static long byteOffset(int i) { //shift为偏移位数，base为第一个元素的地址，i移shift个位后+基位置得到第i个元素位置 return ((long) i &lt;&lt; shift) + base; } //先检测i是否越界，再调用byteOffset(i)返回 private long checkedByteOffset(int i) { if (i &lt; 0 || i &gt;= array.length) throw new IndexOutOfBoundsException(\"index \" + i); return byteOffset(i); } //构造初始化给定长度数组 public AtomicIntegerArray(int length) { array = new int[length]; } //创建一个新AtomicIntegerArray，其长度与传入数组相同，并从给定数组中复制所有元素。所以当 AtomicIntegerArray 对内部的数组元素进行修改时，不会影响传入的数组。 public AtomicIntegerArray(int[] array) { this.array = array.clone(); } //返回当前位置的元素 public final int get(int i) { //调用checkedByteOffset获取当前位置的元素地址 return getRaw(checkedByteOffset(i)); } //getIntVolatile方法获取数组中offset偏移地址对应的整型field的值,支持volatile load语义。返回该值。 private int getRaw(long offset) { return unsafe.getIntVolatile(array, offset); } //更新第i个位置的值，也需先计算当前位置的元素的offset public final void set(int i, int newValue) { unsafe.putIntVolatile(array, checkedByteOffset(i), newValue); } //同AtomicInteger的lazySet,这里更新第i个位置的元素 public final void lazySet(int i, int newValue) { unsafe.putOrderedInt(array, checkedByteOffset(i), newValue); } public final int getAndSet(int i, int newValue) { return unsafe.getAndSetInt(array, checkedByteOffset(i), newValue); } //如果当前值等于预期值，则以原子方式将数组位置 i 的元素设置成 update 值。 public final boolean compareAndSet(int i, int expect, int update) { return compareAndSetRaw(checkedByteOffset(i), expect, update); } private boolean compareAndSetRaw(long offset, int expect, int update) { return unsafe.compareAndSwapInt(array, offset, expect, update); } //原子的方式让第i个元素加1 public final int getAndIncrement(int i) { return getAndAdd(i, 1); } //原子的方式让第i个元素减1 public final int getAndDecrement(int i) { return getAndAdd(i, -1); } //原子的方式让第i个元素加delta public final int getAndAdd(int i, int delta) { return unsafe.getAndAddInt(array, checkedByteOffset(i), delta); } //还有其他一些方法都和Integer原子类基本一样 简单使用： 123456789101112131415161718192021public class AtomicArray { static int[] value = new int[] { 1, 2,3 }; static AtomicIntegerArray atomicIntegerArray = new AtomicIntegerArray(value); public static void main(String[] args) { //返回第一个位置的元素 2 System.out.println(atomicIntegerArray.get(1)); //更新第1个位置的元素 atomicIntegerArray.set(1,4); //返回4 System.out.println(atomicIntegerArray.get(1)); //设置第0个位置为3，返回更新前的值 1 System.out.println( atomicIntegerArray.getAndSet(0, 3)); //返回更新后的3 System.out.println(atomicIntegerArray.get(0)); //返回1，原数组不会变化 System.out.println(value[0]); atomicIntegerArray.compareAndSet(0,3,4); System.out.println(atomicIntegerArray.get(0)); }} 5.4 更新引用类型原子更新基本类型的 AtomicInteger，只能更新一个变量，如果要原子更新多个变量，就需要使用这个原子更新引用类型提供的类。Atomic 包提供了以下 3类。AtomicReference，AtomicStampedReference，AtomicMarkableReference 5.5 AtomicReference方法同前面几个类基本一样，但支持泛型，可传入对象,支持对对象的原子操作。 5.6 AtomicStampedReference和AtomicMarkableReferenceAtomicStampedReference 使用版本戳的记录每次改变后的版本号，这样的话就不会存在 ABA问题了。AtomicMarkableReference跟 AtomicStampedReference 基本相同，AtomicStampedReference 在Pair类 中使用 int类型的stamp 作为计数器，每次操作都更新版本，关注的的是动过几次。AtomicMarkableReference 在 Pair类 使用的是 boolean 类型的mark，关注的的是有没有被动过。 AtomicStampedReference源码如下： 首先定义了一个Pair内部类： 1234567891011private static class Pair&lt;T&gt; { final T reference; final int stamp; private Pair(T reference, int stamp) { this.reference = reference; this.stamp = stamp; } static &lt;T&gt; Pair&lt;T&gt; of(T reference, int stamp) { return new Pair&lt;T&gt;(reference, stamp); } } 该类将元素的值(reference)和版本号(stamp)都维护在自己身上。 成员变量 12345678910111213141516171819//声明Pair类型变量private volatile Pair&lt;V&gt; pair;//获取Unsafeprivate static final sun.misc.Unsafe UNSAFE = sun.misc.Unsafe.getUnsafe();//使用unsafe获取偏移量保存到pairOffsetprivate static final long pairOffset = objectFieldOffset(UNSAFE, \"pair\", AtomicStampedReference.class); static long objectFieldOffset(sun.misc.Unsafe UNSAFE, String field, Class&lt;?&gt; klazz) { try { return UNSAFE.objectFieldOffset(klazz.getDeclaredField(field)); } catch (NoSuchFieldException e) { // Convert Exception to corresponding Error NoSuchFieldError error = new NoSuchFieldError(field); error.initCause(e); throw error; //后面两个放在源码的最后，不太好找 构造方法 123public AtomicStampedReference(V initialRef, int initialStamp) { pair = Pair.of(initialRef, initialStamp); } 传入初始值和初值版本戳保存到pair。 方法 4.1. getReference()和getStamp()：返回元素值和返回版本戳 123456public V getReference() { return pair.reference; } public int getStamp() { return pair.stamp; } 4.2 get() 123456//返回当前元素的值，并将当前元素的版本号保存到传入的数组中的第一个位置public V get(int[] stampHolder) { Pair&lt;V&gt; pair = this.pair; stampHolder[0] = pair.stamp; return pair.reference; } 4.3 casPair() 12345//cmp:期望的pair,val：新的pair//CAS更新当前的pairprivate boolean casPair(Pair&lt;V&gt; cmp, Pair&lt;V&gt; val) { return UNSAFE.compareAndSwapObject(this, pairOffset, cmp, val); } 4.4 compareAndSet() 该方法首先判断期望的值和版本戳是否和当前的值和版本戳相同，如果不相同则直接返回false，如果相同则继续比较新的值和版本戳是否和当前值相同，如果相同则直接返回true，否则对当前的pair进行CAS操作。 12345678910111213141516171819/** * 原子的修改元素的值和版本戳 * @param 期望值 * @param 新值 * @param 期望版本戳 * @param 新版本戳 */ public boolean compareAndSet(V expectedReference, V newReference, int expectedStamp, int newStamp) { Pair&lt;V&gt; current = pair; return expectedReference == current.reference &amp;&amp; expectedStamp == current.stamp &amp;&amp; ((newReference == current.reference &amp;&amp; newStamp == current.stamp) || casPair(current, Pair.of(newReference, newStamp))); } 4.5 weakCompareAndSet() 其代码同compareAndSet无差别，但在JDK9中，两个方法都添加了@HotSpotIntrinsicCandidate注解，使用该注解的方法在JVM中都有一套基于CPU指令的高效的实现，且会在运行时会替代JDK的源码实现，从而获得更高的效率。即HotSpot可能会手动实现这个方法。参考：https://blog.csdn.net/lzcaqde/article/details/80868854的解读。 12345678// 同compareAndSet，但可能不能保证原子性public boolean weakCompareAndSet(V expectedReference, V newReference, int expectedStamp, int newStamp) { return compareAndSet(expectedReference, newReference, expectedStamp, newStamp); } 4.6 set() 12345678910/** * 源码解释无条件更新当前元素的值和版本戳 * @param newReference 新值 * @param newStamp 新版本戳 */public void set(V newReference, int newStamp) { Pair&lt;V&gt; current = pair; if (newReference != current.reference || newStamp != current.stamp) this.pair = Pair.of(newReference, newStamp); } 4.7 attemptStamp() 如果引用对象为期望值，则重新设置新的版本戳。 1234567public boolean attemptStamp(V expectedReference, int newStamp) { Pair&lt;V&gt; current = pair; return expectedReference == current.reference &amp;&amp; (newStamp == current.stamp || casPair(current, Pair.of(expectedReference, newStamp))); } 示例： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647public class UseAtomicStampedReference { /** * 设置初始值和初始版本戳 */ static AtomicStampedReference&lt;String&gt; asr = new AtomicStampedReference(\"wml\",0); public static void main(String[] args) throws InterruptedException { //拿到当前的版本号(旧) final int oldStamp = asr.getStamp(); final String oldReference = asr.getReference(); System.out.println(\"旧值：\"+oldReference+\"，旧版本戳：\"+oldStamp); Thread rightStampThread = new Thread(() -&gt; { System.out.println(Thread.currentThread().getName()+\":当前变量值：\" +oldReference + \"，当前版本戳：\" + oldStamp ); //更新引用对象值和版本戳 asr.compareAndSet(oldReference, \"wml222\", oldStamp, oldStamp + 1); int[] stampHolder=new int[2]; stampHolder[0]=0; //调用get，返回当前值，并将版本保存到stampHolder[0]中 asr.get(stampHolder); //打印当前版本 System.out.println(\"使用get()获取版本：\"+stampHolder[0]); }); Thread errorStampThread = new Thread(() -&gt; { String reference = asr.getReference(); System.out.println(Thread.currentThread().getName()+\":当前变量值：\" +reference + \"，当前版本戳：\" + asr.getStamp()); //更新引用对象值和版本戳 asr.compareAndSet(reference, \"wml333\", oldStamp, oldStamp + 1); }); rightStampThread.start(); rightStampThread.join(); errorStampThread.start(); errorStampThread.join(); System.out.println(\"Main线程:当前变量值：\" +asr.getReference() + \"，当前版本戳：\" + asr.getStamp()); asr.set(\"set新值\",3); System.out.println(\"使用set更新:当前变量值：\" +asr.getReference() + \"，当前版本戳：\" + asr.getStamp()); }} 线程errorStampThread没有使用更新后的版本戳作为期望版本，因此该线程CAS失败。 5.7 原子更新字段类atomic包提供了AtomicIntegerFieldUpdater，AtomicLongFieldUpdater，AtomicReferenceFieldUpdater三个类实现原子的更新某个类的某个字段。以AtomicReferenceFieldUpdater为例：更新字段类需要两步：1.由于原子更新字段类都是抽象类，每次必须使用静态方法 newUpdater()创建一个更新器，并且传入要更新的类，字段类型和字段名。2.更新类的字段（属性）必须使用 public volatile修饰符。其他注意点：1.变量不可使用static、final关键字。2.变量的描述符类型必须与调用者一致。否则调用者不能调用变量也就不能通过反射操作保证原子性。 每个更新字段类都是一个抽象类，内部有一个AtomicXXXXFieldUpdaterImpl实现类，相关代码如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485 private static final class AtomicReferenceFieldUpdaterImpl&lt;T,V&gt; extends AtomicReferenceFieldUpdater&lt;T,V&gt; { // 获取Unsafe private static final sun.misc.Unsafe U = sun.misc.Unsafe.getUnsafe(); // 当前变量的内存偏移量 private final long offset; // 如果要操作的类的字段被protected修饰，则cclass为调用者类的class对象，否则cclass为tclass。 private final Class&lt;?&gt; cclass; // 要操作的类的class对象 private final Class&lt;T&gt; tclass; // 要操作的类字段的class对象 private final Class&lt;V&gt; vclass; /** * @param tclass 即上面的tclass * @param vclass 要操作的类字段的class对象 * @param fieldName 被操作的字段名 * @param caller 调用者类的class对象 */ AtomicReferenceFieldUpdaterImpl(final Class&lt;T&gt; tclass, final Class&lt;V&gt; vclass, final String fieldName, final Class&lt;?&gt; caller) { //原子更新的字段 final Field field; //原子更新字段的class对象 final Class&lt;?&gt; fieldClass; //原子更新字段的修饰符 final int modifiers; try { //利用反射机制获取tclass的field field = AccessController.doPrivileged( new PrivilegedExceptionAction&lt;Field&gt;() { public Field run() throws NoSuchFieldException { return tclass.getDeclaredField(fieldName); } }); //获取该字段的修饰符 modifiers = field.getModifiers(); //检查该字段的访问权限，无法访问则抛出对应异常信息 sun.reflect.misc.ReflectUtil.ensureMemberAccess( caller, tclass, null, modifiers); //获取对应class的类加载器 ClassLoader cl = tclass.getClassLoader(); ClassLoader ccl = caller.getClassLoader(); if ((ccl != null) &amp;&amp; (ccl != cl) &amp;&amp; ((cl == null) || !isAncestor(cl, ccl))) { sun.reflect.misc.ReflectUtil.checkPackageAccess(tclass); } fieldClass = field.getType(); } catch (PrivilegedActionException pae) { throw new RuntimeException(pae.getException()); } catch (Exception ex) { throw new RuntimeException(ex); } if (vclass != fieldClass) throw new ClassCastException(); if (vclass.isPrimitive()) throw new IllegalArgumentException(\"Must be reference type\"); if (!Modifier.isVolatile(modifiers)) throw new IllegalArgumentException(\"Must be volatile type\"); //首先判断字段修饰符是否为protected // 再判断tclass和caller是否相同或者是另一个类的子类 this.cclass = (Modifier.isProtected(modifiers) &amp;&amp; tclass.isAssignableFrom(caller) &amp;&amp; !isSamePackage(tclass, caller)) ? caller : tclass; this.tclass = tclass; this.vclass = vclass; this.offset = U.objectFieldOffset(field); } //如果可以在第一个类加载器的委托链中找到第二个类加载器，则返回true private static boolean isAncestor(ClassLoader first, ClassLoader second) { ClassLoader acl = first; do { acl = acl.getParent(); if (second == acl) { return true; } } while (acl != null); return false; } 原子更新类的方法同atomic包下的其他类基本相同，但是该类在进行CAS前，需要先进行类型检查，如下： 123456789101112131415//检查目标参数是否是类的实例。失败时，抛出原因。 private final void accessCheck(T obj) { if (!cclass.isInstance(obj)) throwAccessCheckException(obj);}//检查目标参数是否是对应字段的类型，如果不是则抛出异常private final void valueCheck(V v) { if (v != null &amp;&amp; !(vclass.isInstance(v))) throwCCE(); } public final boolean compareAndSet(T obj, V expect, V update) { accessCheck(obj); valueCheck(update); return U.compareAndSwapObject(obj, offset, expect, update);} 使用示例： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849public class AtomicReferenceFieldUpdaterDemo { /** * 定义AtomicReferenceFieldUpdater，传入要操作的类User，以及原子操作的字段age的class对象Integer.class和字段名age，这里字段必须为引用类型，如果是int类型的则需使用 */ static AtomicReferenceFieldUpdater arf = AtomicReferenceFieldUpdater.newUpdater(User.class, Integer.class, \"age\"); /** * 定义AtomicIntegerFieldUpdater，传入要操作的类User，以及原子操作的字段名grade */ static AtomicIntegerFieldUpdater aif=AtomicIntegerFieldUpdater.newUpdater(User.class,\"grade\"); public static void main(String[] args) throws InterruptedException { User user = new User(); user.age=19; user.grade=0; //CAS修改为20 arf.compareAndSet(user, 19, 20); //输出20 System.out.println(arf.get(user)); //修改为21，返回修改前的 20 System.out.println(arf.getAndSet(user,21)); //修改后为21 System.out.println(user.age); ThreadPoolExecutor poolExecutor = new ThreadPoolExecutor(500, 1000, 0L, TimeUnit.MILLISECONDS, new LinkedBlockingDeque()); //开500个线程增加grade字段 for (int i = 0; i &lt; 500; i++) { poolExecutor.execute(()-&gt;{ aif.incrementAndGet(user); }); } poolExecutor.shutdown(); Thread.sleep(2000L); System.out.println(\"增加后的grade为:\"+aif.get(user)); aif.compareAndSet(user,500,1000); System.out.println(\"修改后的grade为\"+aif.get(user)); }}class User { protected volatile Integer age; protected volatile int grade;} 结果： 12345202021增加后的grade为:500修改后的grade为1000 参考：https://zhuanlan.zhihu.com/p/65240318","link":"/posts/20200130-atomicClass.html"},{"title":"java并发编程之显示锁Lock、Condition接口、LockSupport以及AQS（同步队列、条件等待队列）详解","text":"一、显式锁synchronized关键字是java内置的语言特性，使用synchronized关键字会隐式的获取锁，在获取锁的线程执行执行完任务或是执行过程中发生异常时会自动释放锁。但为什么还需要Lock呢？ 如，目前绝大多数的业务场景基本都是读多写少，如读写比例为10:1，倘若使用synchronized，若有一个线程在读，则因为其的独占性，其他的线程都只能等待，造成大量的资源浪费，但Lock的实现类ReentrantReadWriteLock读写锁便可以完美的解决这一问题。 又如，synchronized无法设置超时时间，而如果获取该锁的线程因为I/O请求或是其他原因导致一直无法释放锁，则其他线程便会进入“无限等待”的状态，而Lock获取锁时可设置超时时间，如果在截止时间之后仍未获取到锁，则返回。 但个人认为如果不使用lock.trylock或者lockInterruptbly()中断获取锁的线程等，尽量使用synchronized关键字，synchronized因为是一个语言特性，而Lock是一个类，使用就需要创建对象实例必然会比synchronized有所消耗，jdk对synchronized也进行了许多优化。 二、Lock先看lock的标准用法： 123456789101112private Lock lock = new ReentrantLock();private int num= 1; .............public void test() { lock.lock(); //如果中间抛了个异常，unlock就不会执行，因此释放锁必须放在finally中 try{ age++; }finally { lock.unlock(); }} 这里不能将获取锁放在try中，因为如果放在try中，当获取锁时发生了异常，必然会执行unlock()释放锁，而问题是当前并没有获取到锁，又必然会导致程序异常。 Lock的常用方法如下： lock() 获取锁，调用该方法的线程会获取到锁，如果获取到锁，从该方法返回，否则会进行等待。 void lockInterruptibly() throws InterruptedException;该方法支持中断的获取锁。即在获取锁时，如果锁已被其他线程获取，则当前线程只能进入阻塞等待状态，但 是可以调用该线程的interrupt()方法中断当前线程的等待状态，停止获取锁。 boolean tryLock() 该方法实现非阻塞的获取锁，即调用该方法会立即返回，如果获取到，则返回true，如果未获取到则返回false官方给出的范例如下： 12345678910Lock lock = ...; if (lock.tryLock()) { try { //如果获取到锁就处理相关任务 } finally { lock.unlock(); } } else { //未获取到执行其他任务 }} boolean tryLock(long time, TimeUnit unit) throws InterruptedException;同3一样，但增加了超时时间。当：（1）当前线程在超时时间内获取到锁，则直接返回true（2）当前线程在超时时间内被中断，则抛出中断异常（3）当前线程在超时时间内未获取到锁，返回false void unlock();释放锁。 Condition newCondition(); 返回一个Condition实例，该实例与调用其的的锁绑定，调用后，可使用condition的`await()`、`signal()`等方法对调用该方法的线程进行等待和唤醒，一个Lock对象可以使用多个`Condition`三、Conditionsynchronized关键字可通过wait()、notify()实现等待-通知的模式，而Lock也可以实现，但是其是借助Condition接口实现的，通过Lock.newCondition()就可以看出。与synchronized不同的是，一个Lock对象可以创建多个Condition实例，因此，每个Condition实例可以维护单独的线程，在调用condition.await()和signal()时，只会控制注册在该condition实例上的线程，signalAll()也不会像synchronized调用notifyAll()一样通知所有阻塞等待的线程，只是唤醒所有注册在该实例的线程。Condition的常用方法： void await() throws InterruptedException;与此Condition关联的锁会被原子释放，并且出于线程调度的目的，当前线程被禁用，进入等待状态，直到发生以下四种情况之一：1.其他一些线程调用此Condition的signal()或signalAll()方法，而当前线程恰好被选择为要唤醒的线程2.其他线程调用interrupt() 方法中断当前线程3.发生虚假唤醒如果 当前线程被唤醒，从await()方法返回，则意味着当前线程已经获取了该Condition对象绑定的锁。 void awaitUninterruptibly(); 同await()一样，但是不响应中断。即如果当前线程进入此方法时已设置其中断状态，或者在等待时其他线程调用`interrupt()` 方法，它仍继续等待直到收到signal()或signalAll()。当它最终从该方法返回时，其中断状态仍将被设置。 long awaitNanos(long nanosTimeout) throws InterruptedException; 当前线程进入等待状态直到被通知、中断或超出超时时间。 此方法返回剩余时间。因此如果返回小于等于0的数，说明已经超时。 boolean await(long time, TimeUnit unit) throws InterruptedException;同上，但如果超时返回false，否则返回true boolean awaitUntil(Date deadline) throws InterruptedException; 当前线程进入等待状态直到被通知、中断或超出截止时间。超时返回false，否则返回true。 void signal();唤醒一个等待队列中等待时间最长的线程。如果有线程在该Condition下等待，则选择一个线程唤醒。该线程从await()返回前，必须重新获取Conditon绑定的锁。 void signalAll(); 唤醒所有在该Condition上等待的线程。同样需要先获取绑定的锁。 Condition简单使用： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134package com.wml.test4.conditon;/** * @author Wang * @date 2020/2/117:27 */public class ConditionDemo { private static Delivery delivery = new Delivery(\"wml\", \"南京路1号\", \"德基广场三层\", 1000); public static void main(String[] args) throws InterruptedException { for (int i = 0; i &lt; 3; i++) { new Thread(() -&gt; { delivery.sms300(); }, \"distance\").start(); } for (int i = 0; i &lt; 3; i++) { new Thread(() -&gt; { delivery.smsArrived(); }, \"address\").start(); } System.out.println(\"配送中\"); Thread.sleep(3000L); delivery.arive300(); Thread.sleep(1000L); delivery.completeDelivery(); }}//配送类class Delivery { private Lock lock = new ReentrantLock(); //使用lock创建一个用于实现距离的等待通知的condition private Condition distConditon = lock.newCondition(); //使用lock创建一个用于实现地点的等待通知的condition private Condition addrCondition = lock.newCondition(); /** * 收餐人 */ private String recipient; /** * 配送地址 */ private String address; /** * 当前位置 */ private String currentAddress; /** * 距离 */ private int distance; public Delivery(String recipient, String address, String currentAddress, int distance) { this.recipient = recipient; this.address = address; this.currentAddress = currentAddress; this.distance = distance; } /** * 距离送餐地点还有300米，通知订餐人到指定地点取餐 */ public void arive300() { lock.lock(); try { this.distance = 300; //发送通知，唤醒等待线程 distConditon.signal(); } finally { lock.unlock(); } } /** * 完成配送，更新距离和位置，唤醒线程发送相关通知 */ public void completeDelivery() { lock.lock(); try { this.distance = 0; this.currentAddress = this.address; //唤醒当前condition实例的等待线程 addrCondition.signal(); } finally { lock.unlock(); } } /** * 到达300米处发送通知 */ public void sms300() { lock.lock(); try { while (this.distance &gt; 300) { try { distConditon.await(); System.out.println(\"到达300米处，distConditon执行signal唤醒了\" + Thread.currentThread().getName() + \"线程\"); } catch (InterruptedException e) { e.printStackTrace(); } } } finally { lock.unlock(); } System.out.println(\"亲爱的\" + this.recipient + \"先生/女士，您的外卖还有300米送达\"); } //订餐送达目的地 public void smsArrived() { lock.lock(); try { try { while (!this.currentAddress.equals(this.address)) { //指定超时时间 addrCondition.await(); System.out.println(\"addressCOndition的\" + Thread.currentThread().getName() + \"线程被唤醒\"); System.out.println(\"订餐已送至目的地:\" + this.address); } } catch (InterruptedException e) { e.printStackTrace(); } } finally { lock.unlock(); } System.out.println(\"完成配送\"); }} 结果： 123456配送中到达300米处，distConditon执行signal唤醒了distance线程亲爱的wml先生/女士，您的外卖还有300米送达addressCOndition的address线程被唤醒订餐已送至目的地:南京路1号完成配送 该例子使用Lock对象创建了一个距离condition和地址condition，外派配送至距离送餐点300米和送达到指定地点时都需要发送通知，发送通知需要分别调用距离和地址condition的await()方法等待，当到达300米和指定地点时再分别调用对应的condition.signal()唤醒一个等待中的线程。 四、LockSupport在将Lock的实现类前，需要先将AQS，但是了解AQS又需要先了解LockSupport。LockSupport 定义了一组以 park 开头的方法用来阻塞当前线程，以及unpark(Thread thread)方法来唤醒一个被阻塞的线程。 LockSupport类无法被实例化（从以下源码可看出，只有一个私有的构造函数）且所有方法都是静态的，这些方法提供了最基本的线程阻塞和唤醒功能。 123public class LockSupport { private LockSupport() {} } 再来看看LockSupport的成员变量： 123456private static final sun.misc.Unsafe UNSAFE;//挂起线程对象的偏移地址,对应Thread类的parkBlocker字段private static final long parkBlockerOffset;private static final long SEED;private static final long PROBE;private static final long SECONDARY; 对应的赋值在静态代码块中: 1234567891011121314static { try { UNSAFE = sun.misc.Unsafe.getUnsafe(); Class&lt;?&gt; tk = Thread.class; parkBlockerOffset = UNSAFE.objectFieldOffset (tk.getDeclaredField(\"parkBlocker\")); SEED = UNSAFE.objectFieldOffset (tk.getDeclaredField(\"threadLocalRandomSeed\")); PROBE = UNSAFE.objectFieldOffset (tk.getDeclaredField(\"threadLocalRandomProbe\")); SECONDARY = UNSAFE.objectFieldOffset (tk.getDeclaredField(\"threadLocalRandomSecondarySeed\")); } catch (Exception ex) { throw new Error(ex); } } 可以看到都是先获取Thread类下的对应的字段，如parkBlocker，然后通过UNFAFE的objectFieldOffset()方法获取对应字段的偏移量（某字段在其类中的内存偏移量是始终相同的） 再来看看LockSupport的静态方法： 说在前面：LockSupport的park()和unpark()底层在维护一个许可证，park相当于消费者，unpark相当于生产者（生产一个许可证），park在没被中断或其他原因导致停止等待的情况下，必须消费一个许可证才可以继续执行 1.park相关方法: 123public static void park() { UNSAFE.park(false, 0L); } 其底层调用的UNSAFE.park(boolean isAbsolute, long time)方法，其底层原理解析可参考此文章：https://juejin.im/post/5bdc1142e51d45052c6fede7#heading-1，简单的讲，就是其底层维护了一个volatile int _counter变量，该变量就相当于许可证，park()方法就是将其从1改为0消费掉。其会首先尝试获取许可，如果没有获取到，如果获取到则说明有线程调用unpark()释放了一个许可，再进行以下情况的判断： 当前线程被中断，直接返回 当前线程到期，直接返回，具体可分为（以下情况发生中断或出现未知原因也都会返回）:a.`isAbsolute`为true，如果`time`小于等于0，直接返回；如果大于0，进行粗精度超时计算，超时时间内未获取到许可则返回 b.`isAbsolute`为false，`time`为0L，不进行超时计算，一直等待unpark释放许可 c..`isAbsolute`为false，`time`大于0，进行细精度超时计算，如果在time时间内仍未获取到许可，则直接返回 超时相关方法： 1234567public static void parkUntil(long deadline) { UNSAFE.park(true, deadline);}public static void parkNanos(long nanos) { if (nanos &gt; 0) UNSAFE.park(false, nanos);} 2. 带有blocker的park相关方法: 123456public static void park(Object blocker) { Thread t = Thread.currentThread(); setBlocker(t, blocker); UNSAFE.park(false, 0L); setBlocker(t, null); } 该方法也是用于阻塞当前线程，其中blocker是用来标识当前线程在等待的对象（阻塞对象），用于问题的排查和系统监控。 setBlocker()方法如下： 123private static void setBlocker(Thread t, Object arg) { UNSAFE.putObject(t, parkBlockerOffset, arg); } 可以看到，该方法调用了UNSAFE.putObject()方法，实现将传入的blocker，（这里是arg），赋值给当前线程的parkBlocker对应偏移量下的数据。回过头看park(Object blocker) 方法，其在调用UNSAFE.park()前设置了blocker，在被唤醒后又调用了setBlocker将对应位置的blocker清空。因此当前线程在阻塞前，我们仍可以获取到当前的blocker。获取Blocker方法如下： 12345public static Object getBlocker(Thread t) { if (t == null) throw new NullPointerException(); return UNSAFE.getObjectVolatile(t, parkBlockerOffset); } 带blocker的超时的park()方法如下： 1234567891011121314public static void parkNanos(Object blocker, long nanos) { if (nanos &gt; 0) { Thread t = Thread.currentThread(); setBlocker(t, blocker); UNSAFE.park(false, nanos); setBlocker(t, null); } }public static void parkUntil(Object blocker, long deadline) { Thread t = Thread.currentThread(); setBlocker(t, blocker); UNSAFE.park(true, deadline); setBlocker(t, null); } 3.unpark相关方法: 1234public static void unpark(Thread thread) { if (thread != null) UNSAFE.unpark(thread); } 唤醒一个被阻塞的线程。底层就是将_counter变量设为1，如果_counter本来是0，则会唤醒在等待的线程。unpark可以在park之前使用，这样调用park时发现_counter为1，则可以直接消费使用；unpark()可以调用多次，但_counter值最多为1，不会累加，因此连续调用两次park()只有第一次调用时可以继续执行，第二次就会等待。 下面写一个小例子验证上面的说法： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273public class LockSupportDemo { /** * 测试blocker在对应线程被唤醒后清空 */ public static void testBlocker(){ Thread threadA = new Thread(()-&gt;{ System.out.println(\"ThreadA被阻塞前\"); LockSupport.park(\"threadA_Blocker\"); try { Thread.sleep(1000L); } catch (InterruptedException e) { e.printStackTrace(); } }); threadA.start(); new Thread(()-&gt;{ try { Thread.sleep(2000L); } catch (InterruptedException e) { e.printStackTrace(); } String blocker = (String) LockSupport.getBlocker(threadA); System.out.println(\"线程A即将被唤醒\"); System.out.println(\"获取到线程A的blocker:\"+blocker); //释放线程A LockSupport.unpark(threadA); System.out.println(\"线程A被唤醒了\"); System.out.println(\"再次获取线程A的blocker\"); String blocker2=(String)LockSupport.getBlocker(threadA); System.out.println(\"获取到线程A的blocker:\"+blocker2); }).start(); } public static void main(String[] args) throws InterruptedException { //testBlocker(); Thread thread = new Thread(() -&gt; { unparkFirst(); }); thread.start(); new Thread(()-&gt;{ try { Thread.sleep(2000L); } catch (InterruptedException e) { e.printStackTrace(); } System.out.println(\"第三次执行unpark\"); LockSupport.unpark(thread); }).start(); } /** * 测试先执行unpark，再park可继续执行，但是执行两次unpark，也只能执行一次park，第二次park被阻塞 */ public static Thread unparkFirst(){ Thread curThread = Thread.currentThread(); LockSupport.unpark(curThread); LockSupport.unpark(curThread); System.out.println(\"执行两次unpark后\"); LockSupport.park(); System.out.println(\"第一次执行park后\"); LockSupport.park(); System.out.println(\"第二次执行park后\"); return curThread; }} 执行testBlocker()结果： 123456ThreadA被阻塞前线程A即将被唤醒获取到线程A的blocker:threadA_Blocker线程A被唤醒了再次获取线程A的blocker获取到线程A的blocker:null 发现在线程A被唤醒后，对应的blocker为空执行unparkFirst()结果： 1234执行两次unpark后第一次执行park后第三次执行unpark第二次执行park后 发现第二次执行park后，线程被阻塞等待，只有再次执行unpark后，后面的代码才能继续执行，因此park和unpark应成对出现，否则线程会一直等待下去。 五、AQS讲完了LockerSupport，接下来就可以讲解AQS了。 5.1 CLH队列锁CLH 队列锁是一种基于链表的可扩展、高性能、公平的自旋锁，申请线程仅仅在本地变量上自旋，它不断轮询前驱的状态，假设发现前驱释放了锁就结束自旋，获取对应的锁。 CLH队列锁由一个前驱节点pre，一个当前节点curNode，一个tail尾节点和一个locked位构成 5.1.1 获取锁若当前线程A需要获取锁，则线程A创建一个新的QNode，先将其locked位设为true，表示需要获取锁，在调用tail.getAndSet(curNode)，CAS的方式将自己设为尾部（这样后面再有需要获取锁的就必须在线程A后排队），同时该方法返回原来的尾节点，让自己的前驱节点指向原尾节点（即指向前一个线程的node节点，如果是第一个获取锁的线程，则pre指向null，因为tail初始化为null），最后循环访问原尾节点的locked位，当其为false时，停止循环，即停止自旋，获得到锁。示意图如下：这样只要前面的线程使用锁结束，locked位变为false，后面排队的线程就可以获取到锁。 5.1.2 释放锁释放锁比较简单，直接将当前节点的locked位设为false，然后让当前节点设为前驱节点，代表出队。简单实现： 123456789101112131415161718192021222324252627282930313233/** * @author Wang * @date 2020/2/216:19 */public class CLH { private final AtomicReference&lt;QNode&gt; tail= new AtomicReference&lt;&gt;(new QNode());; private final ThreadLocal&lt;QNode&gt; pre; private final ThreadLocal&lt;QNode&gt; curNode; private static class QNode { volatile boolean locked = false; } public CLH() { curNode = ThreadLocal.withInitial(() -&gt; new QNode()); pre = ThreadLocal.withInitial(() -&gt; null); } public void lock() { QNode node = curNode.get(); node.locked = true; QNode pred = tail.getAndSet(node); pre.set(pred); while (pred.locked) {} } public void unlock() { QNode qnode = curNode.get(); qnode.locked = false; curNode.set(pre.get()); }} 5.2 AQS AQS即队列同步器，是用来构建锁和其他同步组件的基础框架，如即将要将的Lock的几个实现类，ReentrantLock、ReentrantReadWriteLock以及前面文章提到的CountDownLatch、Semaphore等都是基于AQS框架实现的，当然我们也可以借助AQS实现自己的同步器。使用方式：子类通过继承AQS，实现AQS提供的抽象方法来管理同步状态，在AQS中维护了一个int类型的state代表该状态，并提供了getState()、setState(int newState)和 compareAndSetState(int expect,int update)等方法实现对共享资源state的获取和释放；而该子类推荐使用静态内部类的方式实现，AQS只是定义了若干同步状态获取和释放的方法提供自定义同步组件使用，其支持独占式和共享式两种方式获取同步状态。同步器面向的是锁的实现者，它简化了锁的实现方式，屏蔽了同步状态管理、线程的排队、等待与唤醒等底层操作。锁和同步器很好地隔离了使用者和实现者所需关注的领域。实现者需要继承同步器并重写指定的方法，随后将同步器组合在自定义同步组件的实现中，并调用同步器提供的模板方法，而这些模板方法将会调用使用者重写的方法。 模板方法AQS的设计是基于模板方法模式的。那么什么是模板方法呢？简单的说就是在方法中只定义了该方法的骨架，但是具体的实现步骤放在了其子类中。如Spring中的各种各样的Template模板。如还不懂什么是模板方法，请看以下例子： 1.定义一个改卷子的抽象类： 12345678910111213141516171819202122232425262728293031public abstract class AbstractMarking { //改卷子 protected abstract void check(); //计算总分 protected abstract void compute(); //划分等第 protected abstract void rank(); /** * 批卷的模板方法 * 提供了以上三个抽象方法，具体实现在子类 */ public final void marking(){ check(); compute(); if (shouldRank()){ rank(); } } /** * 是否要打等级(有的科目根据分数要划分等级，有的则按分数评) * @return */ protected boolean shouldRank(){ return false; }} 2.分别定义数学、英语和实训类实现改卷子的抽象类 1234567891011121314151617181920212223242526272829303132333435363738public class English extends AbstractMarking { @Override protected void check() { System.out.println(\"改英语卷子\"); } @Override protected void compute() { System.out.println(\"计算英语分数\"); } @Override protected void rank() { System.out.println(\"不需打英语\"); }}public class Practical extends AbstractMarking { @Override protected void check() { System.out.println(\"改实训成果\"); } @Override protected void compute() { System.out.println(\"计算实训分数\"); } @Override protected void rank() { System.out.println(\"打实训等级\"); } @Override protected boolean shouldRank() { return true; }} 调用： 12345678910public class Main { public static void main(String[] args) { AbstractMarking englishMarking=new English(); englishMarking.marking(); AbstractMarking mathMarking=new Math(); mathMarking.marking(); AbstractMarking pracMarking=new Practical(); pracMarking.marking(); }} 结果： 1234567改英语卷子计算英语分数改高数卷子计算高数分数改实训成果计算实训分数打实训等级 AQS中的模板方法：实现自定义同步组件时，将会调用同步器提供的模板方法。 独占模式： void acquire(int arg)独占式获取同步状态，如果当前线程获取同步状态成功，则由该方法返回，否则进入同步队列等待，该方法会调用重写的tryAcquire(int arg)方法 void acquireInterruptibly(int arg)同上，但相应中断，当前线程未获取到同步状态而进入同步队列，但如果当前线程被中断，则该方法会抛出InterruptedException异常并返回。 boolean tryAcquireNanos(int arg, long nanosTimeout)同2，但增加了超时时间，如果当前线程在超时时间内未获得到同步状态，则返回false，反之返回true protected boolean tryAcquire(int arg)以及tryRelease(int arg) （可重写）tryAcquire独占式获取同步状态，实现该方法需要查询当前状态并判断同步转阿根廷是否符合预期，然后再进行CAS设置同步状态。获取成功返回true，反之返回false。tryRelease度展示释放同步状态，等待获取同步状态的线程将有机会获取同步状态 boolean release(int arg)独占式地释放同步状态，该方法会在释放同步状态后，将同步队列中第一个节点包含的线程唤醒。 共享模式：提供了与独占模式对应的带有Shared的共享式相关的方法。以void acquireShared(int arg)为例，共享式的获取同步状态，如果未获取到，则将当前线程加入同步队列等待，与独占式不同的是该方法允许同一时刻多个线程获取到同步状态。 AQS中的节点和同步队列数据结构在介绍CLH锁时候已经提到了，AQS是基于CLH的变种实现，对应的就是静态内部类Node，定义如下： 先看Node的两个等待模式和几个状态： 1234567891011121314151617static final class Node { //标明线程以共享模式等待锁，如读锁ReadLock static final Node SHARED = new Node(); //标明线程以独占模式等待锁，如可重入锁ReetrantLock(即一把锁一次只能由一个线程持有，而共享锁允许一把锁一次被多个线程持有) static final Node EXCLUSIVE = null; /** *以下几个是线程在队列中的状态 */ // 表示线程获取锁的请求已经 取消 static final int CANCELLED = 1; // 后驱节点入队等待后会更新前驱节点的状态为SIGNAL，等待前驱节点释放同步状态，前驱节点释放后会唤醒后驱节点 static final int SIGNAL = -1; //表示节点在等待队列中，当其他线程调用的condition.signal()后，CONDITION static final int CONDITION = -2; //在共享模式下，前驱节点在唤醒后驱节点的同时，也会无条件的唤醒后驱节点的后驱节点，一直传递下去 static final int PROPAGATE = -3; 除此之外。还有一个值为0的状态，代表初始化Node对象的默认值。从以上变量可看出，当值为负的时候，表示结点等待状态有效，而正值表示结点已被取消。因此可通过判断状态的值是否小于0来判定其是否正常。 成员变量： 1234567891011//线程在队列中的等待状态， 值为以上几个volatile int waitStatus;//当前节点的前驱节点volatile Node prev;//当前节点的后驱节点volatile Node next;//当前节点对应的线程volatile Thread thread;//Node作为同步队列节点时，nextWaiter有两个值：EXCLUSIVE、SHARED标识当前节点是独占模式还是共享模式//Node作为等待队列节点时，nextWaiter表示当前节点的后驱节点。Node nextWaiter; 另外，AQS还提供了头节点和尾节点的引用。 12private transient volatile Node head;private transient volatile Node tail; 但这里的head节点不保存线程信息。如下： 12345private void setHead(Node node) { head = node; node.thread = null; node.prev = null; } head节点是获取同步状态成功的节点，head节点的线程在释放同步状态时，会唤醒其后驱节点，而后驱节点将会在获取同步状态成功时将自己设置为head节点。设置首节点每次都是通过获取同步状态成功的那个线程实现的，因为一次只有一个线程能够成功获取到同步状态，所以设置头节点的方法并不需要使用 CAS ，只需要将头节点设置成为原头节点的后驱节点并断开与原头节点的连接。 独占式同步状态的获取和释放1.获取12345public final void acquire(int arg) { if (!tryAcquire(arg) &amp;&amp; acquireQueued(addWaiter(Node.EXCLUSIVE), arg)) selfInterrupt(); } 1.首先调用自定义同步器实现的 tryAcquire(int arg)方法，该方法需要保证线程安全的获取同步状态，若成功，则返回true，该方法直接返回，若失败，则返回false，继续执行后面的代码。2.如果同步状态获取失败，则构造同步节点并通过addWaiter(Node node)方法将该节点加入到同步队列的尾部。代码如下： 12345678910111213141516171819202122232425Node(Thread thread, Node mode) { this.nextWaiter = mode; this.thread = thread;}private Node addWaiter(Node mode) { //通过当前线程和mode（Node.EXCLUSIVE）构造一个Node节点，在上面的构造方法中可看出mode被赋值给nextWaiter，也印证了上面成员变量中对nextWaiter的解释 Node node = new Node(Thread.currentThread(), mode); //获取原来的尾节点 Node pred = tail; if (pred != null) { //尾节点不为空，让当前节点的前驱指向tail node.prev = pred; //通过CAS更新尾节点 if (compareAndSetTail(pred, node)) { //CAS成功，原tail节点的后驱指向当前节点，实现双向链表 pred.next = node; //返回当前节点 return node; } } //如果尾节点为空或CAS失败，则调用enq(node)将当前节点入队，返回node enq(node); return node; } 入队操作如下：通过一个死循环，不停的CAS设置尾节点 123456789101112131415161718private Node enq(final Node node) { for (;;) { Node t = tail; if (t == null) { //尾节点为空，初始化队列，构建一个新的头节点，并让尾节点等于头接地那 if (compareAndSetHead(new Node())) tail = head; } else { //尾节点不为空 node.prev = t; //CAS设置尾节点 if (compareAndSetTail(t, node)) { t.next = node; return t; } } } } 即入队时，如果当前线程是第一个加入同步队列，则通过compareAndSetHead(new Node())初始化队列头 否则，进行自旋不断CAS将节点插入尾节点 3.最后调用 acquireQueued(Node node,int arg)方法，使得该节点以“死循环”的方式获取同步状态。如果获取不到则阻塞节点中的线程，则只能等待前驱节点出队或阻塞线程被中断才能唤醒阻塞线程。 123456789101112131415161718192021222324252627final boolean acquireQueued(final Node node, int arg) { boolean failed = true; try { boolean interrupted = false; for (;;) { //获取前驱节点 final Node p = node.predecessor(); //只有前驱节点是头节点才可以tryAcquire if (p == head &amp;&amp; tryAcquire(arg)) { //如果获取同步状态成功，则将头节点换为当前节点 setHead(node); p.next = null; // help GC failed = false; //返回中断状态，此时不需要中断 return interrupted; } //前驱节点非头节点或获取同步状态失败 if (shouldParkAfterFailedAcquire(p, node) //判断获取同步状态失败后是否需要阻塞 &amp;&amp; parkAndCheckInterrupt())//如果需要阻塞， interrupted = true;//置中断标志为true } } finally { //如果获取失败，则将当前节点取消 if (failed) cancelAcquire(node); } } shouldParkAfterFailedAcquire如下： 12345678910111213141516171819private static boolean shouldParkAfterFailedAcquire(Node pred, Node node) { //获取前驱节点的状态 int ws = pred.waitStatus; //如果前驱节点是SIGNAL(前驱节点释放锁后会通知后驱节点)，则当前节点可以进行安全等待 if (ws == Node.SIGNAL) return true; //ws大于0即处于CANCEL状态 if (ws &gt; 0) { //循环将当前节点与前驱节点为非CANCEL状态的节点连接，即循环遍历找到有效状态节点 do { node.prev = pred = pred.prev; } while (pred.waitStatus &gt; 0); pred.next = node; } else { //处于其他状态时，将前驱节点的状态更新尾SIGNAL，然后返回false，会在acquireQueued中继续下一个循环，直到前驱节点状态为SIGNAL才会继续执行下一个方法 compareAndSetWaitStatus(pred, ws, Node.SIGNAL); } return false; } 可见，该方法只有在前驱节点状态为SIGNAL时才会返回true，可以进行安全等待。接着会调用parkAndCheckInterrupt()，阻塞当前线程，并返回中断状态 1234private final boolean parkAndCheckInterrupt() { LockSupport.park(this); return Thread.interrupted(); } 流程总结：1.调用tryAcquire尝试获取同步状态，如果获取成功则返回，否则进入 22.调用addWaiter将当前线程构造一个新节点加入同步等待队列，如果队列未初始化则先初始化，否则直接将新节点加入队尾3.接着调用acquireQueued让加入队列的节点开始自旋，只有该节点的前驱节点为head时才可以尝试获取状态（这里一是因为头节点是成功获取到同步状态的节点，头节点释放同步状态会唤醒后驱节点，所以要加此判断，二是因为队列的FIFO），否则跳过处于CANCEL状态的节点，并将前驱节点更新为SIGNAL，只有前驱节点状态为SIGNAL时，该节点才可以进行park等待，返回中断状态4. 如果被中断，则调用selfInterrupt()中断当前线程 2.释放释放同步状态通过release方法，释放后会唤醒后驱节点，让后驱节点重新尝试获取同步状态 12345678910public final boolean release(int arg) { if (tryRelease(arg)) {///调用模板方法释放同步状态，成功返回true，失败返回false 具体实现在子类 Node h = head; //头节点不为空且状态非0时唤醒后驱节点 if (h != null &amp;&amp; h.waitStatus != 0) unparkSuccessor(h); return true; } return false; } unparkSuccessor如下： 12345678910111213141516171819202122private void unparkSuccessor(Node node) { //获取头节点（要释放同步状态的节点）的状态 int ws = node.waitStatus; if (ws &lt; 0) //将状态改为0 compareAndSetWaitStatus(node, ws, 0); //获取后驱节点 Node s = node.next; //如果后驱节点为空或已经被取消 if (s == null || s.waitStatus &gt; 0) { //重新置为null s = null; //从尾部循环获取处于等待状态的节点作为后驱接地那 for (Node t = tail; t != null &amp;&amp; t != node; t = t.prev) if (t.waitStatus &lt;= 0) s = t; } if (s != null) //后驱节点非空时，唤醒该节点 LockSupport.unpark(s.thread); } 那么有一个问题，为什么要从尾部遍历呢？从Node类的源码给出如下解释：首先看一下之前讲的addWaiter 12345678910111213private Node addWaiter(Node mode) { Node node = new Node(Thread.currentThread(), mode); Node pred = tail; if (pred != null) { node.prev = pred; if (compareAndSetTail(pred, node)) { pred.next = node; return node; } } enq(node); return node; } 在插入到尾节点时，先执行的是node.prev=pred，将当前节点与前驱节点连接，然后compareAndSetTail(pred, node)原子更新尾节点后才执行pred.next = node;将前驱节点的next引用与新的尾节点连接起来，如果在该操作执行前调用了unparkSuccessor就无法从前往后完全遍历 共享模式同步状态的获取和释放获取以共享模式获取同步状态，忽略中断 12345public final void acquireShared(int arg) { if (tryAcquireShared(arg) &lt; 0) doAcquireShared(arg); } tryAcquireShared(int arg)模板方法返回值为 int 类型，当返回值大于等于 0 时，表示能够获取到同步状态。可以简单看一下Semphore中非公平锁对该方法的实现： 12345678910111213141516protected int tryAcquireShared(int acquires) { return nonfairTryAcquireShared(acquires); }final int nonfairTryAcquireShared(int acquires) { //通过一个死循环获取同步状态 for (;;) { //获取当前同步状态，这里表示当前可用许可数 int available = getState(); //减去本次申请许可数acquires，得到申请成功后的剩余许可数remaining int remaining = available - acquires; if (remaining &lt; 0 || //如果remaining小于0，则本次申请没有获取成功，直接返回，后续加入等待队列 //如果remaining&gt;0，则CAS地重新设置状态，更新尾remaining，返回remaining compareAndSetState(available, remaining)) return remaining; } } 回到acquireShared()，如果获取同步失败，则执行doAcquireShared()进入同步队列等待，自旋获取 1234567891011121314151617181920212223242526272829303132333435private void doAcquireShared(int arg) { //构造一个共享模式的节点加入到同步队列尾部 final Node node = addWaiter(Node.SHARED); //获取成功否 boolean failed = true; try { //是否被中断 boolean interrupted = false; for (;;) { //获取前驱节点 final Node p = node.predecessor(); if (p == head) { //只有前驱节点是head节点时才可以尝试获取同步状态，原因前面已讲过 int r = tryAcquireShared(arg); //返回值大于0代表获取成功 if (r &gt;= 0) { //将当前节点设为头节点，并且如果还有剩余资源，则继续传播唤醒后驱节点中属于共享模式的节点 setHeadAndPropagate(node, r); p.next = null; // help GC if (interrupted) selfInterrupt(); failed = false; return; } } //获取失败，则判断当前节点是否应该阻塞，如果应该阻塞，则将其阻塞并检查中断 if (shouldParkAfterFailedAcquire(p, node) &amp;&amp; parkAndCheckInterrupt()) interrupted = true; } } finally { if (failed) cancelAcquire(node); } } 总体逻辑和独占式的相同，但因是共享式的，所有在获取了同步状态后需要继续唤醒后驱节点，无条件传播下去。接下来看setHeadAndPropagate的实现： 12345678910111213private void setHeadAndPropagate(Node node, int propagate) { //获取旧的头节点后面会用到 Node h = head; //将当前节点设为新的头节点 setHead(node); //propagate &gt; 0 代表还有剩余同步状态 if (propagate &gt; 0 || h == null || h.waitStatus &lt; 0 || (h = head) == null || h.waitStatus &lt; 0) { Node s = node.next; if (s == null || s.isShared()) doReleaseShared(); } } 关于为什么不只用propagate &gt; 0 来判断，以及PROPAGATE的意义，另一个博主的这篇文章做了很详细的解释：https://www.cnblogs.com/micrari/p/6937995.html 释放：1234567public final boolean releaseShared(int arg) { if (tryReleaseShared(arg)) {//尝试释放同步状态 doReleaseShared(); return true; } return false; } doReleaseShared() 如下：共享模式下，可能会有多个线程释放同步状态 1234567891011121314151617181920212223private void doReleaseShared() { for (;;) { Node h = head; //头节点非空且不等于尾节点 if (h != null &amp;&amp; h != tail) { //获取头节点状态 int ws = h.waitStatus; //如果状态为SIGNAL，则CAS将其状态改为0，如果CAS失败，则一直循环，如果成功则唤醒后驱节点 if (ws == Node.SIGNAL) { if (!compareAndSetWaitStatus(h, Node.SIGNAL, 0)) continue; unparkSuccessor(h); } else if (ws == 0 &amp;&amp; //如果状态为0，则改为PROPAGATE，以确保释放后继续传播 !compareAndSetWaitStatus(h, 0, Node.PROPAGATE)) continue; // loop on failed CAS } //这里，如果头节点在改变了，则继续循环，否则直接break if (h == head) break; } } AQS中的条件队列ConditionObject前面已经介绍了Condition接口，而ConditionObject是Condition的一个实现类，为单向链表。该条件队列的节点也是使用了内部类Node，可以在不满足某个条件的时候挂起线程等待，直到满足某个条件的时候在唤醒线程。下面看一下该类的成员变量： 12345678//等待队列的头节点private transient Node firstWaiter;//等待队列的尾节点private transient Node lastWaiter; //在退出等待时重新中断 private static final int REINTERRUPT = 1;//在退出等待时抛出InterruptedExceptionprivate static final int THROW_IE = -1; 一个 Condition 包含一个等待队列。Condition.await()方法，将会以当前线程构造节点，并将节点从尾部加入等待队列。 1.先看await()方法：12345678910111213141516171819202122232425262728public final void await() throws InterruptedException { //1,如果中断，直接抛出异常 if (Thread.interrupted()) throw new InterruptedException(); //2.将当前线程加入条件等待队列 Node node = addConditionWaiter(); //3.释放当前锁，并唤醒后驱节点，返回释放前的同步状态 int savedState = fullyRelease(node); int interruptMode = 0; //4.循环判断当前node是否已经转移到AQS队列中，直到成功转移到AQS队列结束循环 while (!isOnSyncQueue(node)) { //4.1 阻塞当前线程，直到被unpark或中断 LockSupport.park(this); //4.2如果发生了中断，则要检查中断，并检查节点已经加入到同步队列，如已加入，则break if ((interruptMode = checkInterruptWhileWaiting(node)) != 0) break; } if (acquireQueued(node, savedState) //5.死循环重新获取同步状态（刚刚释放了多少这里就获取多少），返回false获取成功，返回true获取失败 &amp;&amp; interruptMode != THROW_IE) //6.如果被signal后发生中断 interruptMode = REINTERRUPT;//将中断模式改为REINTERRUPT if (node.nextWaiter != null) //7. 删除取消的后驱节点 unlinkCancelledWaiters(); if (interruptMode != 0) //8.如果线程中断了，则抛出异常，如果为REINTERRUPT则中断当前线程 reportInterruptAfterWait(interruptMode); } 添加到等待队列的方法addConditionWaiter()： 1234567891011121314151617181920212223242526Node(Thread thread, int waitStatus) { // Used by Condition this.waitStatus = waitStatus; this.thread = thread; } private Node addConditionWaiter() { //获取尾节点 Node t = lastWaiter; //如果尾节点状态为CANCEL，则移除它 if (t != null &amp;&amp; t.waitStatus != Node.CONDITION) { //清除CANCEL的节点，将所有CONDITION的节点连接起来 unlinkCancelledWaiters(); //重新指向lastWaiter t = lastWaiter; } //构建一个新的condition类型Node加入条件等待队列 Node node = new Node(Thread.currentThread(), Node.CONDITION); //如果尾节点此时为空，则重新初始化首尾相同的队列 if (t == null) firstWaiter = node; else //将尾节点的后驱引用指向当前节点 t.nextWaiter = node; //更新尾节点 lastWaiter = node; return node; } 上述节点引用更新的过程并没有使用 CAS 保证，原因在于调用 await()方法的线程必定是获取了锁的线程，也就是说该过程是由锁来保证线程安全的。 unlinkCancelledWaiters()源码： 123456789101112131415161718192021222324252627private void unlinkCancelledWaiters() { //获取首节点 Node t = firstWaiter; //保存当前节点的前驱节点的引用 Node trail = null; while (t != null) { //获取后驱节点 Node next = t.nextWaiter; //如果当前节点的状态非CONDITION，则移除并将整个链表连接起来 if (t.waitStatus != Node.CONDITION) { //断开当前节点的后驱引用 t.nextWaiter = null; if (trail == null) //首节点指向下当前节点的后驱节点 firstWaiter = next; else //前驱节点存在，则让前驱节点直接跨过当前节点指向当前节点的后驱节点 trail.nextWaiter = next; if (next == null) lastWaiter = trail; } else //当前节点状态为CONDITION，则让trail指向当前节点，当前节点顺为下个节点 trail = t; t = next; } } 彻底释放锁fullyRelease(Node node)即无论多少次重入，通通清零 12345678910111213141516171819final int fullyRelease(Node node) { boolean failed = true; try { //获取当前同步状态 int savedState = getState(); //调用release方法释放并唤醒下一个同步队列的线程 if (release(savedState)) { failed = false; return savedState; } else { //如果释放失败，则抛出异常 throw new IllegalMonitorStateException(); } } finally { if (failed) //如果失败，则取消当前节点 node.waitStatus = Node.CANCELLED; } } isOnSyncQueue(Node node):如果该节点之前在条件等待队列，但现在在同步队列中，则返回true；如果不在同步队列返回false 12345678910111213141516171819202122//node为当前尾节点final boolean isOnSyncQueue(Node node) { //node的状态为CONDITION或node的前驱为空，则说明不在同步队列中，因为队列除头节点外的其他节点的前驱节点都不为 if (node.waitStatus == Node.CONDITION || node.prev == null) return false; //如果当前node 有后继节点，则说明其在同步队列中 if (node.next != null) return true; //到此方法就说明当前尾节点前驱不为空，且后驱为空，此时可以认为node正处于放入同步队列enq方法中的compareAndSetTail(t, node)操作中，前面已经分析过，此时已经连接好了pre但没有连接next，而这个CAS操作有可能失败，所以通过findNodeFromTail再尝试一次判断。 return findNodeFromTail(node); } //该方法中通过一个死循环从同步队列的尾到前遍历寻找当前节点，如果找到返回ture，否则返回false private boolean findNodeFromTail(Node node) { Node t = tail; for (;;) { if (t == node) return true; if (t == null) return false; t = t.prev; } } checkInterruptWhileWaiting(Node node)检查是否中断，如果在signal之前中断，则返回THROW_IE，如果在signal之后，则返回REINTERRUPT，如果没有中断，则为0。 123456private int checkInterruptWhileWaiting(Node node) { return Thread.interrupted() ? //如果发生了中断需要调用transferAfterCancelledWait保证中断的线程已经加入到同步队列 (transferAfterCancelledWait(node) ? THROW_IE : REINTERRUPT) : 0; } transferAfterCancelledWait(Node node)保证中断的线程已经加入到同步队列，判断中断的时候，是否有signal方法的调用，如果返回false表示在中断前被signal，之后checkInterruptWhileWaiting返回REINTERRUPT重新中断；如果返回true表示在中断后被signal，之后checkInterruptWhileWaiting返回THROW_IE 抛出中断异常。 12345678910111213final boolean transferAfterCancelledWait(Node node) { //将当前节点的状态从CONDITION改为0（从这也可以看出isOnSyncQueue方法中通过判断状态是否为CONDITION来判断是否被转移到同步队列） if (compareAndSetWaitStatus(node, Node.CONDITION, 0)) { //如果CAS成功，说明没有被signal，如果被signal，其状态会改为SIGNAL（后边会讲到），则加入同步队列 enq(node); return true; } //如果状态CAS失败，即node状态不为CONDITION，说明已经被signal或被中断，但不能保证先后顺序，通过while循环等待node已经转移到同步队列 while (!isOnSyncQueue(node)) Thread.yield(); //返回false重新中断 return false; } await的带超时时间的其他几个方法同这个基本一样，只是加了超时时间，具体作用看上面的Condition的介绍 2.再看signal相关 将等待时间最长的线程（如果存在）,从条件等待队列移至拥有锁的等待队列。 12345678public final void signal() { //1.首先判断当前线程是不是独占模式，如果不是则抛出异常 if (!isHeldExclusively()) throw new IllegalMonitorStateException(); Node first = firstWaiter; if (first != null) doSignal(first); } doSignal(Node first)会从从首节点开始遍历，把第一个非空、没取消的节点转移到同步队列 123456789private void doSignal(Node first) { do { //删除first接地那 if ( (firstWaiter = first.nextWaiter) == null) lastWaiter = null; first.nextWaiter = null; } while (!transferForSignal(first) &amp;&amp; (first = firstWaiter) != null); } transferForSignal(Node node) 会将节点从条件队列转移到AQS队列 123456789101112131415final boolean transferForSignal(Node node) { //尝试将Node的状态从CONDITION改为0, if (!compareAndSetWaitStatus(node, Node.CONDITION, 0)) //如果CAS失败，说明节点在signal前被取消，返回false，转移失败 return false; //CAS成功，则将该节点加入AQS队列尾部，并返回之前的tail Node p = enq(node); //获取之前的tail的状态 int ws = p.waitStatus; if (ws &gt; 0 //&gt;0，即之前的tail被取消， 则直返回唤醒当前节点的线程 || !compareAndSetWaitStatus(p, ws, Node.SIGNAL))//如果没有被取消，则将原tail节点状态设为SIGNAL,如果失败了则直接唤醒当前线程，如果成功了则前驱节点被设为SIGNAL LockSupport.unpark(node.thread);//唤醒当前节点，当前线程可从await()中的park()返回 return true; } 另外还有signalAll()方法。实现将Condition队列上的所有节点转移到AQS同步队列去竞争锁（独占）。 总结：一个同步器拥有一个同步队列（双向）和多个等待队列（单向）。调用 await()相关的方法，会让当前线程进入等待队列并释放锁，同时线程进入等待状态。从 await()方法返回时，当前线程一定获取了 Condition 绑定的锁。1.调用 await()相关方法时，将同步队列的首节点的线程获取到了锁，将通过addConditionWaiter()方法把当前线程构造成一个新的节点并加入等待队列中，然后释放同步状态，唤醒同步队列中的后驱节点，随后当前线程会进入等待状态。2.等待队列中的节点通过其他线程调用Condition.signal()方法被唤醒后，被唤醒的线程开始尝试获取同步状态。如果是通过中断唤醒，则会抛出InterruptedException，如果不是，将中断模式设为REINTERRUPT，并将被取消的后驱节点清除。3.调用signal()方法，会唤醒在等待队列中等待时间最长的节点（首节点），在唤醒节点之前，会将该节点转移到同步队列中。但当前线程必须是获取了锁 。4.接着获取等待队列的首节点，将其全地转移到同步队列后并使用 LockSupport .unpark唤醒该节点中的线程。5.被唤醒的线程就会从 await()方法中的 while (!isOnSyncQueue(node))循环中退出。（isOnSyncQueue(Node node)方法返回 true，节点已经在同步队列中），6.然后调用 acquireQueued()方法加入到获取同步状态的竞争中。成功获取同步状态（或者说锁）之后，被唤醒的线程将从先前调用的 await()方法返回，此时该线程已经成功地获取了锁。 （部分分析可能有瑕疵，还请指正，感谢~） 下一篇讲Lock的实现类： java并发编程之ReentrantLock和读写锁","link":"/posts/20200204-lcAQS.html"},{"title":"java并发编程之ReentrantLock和读写锁ReentrantReadWriteLock","text":"在前文java并发编程之显示锁Lock、Condition接口、LockSupport以及AQS（同步队列、条件等待队列）详解已经对Lock、Condition以及AQS相关进行了介绍，接下来就要讲一讲Lock接口的几个实现类：ReentrantLock、ReentrantReadWriteLock及其内部类ReadLock和WriteLock。本文中带△△的标注代表前文已讲过，不详述。 首先了解下锁的可重入的概念： 一、锁的可重入“重入“是指线程在获取到锁之后能够再次获取该锁而不会被阻塞，因此：1）线程再次获取锁时，需要去识别获取锁的线程是否为当前持有锁的线程，如果是，则再次成功获取。2）线程获取了几次锁，就需要释放几次锁，只有全部释放完毕，其他线程才能获得锁，因此需要对锁的获取进行自增计算，自增次数表示当前锁被重复获取的次数，而锁被释放时，每次释放该计数都自减1直到减到0时表示成功释放锁。 二、ReentrantLock2.1 类图从上图可以看出：1.ReentrantLock实现了Lock接口2.内部类Sync继承了AQS3. FairSync和NocfairSync继承了Sync 另外，ReentrantLock是可重入的独占锁，因此一次只能有一个线程可获取锁，而其他线程会被阻塞在AQS队列，针对获取锁，其提供了公平和非公平的实现，而公平模式和非公平模式主要通过ReentrantLock的构造方法确定的，如下： 123456public ReentrantLock() { sync = new NonfairSync();}public ReentrantLock(boolean fair) { sync = fair ? new FairSync() : new NonfairSync();} 默认构造函数中，实现了非公平的实现，而带参的构造函数，参数fair为true时为公平实现，为false时为非公平实现。 ReentrantLock的成员变量只有一个Sync对象： 1private final Sync sync; 其成员函数除了实现Lock接口提供的几个方法外（如下），其他方法都是很简单，如获取等待队列长度、获取等待的线程等待。（这几个方法的介绍在上一篇文章有介绍）而对这几个方法的具体实现，都是根据Sync实现了公平锁还是非公平锁。 下面先讲非公平锁的相关方法： 2.2 非公平模式以下是非公平锁的lock()方法： 2.2.1 lock()123456final void lock() { if (compareAndSetState(0, 1)) setExclusiveOwnerThread(Thread.currentThread()); else acquire(1);} 该方法中：1.首先调用compareAndSetState(0, 1)尝试将状态值从0改为1，如果CAS成功，表示锁已经被当前线程占用，则将当前线程设为有独占访问权的线程2.如果CAS失败，表示锁已经被其他线程占用，则调用acquire(1)方法尝试获取锁。 △△acquire(1)为AQS中的方法： 12345public final void acquire(int arg) { if (!tryAcquire(arg) &amp;&amp; acquireQueued(addWaiter(Node.EXCLUSIVE), arg)) selfInterrupt(); } 其中tryAcquire()为尝试获取锁的模板方法，这里的具体实现就是调用了NonfairSync下的非公平实现方法： 12345678910111213141516171819202122232425262728293031323334protected final boolean tryAcquire(int acquires) { return nonfairTryAcquire(acquires); }final boolean nonfairTryAcquire(int acquires) { //获取当前线程 final Thread current = Thread.currentThread(); //当前当前同步状态 int c = getState(); //如果状态为0，表示当前没有线程持有锁 if (c == 0) { //重复lock()中的第一个if语句 if (compareAndSetState(0, acquires)) { setExclusiveOwnerThread(current); return true; } } //如果状态不为0，代表当前有线程持有锁 // 则判断当前持有锁的线程是否为当前线程 else if (current == getExclusiveOwnerThread()) { // 如果是当前线程持有锁 // 1.让当前状态加上acquires(可重入就在这里体现，进行自增) int nextc = c + acquires; //2. 如果加上acquires后的状态值仍小于0 if (nextc &lt; 0) //说明溢出了，抛出异常 throw new Error(\"Maximum lock count exceeded\"); // 如果大于0，则更新当前状态 setState(nextc); //返回true return true; } // 如果不是当前线程，则返回false，尝试获取失败 return false; } 简单总结一下流程：1.首先判断当前状态值state是否等于0，如果等于0则说明没有线程持有锁，进入2，否则进入32. CAS更新状态值，并将当前线程设为独占的3.判断当前持有锁的线程是否为当前线程，如果是则自增状态值，否则返回false；自增状态时需检查自增后的状态值，如果大于0，则更新state，如果小于0，说明溢出，抛出异常。 而如果获取失败了则会执行AQS的acquireQueued(addWaiter(Node.EXCLUSIVE), arg))方法，将当前线程构造为一个独占模式的节点加入同步队列，如果前驱节点为首节点，才可以尝试获取锁，否则跳过处于CANCEL状态的节点，并将前驱节点更新为SIGNAL阻塞自身等待唤醒。以上就是lock()的非公平实现，了解了其可重入的实现核心，如果我们想实现一个自己的不可重入的独占锁，就很简单了。主要就是修改tryAcquire(int arg) 方法，如果CAS成功，则将当前线程设为独占的，否则直接返回false，不进行持有锁是否为当前线程的判断等相关操作。 123456789/*获得锁*/ @Override protected boolean tryAcquire(int arg) { if(compareAndSetState(0,1)){ setExclusiveOwnerThread(Thread.currentThread()); return true; } return false; } 2.2.2 unlock()ReentrantLock的unlock()也是直接调用了AQS的△△release()方法： 123456789101112（ReentrantLock）public void unlock() { sync.release(1); }（AQS）public final boolean release(int arg) { if (tryRelease(arg)) { Node h = head; if (h != null &amp;&amp; h.waitStatus != 0) unparkSuccessor(h); return true; } return false;} 该方法的tryRelease(arg)也是模板方法，在ReentrantLock的实现如下：（非公平和公平模式只是针对lock过程，release的实现是相同的） 12345678910111213141516171819protected final boolean tryRelease(int releases) { // 计算当前状态减去releases后的值 int c = getState() - releases; // 如果当前线程不是独占模式的，则抛出异常 if (Thread.currentThread() != getExclusiveOwnerThread()) throw new IllegalMonitorStateException(); // 可以理解为是否彻底释放 boolean free = false; // 如果c为0，说明当前线程已经将锁释放完毕，即重入的次数都已释放 if (c == 0) { // 置为true，表示已彻底释放 free = true; // 将当前独占线程清空 setExclusiveOwnerThread(null); } // 如果自减一后的state不为0，说明尚未释放完毕，返回false setState(c); return free; } 流程简单的将就是：如果当前状态自减1后为0，则说明锁释放完毕，情况独占锁；如果不为0，则说明重入锁未释放完毕，仍持有资源 如果返回false，就会继续执行release()的△△unparkSuccessor(h);方法唤醒后驱节点。而后驱节点被唤醒后就会再次执行acquireQueued() 1234567891011121314final boolean acquireQueued(final Node node, int arg) { .............. boolean interrupted = false; for (;;) { final Node p = node.predecessor(); if (p == head &amp;&amp; tryAcquire(arg)) { setHead(node); p.next = null; // help GC failed = false; return interrupted; } ............. } } 此时p==head成立，将当前节点设为head，与原head断开，并返回中断标志，此时如没有被中断，就直接从acquire()方法返回，否则中断当前线程。 2.3 公平模式lock()方法：该lock方法也是实现了AQS的acquire()方法，但是是在FairSync实现了公平模式获取锁： 1234567891011121314151617181920protected final boolean tryAcquire(int acquires) { final Thread current = Thread.currentThread(); int c = getState(); if (c == 0) { if (!hasQueuedPredecessors() &amp;&amp; compareAndSetState(0, acquires)) { setExclusiveOwnerThread(current); return true; } } else if (current == getExclusiveOwnerThread()) { int nextc = c + acquires; if (nextc &lt; 0) throw new Error(\"Maximum lock count exceeded\"); setState(nextc); return true; } return false; } } 从源码可以看出，只是在当前状态值为0时，即没有线程持有锁时增加了一个hasQueuedPredecessors()判断，源码如下： 12345678public final boolean hasQueuedPredecessors() { Node t = tail; Node h = head; Node s; return h != t &amp;&amp; //1.头尾节点不相同，说明队列非空，如果队列空，则返回false，说明没有线程在等待 ((s = h.next) == null || s.thread != Thread.currentThread());//2. 队列非空，如果等待线程不是当前线程，则返回true，如果是当前线程，则返回true } 该方法返回当前等待队列是否有其他线程等待，true表示有其他线程在等待，false表示没有如果返回false，则继续进行后面的步骤，同非公平步骤相同 可见，公平锁会考虑线程等待的优先顺序，而非公平锁不考虑顺序，谁来谁就去争夺锁。 三、读写锁ReentrantReadWriteLock在读多写的场景下，该锁就非常适用。该类维护了一个读锁ReadLock和一个写锁WriteLock。 关于写锁：1.写锁是一个支持可重入的排它锁。如果当前线程已经获取了写锁，则增加写状态。如果当前线程在获取写锁时，读锁已经被获取（读状态不为 0）或者该线程不是已经获取写锁的线程，则当前线程进入等待状态。2.如果读锁被获取，则写锁不能被获取。 因为读写锁要保证写锁的操作对读锁可见，如果读锁已被获取，又对写锁获取，那么其他读线程就无法感知到当前写线程的操作。因此，写锁被当前线程获取的前提是其他读线程全部释放读锁，3.写锁一旦被获取，则其他读写线程的访问均被阻塞。关于读锁：1.读锁是一个支持重进入的共享锁，它能够被多个线程同时获取。2.在写锁没有被获取时，读锁可以被多次获取。获取成功则安全地增加读状态（该状态是所有线程获取读锁的次数和，但每个线程获取读锁的次数保存在ThreadLocal中）3.如果在获取读锁时，写锁被其他线程获取，则当前线程阻塞等待 关于锁的升降级：1.锁降级指的是写锁降级为读锁：当前持有写锁，同时再去获取读锁，最后再释放写锁2.锁升级指的是读锁升级为写锁：当前持有读锁，获取写锁，最后释放读锁，但RentrantReadWriteLock不支持锁的升级，因为如果多个线程持有读锁，任意一个线程升级到了写锁，这样就不能保证写线程的更新对其他读线程的可见性。 3.1 类结构从图中可以见出：1.ReentrantReadWriteLock实现了ReadWriteLock接口，在该接口中提供了一个读锁和一个写锁，其具体实现就ReentrantReadWriteLock中的读锁和写锁。2.ReentrantReadWriteLock有5个内部类，分别为ReadLock、WriteLock、FairSync、NonfairSync和Sync，其中FairSync和NonfairSync是Sync的公平和非公平的实现，Sync实现了AQS，读锁和写锁实现了Lock接口。3.在Sync下又有两个内部类：ThreadLocalHoldCounter和HoldCounter 3.2 Sync首先看Sync类：它的两个内部类源码如下： 123456789101112static final class HoldCounter { int count = 0; final long tid = getThreadId(Thread.currentThread()); }static final class ThreadLocalHoldCounter extends ThreadLocal&lt;HoldCounter&gt; { public HoldCounter initialValue() { return new HoldCounter(); } } 其中HoldCounter 内部维护了一个count变量和一个tid，其中count表示一个读线程重入的次数，tid表示持有读锁的当前线程的id，唯一标识一个线程。而ThreadLocalHoldCounter继承了ThreadLocal，并且将HoldCounter作为泛型，重写了ThreadLocal的initialValue()方法，可直接通过get获取当前线程的count值。 在看起类属性前，先了解其读写状态的设计： 读写状态的设计：ReentrantLock 中，同步状态表示锁被一个线程重复获取的次数，而读写锁的自定义同步器需要在同步状态（整型变量）上维护多个读线程和一个写线程的状态，因此就需要对该遍历进行“按位切割使用”。同步状态的高 16 位表示读（读锁线程数），低 16 位表示写（写锁重入此数）读写锁通过位运算确定当前状态。假设当前同步状态值为 S，写状态等于 S&amp;0x0000FFFF（将高 16 位全部抹去），读状态等于 S&gt;&gt;&gt;16（无符号补 0 右移 16 位）。当写状态增加1时，等于S+1，当读状态增加1时，等于S+(1&lt;&lt;16)，也就是S+0x00010000。根据状态的划分能得出一个推论：S 不等于 0 时，当写状态（S&amp;0x0000FFFF）等于 0 时，则读状态（S&gt;&gt;&gt;16）大于 0，即读锁已被获取。（图片来源于网络） Sync的成员属性如下： 123456789101112131415161718192021222324252627 读写锁共用同步状态，高16用于读，低16位用于写 static final int SHARED_SHIFT = 16;// 读锁的单位（因为读锁是高16位，因此每次要加上2^16） static final int SHARED_UNIT = (1 &lt;&lt; SHARED_SHIFT); // 写锁的最大可重入次数或读锁允许的最大线程数 static final int MAX_COUNT = (1 &lt;&lt; SHARED_SHIFT) - 1; // 写锁掩码，用于状态的低16位有效值 static final int EXCLUSIVE_MASK = (1 &lt;&lt; SHARED_SHIFT) - 1; //读锁的计数，当前同步状态右移16位获取读锁计数 static int sharedCount(int c) { return c &gt;&gt;&gt; SHARED_SHIFT; } //获取写线程的数量（获取写锁的重入次数） static int exclusiveCount(int c) { return c &amp; EXCLUSIVE_MASK; }// 保存本地线程获取读锁的重入次数，当前线程的计数变为0时删除之 private transient ThreadLocalHoldCounter readHolds; // 表示最后一个成功获取读锁的线程的计数的缓存 /* 获取和释放读锁的时候，需要更新HoldCount，会先检测缓存的是否为空，如果不为空，则判断线程ID是否和当前线程ID相同 如果相同，就直接通过缓存更新HoldCount 否则，从readHolds中获取HoldCounter对象，赋值给该缓存，最后再更新HoldCounter的计数（不理解的话需要先看下面的源码分析，回头再看就理解了） */ private transient HoldCounter cachedHoldCounter; //第一个获得读取锁的线程。（这里使用此变量应该就是为了提高效率，当只有一个线程获取读锁时，可直接从此变量获取，不需要操作readHolds.get()了） private transient Thread firstReader = null; //是firstReader的重入数。 private transient int firstReaderHoldCount; Sync的构造函数： 123456Sync() { // 初始化本地线程计数器 readHolds = new ThreadLocalHoldCounter(); //确保readHolds的可见性 setState(getState()); } Sync是公平的还是非公平的是在ReentrantReadWriteLock的构造中确定的： 12345public ReentrantReadWriteLock(boolean fair) { sync = fair ? new FairSync() : new NonfairSync(); readerLock = new ReadLock(this); writerLock = new WriteLock(this); } fair为true时实现公平模式，为false时实现非公平模式，同时初始化读锁和写锁。 写锁：写锁内部就维护了一个Sync，其具体实现由ReentrantReadWriteLock中的sync决定： 123456789public static class WriteLock implements Lock, java.io.Serializable { private static final long serialVersionUID = -4992448646407690164L; private final Sync sync; protected WriteLock(ReentrantReadWriteLock lock) { sync = lock.sync; }} 写锁的lock():lock()也是调用了AQS的lock()方法，具体实现为Sync下的tryAcquire() 12345678910111213141516171819202122232425262728293031protected final boolean tryAcquire(int acquires) { //获取当前线程 Thread current = Thread.currentThread(); //获取同步状态 int c = getState(); // 获取写线程数量 int w = exclusiveCount(c); //状态不为0，表示已有其他线程获取读锁或写锁 if (c != 0) { //a.而如果此时w==0即写锁没有被占用，说明读锁被占用，因此直接返回false，获取失败 if (w == 0 || //b.如果当前写锁被持有，则判断持有锁的线程是否为当前线程，如果不是则返回false，如果是则继续 current != getExclusiveOwnerThread()) return false; //如果持有写锁的线程为当前线程 // 则重新计算当前写锁重入次数后是否大于最大重入次数(2^16-1) if (w + exclusiveCount(acquires) &gt; MAX_COUNT) //如果超出最大重入次数，则抛出异常 throw new Error(\"Maximum lock count exceeded\"); //否则更新同步状态，即自增重入次数 setState(c + acquires); return true; } //如果状态为0，表示没有线程获取读写锁 if (writerShouldBlock() || //是否应该阻塞当前获取写锁的线程 !compareAndSetState(c, c + acquires))//如果不需要阻塞，则CAS更新同步状态 return false; //CAS成功，将当前线程设为独占的 setExclusiveOwnerThread(current); return true; } writerShouldBlock()的公平实现需要调用hasQueuedPredecessors判断有没有已经在等待获取写锁的线程，如果有则阻塞当前线程，如果没有则返回true；而非公平实现直接返回false 1234567891011static final class NonfairSync extends Sync { final boolean writerShouldBlock() { return false; }}static final class FairSync extends Sync { final boolean writerShouldBlock() { return hasQueuedPredecessors(); } } 流程总结：获取当前同步状态state，和写锁重入次数w 如果state不为0.说明读锁或写锁被占用1.1 如果w为0说明写锁被持有，因此读锁已经被持有，直接返回false1.2 如果w不为0，说明当前写锁被持有，则判断当前写锁线程是否为当前线程，如果是则判断重入次数是否溢出，如果没溢出则更新同步状态返回true；如果不是则直接返回false 如果为0，说明读写锁都没有被占用，则根据sync是公平还是非公平实现判断当前线程是否需要阻塞，如果不需要阻塞则CAS更新同步状态，成功后将当前线程设为独占的，并返回true，获取写锁成功 写锁的unlock():同样调用AQS的unlock，tryRelease的实现如下： 12345678910111213protected final boolean tryRelease(int releases) { //1.如果当前线程不是持有写锁的线程，直接抛出异常 if (!isHeldExclusively()) throw new IllegalMonitorStateException(); //2.计算当前状态减去releases后的值 int nextc = getState() - releases; boolean free = exclusiveCount(nextc) == 0; if (free) //如果重入次数为0，则直接清空锁的持有者。因此重入锁必须将重入次数全部释放后才可真正释放锁,返回true setExclusiveOwnerThread(null); //否则更新重入次数，返回false setState(nextc); return free; 流程总结：1.如果当前线程不是持有写锁的线程直接抛出异常2.如果获取写锁数量为0表示成功释放，置独占线程为空，返回true2.如果不为0，则更新同步状态，返回false 读锁：结构同写锁相同 读锁的lock():对应Sync的tryAcquireShared ： 12345678910111213141516171819202122232425262728293031323334353637383940414243protected final int tryAcquireShared(int unused) { //获取当前线程 Thread current = Thread.currentThread(); // 获取当前状态 int c = getState(); // 如果当前写锁被持有，且不是当前线程,返回-1，小于0表示获取失败 // 而如果写锁被持有，且是当前线程持有，说明正在进行锁降级 if (exclusiveCount(c) != 0 &amp;&amp; getExclusiveOwnerThread() != current) return -1; // 获取当前获取读锁的线程数量 int r = sharedCount(c); if (!readerShouldBlock() &amp;&amp; //具体根据公平或非公平原则判断是否需要阻塞当前线程 r &lt; MAX_COUNT &amp;&amp; //读锁线程小于最大值 compareAndSetState(c, c + SHARED_UNIT)) {//CAS更新成功 if (r == 0) { //持有读锁线程为0 // 将当前线程设为第一个持有读锁的线程，即将读锁状态从0变为1 firstReader = current; firstReaderHoldCount = 1; } else if (firstReader == current) {//当前线程是第一个线程，即该线程重入 //重入数自增 firstReaderHoldCount++; } else {//当前线程不是第一个线程 //先查取缓存，获取缓存计数 HoldCounter rh = cachedHoldCounter; //1.缓存为空 //2.缓存不为空，但对应的线程id非当前正在运行的线程id if (rh == null || rh.tid != getThreadId(current)) // 从threadLocal中获取计数 cachedHoldCounter = rh = readHolds.get(); //如果计数为0 else if (rh.count == 0) //则加入到readHolds中 readHolds.set(rh); //计数自增 rh.count++; } //获取成功，返回1 return 1; } return fullTryAcquireShared(current); } 如果当前线程需要阻塞，或读线程超过最大值，或CAS失败，进入fullTryAcquireShared方法，循环获取读锁 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556final int fullTryAcquireShared(Thread current) { HoldCounter rh = null; //死循环自旋 for (;;) { //获取当前状态 int c = getState(); if (exclusiveCount(c) != 0) {//有线程持有写锁 if (getExclusiveOwnerThread() != current) //且不是当前线程，则返回-1 return -1; } else if (readerShouldBlock()) {//如果需要阻塞 if (firstReader == current) {///当前线程为第一个获取读锁的 // assert firstReaderHoldCount &gt; 0; } else {//当前线程不是第一个获取读锁的 if (rh == null) { //计数为空，则将缓存赋值给它 rh = cachedHoldCounter; //缓存为空或运行线程tid不是当前运行的线程 if (rh == null || rh.tid != getThreadId(current)) { //从threadlocal中获取 rh = readHolds.get(); if (rh.count == 0) readHolds.remove(); } } if (rh.count == 0) return -1; } } // 读锁线程超过最大值，抛出异常 if (sharedCount(c) == MAX_COUNT) throw new Error(\"Maximum lock count exceeded\"); //CAS更新状态值 if (compareAndSetState(c, c + SHARED_UNIT)) { //下面逻辑跟上面基本相同，不赘述 if (sharedCount(c) == 0) { firstReader = current; firstReaderHoldCount = 1; } else if (firstReader == current) { firstReaderHoldCount++; } else { if (rh == null) rh = cachedHoldCounter; if (rh == null || rh.tid != getThreadId(current)) rh = readHolds.get(); else if (rh.count == 0) readHolds.set(rh); rh.count++; cachedHoldCounter = rh; // cache for release } return 1; } } } 读锁的unlock():涉及的类如下： 123456789101112131415161718192021222324252627282930313233343536373839protected final boolean tryReleaseShared(int unused) { Thread current = Thread.currentThread(); //如果第一个读锁的线程是当前线程 if (firstReader == current) { //如果只重入一次 if (firstReaderHoldCount == 1) //直接置空 firstReader = null; else //否则计数自减 firstReaderHoldCount--; } else {//当前线程非第一个读锁线程 //获取缓计数 HoldCounter rh = cachedHoldCounter; if (rh == null || rh.tid != getThreadId(current)) //缓存为空或非当前线程则从threadlocal获取 rh = readHolds.get(); //获取当前线程的获取读锁次数 int count = rh.count; if (count &lt;= 1) {//如果计数小于等于1 readHolds.remove();//彻底释放资源 if (count &lt;= 0)//小于等于-时抛出异常 throw unmatchedUnlockException(); } // 当前线程的读锁的可重入次数自减 --rh.count; } for (;;) { //获取当前状态 int c = getState(); //释放后的状态 int nextc = c - SHARED_UNIT; //cas更新状态 if (compareAndSetState(c, nextc)) //如果为0，表示彻底释放，返回ture，否则返回false return nextc == 0; } } 释放流程：1.如果当前线程是第一个获取读锁的线程，则判断其占有的资源是否为1，即是否只重入一次，如果是，则让第一个读锁的线程置空，否则让第一个读锁的线程的重入次数自减一2.如果当前线程非第一个读锁线程，则首先获取缓存计数，如果为空或非当前线程，则从threadLocal中获取当前线程的计数，如果计数小于等于1，则移除计数，如果≤0，则抛出异常；最后再让count自减一3.进入死循环CAS更新同步状态","link":"/posts/20200207-reentrant_read_write_lock.html"},{"title":"二叉查找树（BST）---java实现","text":"一、定义二叉查找树（BST）是一颗二叉树，其每个节点的值都比左孩子的任意节点大，比右孩子的任意节点小。 最坏情况下运行时间的增长数量级：查找： N插入： N平均情况下：查找命中：1.39lgN插入： 1.39lgN支持有序性相关操作 二、数据结构1234567891011121314151617181920212223242526public class BinarySearchTree&lt;T extends Comparable&lt;? super T&gt;&gt; { private TreeNode&lt;T&gt; root; public BinarySearchTree(TreeNode&lt;T&gt; root) { this.root = root; }}class TreeNode&lt;T&gt;{ T data; TreeNode lchild; TreeNode rchild; public TreeNode(T data) { this(data,null,null); } public TreeNode(T data, TreeNode lchild, TreeNode rchild) { this.data = data; this.lchild = lchild; this.rchild = rchild; }} 三、contains方法如果该树存在数据X则返回true，否则返回false。我们只需要从根节点开始遍历，如果当前节点小于X，则向左递归，否则向右递归，直到找到X或到达树的最后。 1234567891011121314151617public boolean contains(T x){ return contains(x,root); } private boolean contains(T x, TreeNode&lt;T&gt; root) { if (root==null){ return false; } int result=x.compareTo(root.data); if (result&lt;0){ return contains(x,root.lchild); }else if (result&gt;0){ return contains(x,root.rchild); }else { return true; } } 四、查找最小值和最大值一颗二叉查找树，其最小值一定是按左子树递归找到，直到树底1.如果根节点为空，则返回空2.如果左子树为空，则返回根节点3.否则从左孩子开始，继续从1递归。 123456789public TreeNode&lt;T&gt; findMax(TreeNode&lt;T&gt; root){ if (root==null){ return null; } while (root.rchild!=null){ root=root.rchild; } return root; } 查找最大值则相反，从根节点向右子树循环查找。 123456789public TreeNode&lt;T&gt; findMax(TreeNode&lt;T&gt; root){ if (root==null){ return null; } while (root.rchild!=null){ root=root.rchild; } return root; } 五、插入一个节点同样可以使用contains那种递归的方式。如果找到X，则节点已存在，什么都不做；否则就插入到遍历路径上的最后一个节点。 123456789101112131415161718192021public TreeNode&lt;T&gt; insert(T x){ if (x==null){ throw new IllegalArgumentException(\"参数为空\"); } return insert(x,root); } private TreeNode&lt;T&gt; insert(T x,TreeNode&lt;T&gt; t){ //当前节点为空，构建一个新的节点插入x if (t==null){ return new TreeNode&lt;&gt;(x); } int result=x.compareTo(t.data); if (result&lt;0){ //向左递归 t.lchild=insert(x,t.lchild); }else if (result&gt;0){ //向右递归 t.rchild=insert(x,t.rchild); } return t; } 六、删除一个节点删除节点X大致可分为三种情况： 如果X是叶子节点，则直接删除 如果X有一个孩子，则将那个孩子放在当前节点位置 如果X有两个孩子，则找到右孩子中最小的一个节点Y，放到待删除节点X的位置，这样X的左孩子们仍然比它小，现在只需要用同样的方式删除右孩子的Y即可。 123456789101112131415161718192021222324252627282930313233343536public void remove(T x){ if (x==null){ return; } remove(x,root); } /** * 删除一个节点 * 1.如果是叶子节点，则直接删除 * 2.如果有一个孩子，让当前节点等于那个孩子 * 3.如果有两个孩子，让当前节点的值等于右孩子中最小的一个节点的值，然后再同样的方法删除右孩子最小值的节点 * @param x * @param root * @return */ private TreeNode&lt;T&gt; remove(T x,TreeNode&lt;T&gt;root){ if (root==null){ return null; } int result=x.compareTo(root.data); if (result&lt;0){ root.lchild=remove(x,root.lchild); }else if (result&gt;0){ root.rchild=remove(x,root.rchild); }else if (root.lchild!=null&amp;&amp;root.rchild!=null){ //找到待删除节点，且有两个孩子 //让当前节点值等于右孩子最小的节点值 root.data= (T) findMin(root.rchild).data; //在右孩子中删除上一步找到的最小的值 root.rchild=remove(root.data,root.rchild); }else { root=root.lchild==null?root.rchild:null; } return root; } 求节点的高度就很简单了： 123456public int height(TreeNode&lt;T&gt; root){ if (root==null){ return -1; } return 1+Math.max(height(root.lchild),height(root.rchild)); } 总结：使用二叉查找树的运行时间取决于树的形态，而树的形态又取决于数据被插入的顺序。因此最好的情况下是一颗完全二叉树；但最坏情况下，搜索路径上有N个节点，即左右节点都在一条路径下排开。","link":"/posts/20200310-bst.html"},{"title":"AVL树的原理讲解-------java实现","text":"前面讲到了二叉查找树，虽然能够很好的应用于大多数的场景，但是他们在最坏情况下性能还是很差的，如二叉查找树最坏情况下是一颗高度为N的树，显然不利于查找。因此我们需要让查找树保持一种平衡，如二叉查找树最优情况的状态一样。 一、AVL树基础AVL树是一颗保持平衡的二叉查找树，保证了树的深度为O(logN)。其每个节点的左子树和右子树的高度都最多相差1上图就是一颗AVL树，其任意节点的左孩子和右孩子的高度差不超过1。 但是当我们插入或删除一个节点时，很容易破坏AVL树的平衡度，因此我们需要一种操作，在插入或删除完成前重新对树进行平衡，恢复AVL树的性质，这种操作就是旋转。 假设待平衡节点为 A，则不平衡的条件就是A 的两颗子树的高度差为2，因此就会出现四种情况，针对不同情况我们做不同的旋转操作： 1.在A的左孩子的左子树进行插入 （单旋转，向右旋转） 2.在A的左孩子的右子树进行插入 （双旋转，先左，再右） 3.在A的右孩子的左子树进行插入 （双旋转，先右再左） 4.在A的右孩子的右子树进行插入 （单旋转，向左旋转） 情况1：如下图左树，插入了一个节点G后，在A点处失去了平衡（这里树的节点无意义，随意取的，只关注平衡性即可），因此我们需要在A处将树向右旋转，变成右边的树，可以想象成用手提着B，将其提起来，然后将B的右孩子变为A的左孩子对应代码如下：右旋转就先获取其左孩子left1.node的左孩子变为left的右孩子2.left的右孩子变为node3.重新计算node和left的高度 12345678910111213/** * 单旋转(右旋转)(情形1) * @param node * @return */ private AVLNode&lt;T&gt;rotateRight(AVLNode&lt;T&gt; node){ AVLNode&lt;T&gt; left=node.left; node.left=left.right; left.right=node; node.height=Math.max(height(node.left),height(node.right))+1; left.height=Math.max(height(node.left),node.height)+1; return left; } 情况4：如下图1，在A的右孩子的右子树插入了节点G，此时在A节点失去了平衡，因此在A处向左旋转，原理同情况1。实现如下：左旋转就先获取其右孩子right1.node的右孩子变为right的左孩子2.right的左孩子变为node3.重新计算node和right的高度 12345678910111213/** * 单旋转(左旋转)(情形4) * @param node * @return */ private AVLNode&lt;T&gt; rotateLeft(AVLNode&lt;T&gt; node){ AVLNode&lt;T&gt; right=node.right; node.right=right.left; right.left=node; node.height=Math.max(height(node.left),height(node.right))+1; right.height=Math.max(node.height,height(right.right))+1; return right; } 情况2：如下图1，在A的左孩子B的右子树插入了节点D后，在A处失去了平衡，因此需要先对其左孩子B进行左旋转，变成了图2，不难发现图2的情况就是情况1，因此我们只要再对A进行右旋转就可以恢复树的平衡性。之所以会变成情况1，是因为对B进行左旋转后，按照左旋转的特点，会将B的右子树G提升一个高度到B的位置，B自然就会下去一个高度，再加上一个新的G，自然也就变成了情况1。如下图3，对A进行右旋转后，树已恢复平衡。实现如下：有了情况1和情况4的基础，再实现情况2就很简单：1.先对A的左孩子左旋转2.再对A进行右旋转 123456789/** * 双旋转(先左后右)(针对情形2) * @param node * @return */ private AVLNode&lt;T&gt; doubleLeftAndRight(AVLNode&lt;T&gt; node){ node.left=rotateLeft(node.left); return rotateRight(node); } 情况3：如图1，在A的右孩子的左子树加了一个节点D，造成A处失去平衡，因此先对E进行右旋转变成图2，此时变成情况4，再对A进行左旋转变成图3，就恢复了平衡。实现如下： 123456789/** * 双旋转(先右再左) (针对情形3) * @param node * @return */ private AVLNode&lt;T&gt; doubleRightAndLeft(AVLNode&lt;T&gt; node){ node.right=rotateRight(node.right); return rotateLeft(node); } 有了上面的基础，再对AVL树操作就不困难了。 二、数据结构也是一个左孩子，一个右孩子，一个数据域，外加一个当前节点的高度，当然你也可以使用Key-Value结构，按Key进行构造树，一个key关联一个value，这里简单使用了一个泛型T 1234567891011121314151617181920212223242526272829public class AVLTree&lt;T extends Comparable&lt;? super T&gt;&gt; { private AVLNode&lt;T&gt; root; //节点的左右孩子高度差不能超过该值 private static final int HEIGHT_DIFFERENCE=1; public AVLTree(AVLNode&lt;T&gt; root) { this.root = root; }} class AVLNode&lt;T&gt;{ AVLNode(T t){ this(t,null,null); } AVLNode(T data,AVLNode&lt;T&gt; lt,AVLNode&lt;T&gt; rt){ this.data=data; left=lt; right=rt; this.height=0; } T data; AVLNode&lt;T&gt; left; AVLNode&lt;T&gt; right; int height;} AVL树返回最大值最小值以及contains方法同上一篇二叉查找树相同，不赘述。 三、插入一个元素123456789101112131415161718192021public void insert(T data){ if (data==null){ throw new IllegalArgumentException(\"数据为空\"); } root= insert(data, this.root); } private AVLNode&lt;T&gt; insert(T data,AVLNode&lt;T&gt; t){ if (t==null){ return new AVLNode&lt;&gt;(data,null,null); } int compareResult=data.compareTo(t.data); if (compareResult&lt;0){ t.left=insert(data,t.left); }else if (compareResult&gt;0){ t.right=insert(data,t.right); }else { ; } return balance(t); } 可以看出，除了最后一行，其余部分同二叉查找树相同。每次insert()调用后，都要对当前节点进行重新平衡，即当找到插入的节点后，按递归调用栈的顺序，对路径上的每个节点进行重新平衡。balance()节点平衡代码如下： 12345678910111213141516171819202122232425262728293031323334353637383940/** * 对节点t进行平衡 * @param t * @return */ private AVLNode&lt;T&gt; balance(AVLNode&lt;T&gt; t) { if (t==null){ return null; } if (height(t.left)-height(t.right)&gt;HEIGHT_DIFFERENCE){ //左边高 if (height(t.left.left)&gt;=height(t.left.right)){ //左子树的左子树高 //此为情形1，在左子树的左子树插入了元素，直接右旋转 t=rotateRight(t); }else { //左子树的右子树高 //此为情形2，在左子树的右子树插入了元素，先左旋转再右旋转 t=doubleLeftAndRight(t); } }else if (height(t.right)-height(t.left)&gt;HEIGHT_DIFFERENCE){ //右边高 if (height(t.right.left)&gt;height(t.right.right)){ //右子树的左子树高了 //此为情形3，在右子树的左子树插入了元素，先右旋转再左旋转 t=doubleRightAndLeft(t); }else { //右子树的右子树高 //此为情形4，在右子树的右子树插入了元素，直接左旋转 t=rotateLeft(t); } } //重新计算该节点的高度 t.height=Math.max(height(t.left),height(t.right))+1; return t; } private int height(AVLNode&lt;T&gt; t){ return t==null?-1:t.height; } 四、删除一个元素逻辑同二叉查找树，同插入一样，需要在每次remove调用后对当前节点进行平衡。 1234567891011121314151617181920212223242526272829/** * 删除数据 * @param x */ public void remove( T x ) { root = remove( x, root ); } private AVLNode&lt;T&gt; remove(T data,AVLNode&lt;T&gt; root){ if (root==null){ return null; } int compareResult=data.compareTo(root.data); if (compareResult&lt;0){ root.left=remove(data,root.left); }else if (compareResult&gt;0){ root.right=remove(data,root.right); }else if (root.left!=null&amp;&amp;root.right!=null){ //待删除节点有两个孩子 root.data=findMin(root).data; root.right=remove(root.data,root.right); }else { //待删除节点没有孩子或有一个孩子 root=root.left==null?root.right:root.left; } //重新平衡树 return balance(root); } 我们可以按照中序遍历返回AVL树的节点队列： 12345678910111213141516171819202122/** * 返回数据队列 * @return */ public Queue&lt;T&gt;iterator(){ if (isEmpty()){ return null; }else { Queue&lt;T&gt;queue=new Queue&lt;&gt;(); return iterator(root,queue); } } private Queue&lt;T&gt; iterator( AVLNode&lt;T&gt; t,Queue&lt;T&gt; queue ) { if( t != null ) { iterator( t.left,queue ); queue.enqueue(t.data); iterator( t.right, queue); } return queue; } 测试： 12345678910111213141516171819202122232425public static void main(String[] args) { AVLTree&lt;Integer&gt; avlTree = new AVLTree&lt;&gt;(new AVLNode&lt;&gt;(1)); avlTree.insert(2); avlTree.insert(3); avlTree.insert(4); avlTree.insert(5); avlTree.insert(6); avlTree.insert(7); avlTree.insert(15); avlTree.insert(16); avlTree.insert(14); //中序遍历打印 avlTree.printTree(); System.out.println(\"==========删除节点15=========\"); avlTree.remove(15); Queue&lt;Integer&gt; queue = avlTree.iterator(); while (!queue.isEmpty()){ System.out.println(queue.dequeue()); } Integer max = avlTree.findMax(); System.out.println(\"最大元素:\"+max); System.out.println(\"节点17是否存在\"+avlTree.contains(17)); } 结果： 123456789101112131415161718192021221234567141516==========删除节点15=========12345671416最大元素:16节点17是否存在false 总结：AVL树总体上的实现和二叉查找树相同，只是为了重新让树恢复平衡需要在递归调用中对当前节点进行balance()。AVL树的查找、插入或删除，最坏的情况下的复杂度均为O(log(n))，但如果数据量很大时，AVL树的综合性能略逊于另一种平衡树—-红黑树，我们会在一篇讲到。","link":"/posts/20200310-avltree.html"},{"title":"《算法4》归并排序---------java实现","text":"归并排序采用分治策略实现 平均时间复杂度 : O（nlogn） 最差时间复杂度: O(nlogn) 稳定性： 稳定 空间复杂度：O(n) 归并排序时以空间换时间的排序方法，空间消耗很大，一般内部排序使用快速排序较多 假设有这样一组数据：[10,4,8,7,1,3,2,9] 我们先介绍自顶向下的归并排序 一、分) 如上将8个数组分成8个单独的数据 二、合1.将 10和 4合并 ) 2.将8和7合并 ) 3. 将4,10和7,8合并 )、 4.同样将右半部分也按此合并得到如下两组数据 ) 5.最后将两组数据合并在一起 ) 三、代码实现123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596package com.wml.sort;import java.util.Arrays;/** * @author * @date 2019/10/2919:17 */public class MergeSort { private static int CUTOFF = 15; public static &lt;T extends Comparable&lt;? super T&gt;&gt; void mergeSort(T[] arr) { T[] temp = (T[]) new Comparable[arr.length]; mergeSort(arr, temp, 0, arr.length - 1); } /** * 自顶向下归并排序 长度为N的数组，需要1/2NlogN到NlgN次比较 * @param arr * @param temp * @param left * @param right * @param &lt;T&gt; */ private static &lt;T extends Comparable&lt;? super T&gt;&gt; void mergeSort(T[] arr, T[] temp, int left, int right) { if (left &lt; right) { //System.out.println(\"sort(arr,\" + left + \",\" + right + \")\"); int mid = (left + right) / 2; mergeSort(arr, temp, left, mid); mergeSort(arr, temp, mid + 1, right); merge(arr, temp, left, mid + 1, right); } } /** * 合并两组数据 * @param arr 原始数组 * @param temp 临时数组 * @param leftStart 左半部分开始位置 * @param rightStart 右半部分开始位置 * @param rightEnd 右半部分结束位置 * @param &lt;T&gt; */ private static &lt;T extends Comparable&lt;? super T&gt;&gt; void merge(T[] arr, T[] temp, int leftStart, int rightStart, int rightEnd) { // System.out.println(\"merge(arr,temp,\" + leftStart + \",\" + rightStart + \",\" + rightEnd + \")\"); //计算左半部分边界 int leftEnd = rightStart - 1; //临时数组当前位置的指针 int tempCurrent = leftStart; //计算待合并数组的总长度 int length = rightEnd - leftStart + 1; //当任意一边数据拷贝完毕结束循环 while (leftStart &lt;= leftEnd &amp;&amp; rightStart &lt;= rightEnd) { if (arr[leftStart].compareTo(arr[rightStart]) &lt;= 0) { temp[tempCurrent++] = arr[leftStart++]; } else { temp[tempCurrent++] = arr[rightStart++]; } } //如果是左边的未拷贝完毕，则继续将左边剩下的拷贝到临时数组 while (leftStart &lt;= leftEnd) { temp[tempCurrent++] = arr[leftStart++]; } //如果是右边的未拷贝完毕，则继续将右边剩下的拷贝到临时数组 while (rightStart &lt;= rightEnd) { temp[tempCurrent++] = arr[rightStart++]; } for (int i = 0; i &lt; length; i++, rightEnd--) { arr[rightEnd] = temp[rightEnd]; } }public static void main(String[] args) { /* Integer[]arr=new Integer[8000000]; Random random=new Random(); for (int i = 0; i &lt; 8000000; i++) { arr[i]= random.nextInt(8000000); } long begin=System.currentTimeMillis(); System.out.println(begin); mergeSort(arr); long end=System.currentTimeMillis(); System.out.println(end); System.out.println(end-begin);*/ Integer[]arr={4,12,4,25,12,524,12,12,25,346,21,346,47,587,96,4534,21,56,8,78,9,2,12}; mergeSort(arr); for (Integer o:arr){ System.out.println(o); } } } 结果： 以下执行地动态情况可以看出归并排序的递归过程，加深理解： 123456789101112131415161718192021222324489121212121221212525475678963463465245874534 算法第四版给出如下结论： 对于长度为N的任意数组，自顶向下的归并排序需要1/2NlgN到NlogN次比较。 且最多需要访问组数6NlgN次 此时我们可以对该算法进行一定的优化，我们知道在规模较小的数组排序时，使用插入排序更快速些，因为我们可以在数组规模小于15时让其执行插入排序。另外对于两个待合并数组，如果a[mid]&lt;=a[mid+1]，即左边一组的最后一个元素小于等于右边一组的第一个元素。我们可以不对其进行merge，因为这两组数据已经是有序的了。 修改后的mergeSort如下： 123456789101112131415161718private static &lt;T extends Comparable&lt;? super T&gt;&gt; void mergeSort(T[] arr, T[] temp, int left, int right) { if (left &lt; right) { //小于CUTOFF=15时，进行 插入排序 if (right-left&lt;CUTOFF){ InsertSort.insertSort(arr,left,right); } System.out.println(\"sort(arr,\" + left + \",\" + right + \")\"); int mid = (left + right) / 2; mergeSort(arr, temp, left, mid); mergeSort(arr, temp, mid + 1, right); //如果左半边最后一个元素大于右半边第一个元素时才进行合并 if (arr[mid].compareTo(arr[mid + 1]) &gt; 0) { merge(arr, temp, left, mid + 1, right); } } } 三、自底向上的归并排序自底向上的归并排序思想是： 先归并微型数组，再成对归并得到的子数组，直到将整个数组归并在一起。 流程就是： 1.将每个元素当做大小为1的数组，两两归并 2.然后再四个四个归并 3.再八个八个归并 4.直到归并完毕 1234567891011121314151617181920212223242526272829303132/** * 自底向上 * @param arr 原始数组 * @param temp 临时数组 * @param &lt;T&gt; */ private static &lt;T extends Comparable&lt;? super T&gt;&gt; void mergeSort(T[] arr, T[] temp) { int N = arr.length; //一开始两两比较，gap为1，之后每次都扩大一倍 for (int gap = 1; gap &lt; N; gap *= 2) { //数组大小小于CUTOFF时，进行插入排序 if (gap &lt; CUTOFF) { for (int left = 0; left &lt; N - gap; left += gap + gap) { int right = Math.min(left + gap + gap - 1, N - 1); InsertSort.insertSort(arr, left, right); } } else { //对0到N-gap进行排序，gap为1，就是两两排序，gap为2，就是四四排序 for (int left = 0; left &lt; N - gap; left += gap*2) { //计算当前待合并数组的右边界位置，如果原始数组最后一组数据不够2*gap，则left+gap*2就会越界，其真实的边界应当是N-1 int right = Math.min(left + gap*2 - 1, N - 1); //同自顶向下，若待合并的数据已经是有序的，则不进行合并 if (arr[left + gap - 1].compareTo(arr[left + gap]) &gt; 0) { merge(arr, temp, left, left + gap, right); } } } } } 暂时去掉优化的部分，同样对该算法的调用进行打印输出（仍用自顶向下归并的数据）： gap=1时，两两排序 *merge(arr,temp,0,1,1) * ​ *merge(arr,temp,2,3,3) * ​ *merge(arr,temp,4,5,5) * ​ *merge(arr,temp,6,7,7) * ​ *merge(arr,temp,8,9,9) * ​ merge(arr,temp,10,11,11) ​ *merge(arr,temp,12,13,13) * ​ *merge(arr,temp,14,15,15) * ​ *merge(arr,temp,16,17,17) * ​ *merge(arr,temp,18,19,19) * ​ merge(arr,temp,20,21,21) gap=2时，四个四个排序*merge(arr,temp,0,2,3) * ​ *merge(arr,temp,4,6,7) * ​ *merge(arr,temp,8,10,11) * ​ merge(arr,temp,12,14,15) ​ merge(arr,temp,16,18,19) ​ merge(arr,temp,20,22,22) gap=4时，八个八个排序*merge(arr,temp,0,4,7) * ​ merge(arr,temp,8,12,15) ​ *//此时右半边只有7个数据，因此right=N-1=23-1=22 * ​ merge(arr,temp,16,20,22) gap=8时，16个一组排序merge(arr,temp,0,8,15) gap=16时，此时左半边为0-15，右半边为16-22，合并之merge(arr,temp,0,16,22)24489121212121221212525475678963463465245874534 对于长度为N的任意数组，自底向上的归并排序一样需要1/2NlgN到NlogN次比较。 且最多需要访问组数6NlgN次 当数组长度为2的幂时，两种归并方式所用的比较次数和数组访问次数正好相同，只是顺序不同。 而自底向上的归并更适合比较链表结构的数据。只需要重新组织链表的链接就可以原地排序，而不需要创建任何新的节点。","link":"/posts/20200107-mergeSort.html"},{"title":"《算法4》散列表实现笔记","text":"一、散列函数散列函数会将键转为数组的索引。我们的散列函数应该计算速度快且能够均匀分布所有的键，如对于大小为M的散列表，我们的散列函数应当能够让任意的key都能够转化为 0-到M-1 的整数，对于不同的键应该有不同的散列函数。Java中许多常用的类都重写了hashCode方法，以针对不同的数据类型使用不同的散列函数。 二、基于拉链法的散列表散列算法理想的状态是将不同的key都转为不同的索引值，但这显然是不可能的，一定会产生冲突，因此我们就需要对冲突进行处理。一种直接的方法是将大小为M的数组中的每个索引指向一条链表，链表中的每个节点都存储了散列值为该链表所在索引值的键值对，这种方法就是拉链法。 如下是基本数据结构： 123456789101112131415161718192021222324public class SeparateChainingHashST&lt;Key,Value&gt; { /** * 键值对总数 */ private int N; /** * 散列表大小 */ private int M; private SequentialSearchST&lt;Key,Value&gt;[] st; public SeparateChainingHashST() { this(997); } public SeparateChainingHashST(int M) { this.M=M; st=new SequentialSearchST[M]; for (int i = 0; i &lt; M; i++) { //数组中每个索引值都初始化一个链表 st[i]=new SequentialSearchST&lt;&gt;(); } }} SequentialSearchST是前面顺序查找中实现的无序链表： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394959697ublic class SequentialSearchST&lt;Key, Value&gt; { /** * 首节点 */ private Node first; private int size; private class Node { private Key key; private Value value; private Node next; public Node(Key key, Value value, Node next) { this.key = key; this.value = value; this.next = next; } } /** * 根据key查询对应的值，一个个往下遍历直到找到相等的key，返回对应的值，否则返回null * @param key * @return */ public Value get(Key key) { for (Node x = first; x != null; x = x.next) { if (key.equals(x.key)) { return x.value; } } return null; } /** * 加入一个元素 * @param key * @param value */ public void put(Key key, Value value) { for (Node x = first; x != null; x = x.next) { //key已存在，更新对应的值 if (key.equals(x.key)) { x.value = value; return; } } //key不存在，新添加一个节点 first = new Node(key, value, first); size++; } public boolean isEmpty() { return size == 0; } private int size() { return size; } public boolean contains(Key key) { if (key == null) throw new IllegalArgumentException(\"argument to contains() is null\"); return get(key) != null; } /** * 删除key对应的节点 * @param key */ public void delete(Key key) { if (key == null) throw new IllegalArgumentException(\"argument to delete() is null\"); first = delete(first, key); } /** * 递归查找，直到找到相等的key，正常删除链表节点 * @param x * @param key * @return */ private Node delete(Node x, Key key) { if (x == null) return null; if (key.equals(x.key)) { size--; return x.next; } x.next = delete(x.next, key); return x; } public Iterable&lt;Key&gt; keys() { Queue&lt;Key&gt; queue=new Queue&lt;&gt;(); while (first!=null){ queue.enqueue(first.key); first=first.next; } return queue; }} hash计算：上面说了，java中为所有数据类型都重写了hashCode()方法，该方法返回一个32位比特的整数，但我们需要的是数组的索引，因此我们需要将默认的hashCode方法和除留余数法结合起来产生一个0到M-1的整数，又因为hashCode返回的值是带有符号位的，这样就算导致计算结果出现负数，因此我们需要通过0x7fffffff变为一个31位的非负整数，再使用除留余数法让其%M，M为一个较大的质数。 123private int hash(Key key){ return (key.hashCode() &amp; 0x7fffffff) % M; } 这样我们就可以对数据进行插入、删除和获取了：插入实现：如下，先计算key的哈希值，得到一个数组的索引，然后将该键值对插入到该索引对应的链表中。 12345678910111213public void put(Key key,Value value){ if (key==null){ throw new NoSuchElementException(\"key为空\"); } if (value==null){ delete(key); } //保证链表的长度在2到8之间 if (N&gt;=8*M){ resize(M*2); } st[hash(key)].put(key,value); } 删除实现：先计算key的哈希值，找到其所在的链表，如果该链表中有该key，其删除之。 12345678910111213141516171819202122/** * 删除指定键值对 * @param key */ public void delete(Key key) { if (key == null) throw new IllegalArgumentException(\"argument to delete() is null\"); int i = hash(key); if (st[i].contains(key)){ N--; } st[i].delete(key); //保证链表平均长度在2到8间 此为下界2 if (N&gt;0 &amp;&amp; N&lt;=M*2){ resize(M/2); } }public boolean contains(Key key) { if (key == null) throw new IllegalArgumentException(\"key为空\"); return get(key) != null; } 获取值：计算key的哈希值， 返回对应链表中的value 12345public Value get(Key key){ if (key == null) return null; return st[hash(key)].get(key); } 我们使用M条链表存储N个键，无论键在表中如何分布，其平均长度一定是 N/M。使用拉链法的一个好处是，如果存入的键多与预期，查找的时间只会比选择更大的数组长；如果低于预期，虽然会造成一点空间浪费，但查找很快。因此内存足够时，可选择足够大的M，让查找使用变为常数；当内存紧张时，选择尽量大的M仍能够将性能提高M倍。 动态调整数组：在删除后，如果平均长度N/M低于2，则让数组缩小 一倍：M/2;在加入一个数据后，如果 N/M 高于8，则让数组增加一倍： M*2 12345678910111213private void resize(int capacity){ SeparateChainingHashST&lt;Key,Value&gt;hashST=new SeparateChainingHashST&lt;&gt;(capacity); for (int i = 0; i &lt; M; i++) { for (Key key:st[i].keys()){ if (key!=null){ hashST.put(key,st[i].get(key)); } } } this.M=hashST.M; this.N=hashST.N; this.st=hashST.st; } 三、基于线性探测法的散列表实现散列表的另一种方式是用大小为M的数组保存N个键值对（M&gt;N），借助空位解决碰撞冲突，基于这种策略的所有方法都成为开放地址散列表。开放地址散列表最简单的方法是线性探测法，即如果产生冲突（一个键的散列值已经被另一个不同的键占用），则直接检查散列表的下一个位置（索引+1），如果还是冲突，则一直向后探测，直到找到一个空位置，将该键值对插入进去。数据结构如下：这里使用一个Key[]保存键，一个Values[]保存key对应的值 12345678910111213141516171819public class LinearProbingHashST&lt;Key, Value&gt; { private Key[] keys; private Value[] values; /** * 键值对数 */ private int N; /** * 线性表大小 */ private int M; public LinearProbingHashST(int M) { this.M = M; keys = (Key[]) new Object[this.M]; values = (Value[]) new Object[this.M]; }} 插入操作：我们需要计算待插入的键的hash值，然后判断当前索引是否被其他键占用，如果被占用的键也是待插入的键，则修改对应的值，否则一直遍历下去直到找到一个空位置。 12345678910111213141516171819202122232425public void put(Key key, Value value) { if (key == null) throw new IllegalArgumentException(\"first argument to put() is null\"); if (value==null){ delete(key); } //保证使用率 N/M 小于等于 1/2 ，当使用率趋近于1时，探测的次数会变得很大 if (N&gt;=M*2){ resize(M*2); } int i; for (i = hash(key); keys[i] != null; i = (i + 1) % M) { if (keys[i].equals(key)) { //待插入的key存在，修改对应的值并返回 values[i] = value; return; } } //找到空位置，插入键值对 keys[i] = key; values[i] = value; N++;} private int hash(Key key) { return (key.hashCode() &amp; 0x7fffffff) % M;} 查询操作：计算key的哈希值，如果当前位置冲突（被其他key占用），则继续向后遍历，遍历的结束条件是从hash(key)到下一个null位置前，如果存在，则返回对应的value，如果不存在则返回null 12345678public Value get(Key key) { for (int i = hash(key); keys[i] != null; i = (i + 1) % M) { if (keys[i].equals(key)) { return values[i]; } } return null; } 对于如下一个散列表： 1230 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15P M A C S H L E R X10 9 8 4 0 5 11 12 3 7 A的散列值是4，H的散列值也是4，但因为在4冲突，所以插入H的时候被线性移动到了7位置，因此我们在查找H对应的值的时候，先从索引4开始，不匹配，顺次向下查找，如果在空位置9之前还没找到，说明不存在H，但因为H在9之前的7位置，索引返回对应的值5.删除操作：对于删除操作，我们不可以直接将对应的key置为null。同样是上面的散列表，假如删除C，而H的散列值为4，在线性探测的过程中，会因为索引5为空，而“错误”的认为散列表中不存在H而返回null，但事实是H存在，并且在索引7中。 因此在删除给定key后，需要将key+1到下一个空位置前的所有键重新插入散列表，以避免上述错误的发生。 1234567891011121314151617181920212223242526272829public void delete(Key key) { if (!contains(key)) { return; } int i=hash(key); //线性探测找到待删除的key的索引 while (!keys[i].equals(key)){ i=(i+1)%M; } //置空 keys[i]=null; values[i]=null; //将i+1的位置到下一个空位置前的所有key重新插入到散列表中 i=(i+1)%M; while (keys[i]!=null){ Key oldKey=keys[i]; Value oldValue=values[i]; keys[i]=null; values[i]=null; N--; put(oldKey,oldValue); i=(i+1)%M; } N--; if (N&gt;0 &amp;&amp; N &lt;= M/8){ resize(M/2); } } 另α= N/M ，我们称α为散列表的使用率在《算法4》中给出了如下结论： 在一张大小为M并含有N个键的基于线性探测的散列表中，如果我们的散列函数能够均匀并独立地将所有的键分布在0到M-1之间，则命中和未命中的查找所需的探测次数分别为： 1 / 2(1 + 1 / 1−α) and 1/2 ( 1 + 1 / (1−α) ^ 2) 即当散列表快满的时候，查找所需的探测次数是巨大的（α趋近于1），但当使用率α &lt; 1/2时，探测的预计次数只在1.5到2.5之间，因此我们要保证 α的值不大于 1/2。基于此我们要在插入前和删除后对数组进行动态调整： 插入前判断： 1234//保证使用率 N/M 不能超过1/2 ，当使用率趋近于1时，探测的次数会变得很大if (N&gt;=M*2){ resize(M*2);} 删除后判断：保证使用的内存量和表中的键值对数量的比例总在一定范围内。 1234 //数组减小一半，如果N/M 为12.5% 或更少if (N&gt;0 &amp;&amp; N &lt;= M/8){ resize(M/2); }","link":"/posts/20200310-seq-linear-hash.html"},{"title":"《算法4》索引优先队列笔记-----java实现","text":"一、前言前面已经讲了优先队列（堆）的实现，https://wbml.top/posts/20200310-HeapPQ.html，但是其很明显有一个缺点，那就是无法直接访问已经在队列中的元素，更新或是删除它们，在Dijistra算法中就非常需要此性质，因此要解决此问题就需用到索引优先队列 二、索引优先队列数据结构讲解索引优先队列使用一个int[] pq数组作为索引队列， 保存对象在数组中的位置，使用T[] keys数组保存对象关联的值，使用int[] qp表示对象在索引队列pq中的位置。 如有这样一组数据： 123456780 -&gt; f1 -&gt; a3 -&gt; c5 -&gt; r7 -&gt; g10-&gt; i我们将0,1,3,5,7,10称为数据对象的索引 对应的pq、qp以及keys数组就是： 1234 0 1 2 3 4 5 6 7 8 9 10pq: 1 3 0 7 10 5qp: 2 0 1 5 3 4keys: f a c r g i 可以看到keys[i] ： i就是数据对象索引，keys[i] 就是与之关联的值 keys[0]=f,keys[1]=aqp[i] : 对象索引在索引队列中的位置，qp[0]=2 ,对象索引 0 在队列中的位置为2pq[i] : 即按照对应索引关联的值进行排序，如a是所有元素中最小的，因此其索引1在pq中的位置就是0，排在第一位 画出对应的二叉树会更容易理解：节点外边的就是pq的下标j，节点中的数字就是对象索引即pq[j]的值，节点中的字符就是 索引关联的对象，保存在keys中 因此对于 1-&gt;a 这样一个数据，用 i 表示其索引1则有以下关系： 令x=qp[i]则pq[x]=ikeys[pq[x]]=akeys[i] = apq[qp[i]] = i 数据结构如下： 123456789101112131415161718192021222324252627282930313233343536373839public class IndexMinPQ&lt;Key extends Comparable&lt;? super Key&gt;&gt; implements Iterable&lt;Integer&gt; { /** * 索引优先队列,保存对象在数组中的位置，按索引值(即keys[i],i为索引)进行小堆排序 */ private int[] pq; /** * pq的逆序,保存对象索引在pq中的位置 */ private int[] qp; /** * 队列最大元素数 */ private int maxSize; /** * 当前队列元素数量 */ private int currentSize; /** * 具体元素 */ private Key[] keys; public IndexMinPQ(int maxSize) { if (maxSize&lt;0){ throw new IllegalArgumentException(\"参数非法\"); } this.maxSize = maxSize; pq=new int[maxSize + 1 ]; qp=new int[maxSize + 1]; keys= (Key[]) new Comparable[maxSize+1]; currentSize=0; for (int i = 0; i &lt; maxSize + 1; i++) { //qp 初始化为-1 ，表示没有索引关联的对象 qp[i] = -1; } }} 这样就可以得到几个常用的方法： keyOf(int i) 返回索引 i 关联的需 12345public Key keyOf(int i){ checkIndex(i); if (!contains(i))throw new NoSuchElementException(\"不存在该索引\"); return keys[i]; } minIndex() 返回最小的索引 12345678910/** * 返回最小的索引，即索引队列pq[1]对应的索引对象 * @return */ public int minIndex(){ if (isEmpty()){ throw new NoSuchElementException(\"队列为空\"); } return pq[1]; } contains(int index) ：索引index是否包含在队列中，即index是否关联了对象 12345678910public boolean contains(int index){ checkIndex(index); //如果存在，则qp[index]一定不为-1，且指向 该对象index在 索引队列pq中的位置 return qp[index] != -1; } private void checkIndex(int index){ if (index&lt;0 || index&gt;= maxSize){ throw new IndexOutOfBoundsException(\"参数越界\"); } } 三、插入操作同优先队列思想类似。若插入一对数据为： index -&gt; key这里首先将对象索引index保存在优先队列pq的最后一个元素（先让currentSize+1），因此 qp[index] = currentSize，pq[currentSize]=index，keys[index]=key`，接着从优先队列pq的最后一个节点，即刚刚加入的节点开始执行上滤操作（同堆排序中的上滤基本相同），但这里需要注意的是，在上滤的过程中，比较的是 keys[pq[i]]，即比较的是索引index关联的值key，发生交换时不光要交换pq的值，还要更新qp的值。实现如下：插入： 1234567891011121314151617181920/** * 插入一对值 * @param index 索引 * @param key 索引关联的值 */ public void insert(int index,Key key){ checkIndex(index); if (contains(index)){ throw new IllegalArgumentException(\"索引\"+index+\"已存在\"); } //增加元素数 currentSize++; //当前对象的索引为队列尾部 qp[index]=currentSize; //该索引指向的对象在key中的位置为index pq[currentSize]=index; keys[index] = key; //对尾部元素上滤 percolateUp(currentSize); } 上滤操作： 12345678910/** * 上滤 * @param n */ private void percolateUp(int n) { //将n和n/2（n的父亲）比较，如果父亲大，则交换两个节点 for (; n&gt;1&amp;&amp;compareTo(n,n/2)&lt;0 ; n/=2) { swap(n,n/2); } } compareTo 比较关联的值： 123456789/** * 比较索引队列i和j上的对应的key值大小 * @param i * @param j * @return */ private int compareTo(int i,int j){ return keys[pq[i]].compareTo(keys[pq[j]]); } 交换pq[i]和pq[j]的元素： 1234567891011121314/** * 交换pq[i]和pq[j]的元素 * 并更新qp,qp[pq[i]]=i; * @param i * @param j */ private void swap(int i, int j) { int temp= pq[i]; pq[i] = pq[j]; pq[j] = temp; qp[pq[i]] = i; qp[pq[j]] = j; } 四、删除最小键删除最小键（即keys[pq[1]]）比较简单： 获取最小键索引minIndex，并将索引队列pq的第一个元素和最后一个元素交换，并让currentSize减一 同优先队列一样，从队列第一个元素开始下滤，将第一个元素放在满足堆序的位置 此时只需让qp[minIndex]=-1，keys[minIndex]=null 即可 实现： 12345678910111213141516171819/** * 删除最小键并返回其关联的索引。 * @return 关联的索引 即pq[1] */ public int delMin(){ if (currentSize == 0) { return -1; } int minIndex=pq[1]; swap(1,currentSize--); percolateDown(1); //删除当前对象，即pq中不存在该对象了 qp[minIndex] = -1; pq[currentSize+1]=-1;//不是必须的 keys[minIndex]=null; return minIndex; } 下滤：逻辑同优先队列（堆） 12345678910111213141516171819/** * 下滤 * @param k */ private void percolateDown(int k) { int child; for (; k*2 &lt;= currentSize ; k =child) { child= 2 * k; if (child &lt; currentSize &amp;&amp;compareTo(child+1,child)&lt;0){ child++; } if (compareTo(child,k)&lt;0){ swap(child,k); }else { break; } } } 五、删除指定索引关联的key删除指定索引的关联的key同删除最小值基本一样，只是交换时是交换pq[qp[i]]与pq[currentSize]的元素，i为待删除对象索引。且交换完后不能只进行下滤，因为我们不确定待删除的是pq[1]所关联的对象，因此需要进行上滤和下滤两次操作。 123456789101112131415161718/** * 删除与索引i关联的key * @param i */ public void delete(int i){ checkIndex(i); if (!contains(i)){ throw new IllegalArgumentException(\"索引不存在\"); } int index=qp[i]; swap(index,currentSize--); //上滤 percolateUp(index); //再下滤 顺序随意 percolateDown(index); keys[index]=null; qp[i] = -1; } 五、修改索引i关联的key值因为只是修改了i关联的值，所以只要修改keys[i]=newKey，而 qp[i] 和 pq[qp[i]] 指的值并没有改变。但因为pq[qp[i]] 关联的对象改变了，因此需要对qp[i] 进行上滤和下滤，重新调整索引优先队列。 12345678910111213/** * 修改索引i关联的key值 * @param i * @param key */ public void changeKey(int i,Key key){ checkIndex(i); if (!contains(i))throw new NoSuchElementException(\"不存在该索引\"); keys[i]=key; percolateUp(qp[i]); percolateDown(qp[i]); } 六、增大或减小索引i关联的key值以减小为例，首先要判断新的key是否小于原key值，如果小于，则重新指定keys[i]的值，并进行上滤，因为key比原来的key小，其子节点必然比它小，但是父节点可能会比新的key大，因此只需上滤。增大与之相反。 123456789101112131415161718192021222324252627282930/** * 将与索引 i 关联的键减小为指定值。 * @param i * @param key */ public void decreaseKey(int i,Key key){ checkIndex(i); if (!contains(i))throw new NoSuchElementException(\"不存在该索引\"); if(keys[i].compareTo(key)&lt;0){ throw new IllegalArgumentException(\"当前key无法缩小原key值\"); } keys[i]=key; //当前key变小，因此上滤即可 percolateUp(qp[i]); } /** * 将与索引 i 关联的键增加为指定值。 * @param i * @param key */ public void increaseKey(int i, Key key) { checkIndex(i); if (!contains(i))throw new NoSuchElementException(\"不存在该索引\"); if (keys[i].compareTo(key) &gt;= 0) throw new IllegalArgumentException(\"当前key无法增加原key值\"); keys[i] = key; //当前key变大，因此下滤即可 percolateDown(qp[i]); } 参考：《算法第四版》2.4节","link":"/posts/20200310-indexPQ.html"},{"title":"《算法4》union-find并查集解析","text":"union-find主要用于解决动态连通性的问题，如下图：对于输入的一系列整数对p,q，表示p和q是相连的，在将整数对输入完毕后，我们就可以从该图中获取该图的连通性，如任意两个节点是否相连，共有几个连通分量。如上图可看出共有两个连通分量：0-5-6-1-2-7，8-3-4-9 union-find算法API如下： 12345678910//初始化count个顶点 public UF(int count) //p和q两个点是否连通 public boolean connected(int p,int q)//返回点p所在分量的标识符 private int find(int p) //返回连通分量的个数 public int count() //将p和q两个点连接 public void union(int p,int q) 对于find()和union()有多种实现方式，我们先介绍最基本的quick-find算法： 一、quick-find在该算法中，我们使用一个int id[]数组表示对应的顶点所在的连通分量标识符，如id[0]=0表示顶点0所在的连通分量为0，在构造函数中，会将所有顶点对应的id[]值初始化为与其自身相等的值，表示一开始各个点都以自身作为一个单独的分量，互相不连通。如下： 123456789101112private int[] id; /** * 连通分量数量(标识符) */ private int count; public UF(int count) { this.count = count; this.id=new int[count]; for (int i = 0; i &lt; count; i++) { id[i]=i; } } 对于find()的实现，先介绍quick-find算法，其实现如下： 123private int quickFind(int i) { return id[i]; } id[i]直接保存i的分量id，因此当id[p]=id[q]时，表示p和q是连通的。由此可得connected(p,q)的实现： 123456/** * p和q是否在同一个分量 */ public boolean connected(int p,int q){ return quickFind(p)==quickFind(q); } 而要想实现将p和q连接起来，首先要判断两点是否连通，如果连通则直接返回，如果不连通，则遍历id数组，让所有与id[p]相等的点，改为id[q]，即将所有与p在同一个连通分量上的点修改为q所在连通分量。图示如下： 123456789101112如要连接union(3,4)，p=3，q=4id数组如下:p q 0 1 2 3 4 5 6 7 8 93 4 1 1 2 3 5 6 6 3 3 5可见，id[p]=id[3]=3 ,id[q]=id[4]=5 与p在同一分量的点有：3 7 8 与q在同一分量的点有: 4 9 所以union(3,4)的任务就是让所有id[i]等于3的位置，改为5，即实现连接 连接后的状态如下：p q 0 1 2 3 4 5 6 7 8 93 4 1 1 2 3 5 6 6 3 3 5 1 1 2 5 5 6 6 5 5 5 union实现如下： 12345678910public void union(int p,int q){ if (!connected(p,q)){ for (int i = 0; i &lt; id.length; i++) { if (id[i]==id[p]){ id[i]=id[q]; count--; } } } } 不难发现，该算法每次find()只会访问一次数组，每次union()操作数组的次数 在N+3到2N+1次，最坏情况下会达到平方级别。因此该算法速度快，但无法解决大型问题，因为每次都需要遍历整个id[]数组。 接下来的quick-union对quick-find进行了优化： 二、quick-union该算法的数据结构同quick-find相同，但是id[]的意义改变了。在该算法中，id[]中的元素保存的都是同一个连通分量中的另一个元素。如下图： 12345671 8 / | \\ / \\ 0 2 7 3 9 | | 5 4 | 6 由上图可得id数组： 120 1 2 3 4 5 6 7 8 9 id索引1 1 1 8 3 0 5 1 8 8 值 可知除了根节点，所有的节点的id值都等于上一个节点的值。 而同一个分量的节点，循环向上寻找，最终都会在根节点相遇。如果两个节点在根节点的值相同，则说明在同一个分量，否则在不同的分量中。如果要连接两个分量，只需连接两个分量的根节点，如上图，要连接5和9，则直接让id[1]=8即可。可得如下union-find算法： 1234567891011121314public void union(int p,int q){ int i = find(p); int j = find(q); if (i!=j){ id[i]=j; count--; } } public int find(int p){ while(p!=id[p]){ p=id[p]; } return p; } 分析可知，该算法的find()方法访问数组的次数为1+给定出点对应的高度的两倍，union()访问数组次数为两次find()操作，如果两个不在一个分量中，则还需+1次。在最坏情况下，只有一个无分支的连通分量，即顶点高度height=N，N为所有节点数，此时的运行时间也是平方级的，如果数量巨大，则也很吃力。 三、加权quick-union算法该算法在理解quick-union的基础上，会记录每个节点的高度，在每次union时，会比较高度，并将小树连接到大树上，这样控制树的高度就可以解决上述quick-union的最坏情况。 123456789101112131415161718public class WeightedQuickUnionFind { private int[] id; //每个根节点对应的分量的大小 private int[] weighted; private int count; public WeightedQuickUnionFind(int count) { this.count = count; weighted=new int[count]; id = new int[count]; for (int i = 0; i &lt; count; i++) { //分量大小初始化为1 weighted[i]=1; //分量标识符初始化为自身 id[i]=i; } }} 该算法的find()方法同上，union算法如下： 12345678910111213141516171819202122/** * 加权quick-union算法，保证每次都将小树加到大树上 * @param p * @param q */ public void union(int p,int q){ int i = find(p); int j = find(q); if(i==j)return; else{ //连接时判断两个根节点所在分量的大小 if (weighted[i]&lt;weighted[j]){ id[i]=j; //修改大小 weighted[j] += weighted[i]; }else { id[j]=i; weighted[i] += weighted[j]; } } count--; } 加权quick-union算法 可用于解决大型问题N个点M个连接最多访问数组cMlogN次，c为常数最坏情况下find()、connected()和union()的增长数量级为logN 四、最优算法（使用路径压缩）最优的算法应当是一种能够保证在常数时间内完成各种操作的算法。理想情况下我们希望各个节点都直接链接到根节点，又不想通过大量修改实现。要实现这种算法，就是在find()同时，将该节点路径上的所有节点都直接链接到根节点。 在find()中实现路径压缩： 1234567891011121314151617181920212223/** * 使用路径压缩，将路径上的所有节点都直接与根节点相连 * @param p * @return */ public int find(int p) { //root记录根节点 int root=p; while (root!=id[root]){ //循环找到当前节点所在分量的根节点 root=id[root]; } //此时root已经为当前分量根节点 //对p进行同样方法的循环，将与p在同一个路径上的节点直接与root相连接 while (id[p]!=root){ int temp=p; //当前节点与root连接 id[temp]=root; //指向下一个节点，继续循环 p=id[p]; } return root; } 因此使用路径压缩的加权quick-union算法就是该问题的最优解，该算法的union和find()的成本的增长数量级已经非常接近1，但没达到1以下是完整代码： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061public class ComPathWeightedQuickUnionFind { private int[] id; private int[] weighted; private int count; public ComPathWeightedQuickUnionFind(int count) { this.count = count; weighted=new int[count]; id = new int[count]; for (int i = 0; i &lt; count; i++) { weighted[i]=1; id[i]=i; } } /** * 加权quick-union算法，保证每次都将小树加到大树上 * @param p * @param q */ public void union(int p,int q){ int i = find(p); int j = find(q); if (i==j){ return; }else { if (weighted[i]&lt;weighted[j]){ id[i]=j; weighted[j] += weighted[i]; }else { id[j]=i; weighted[i] += weighted[j]; } } count--; } /** * 使用路径压缩，将路径上的所有节点都直接与根节点相连 * @param p * @return */ public int find(int p) { int root=p; while (root!=id[root]){ root=id[root]; } while (id[p]!=root){ int temp=p; id[temp]=root; p=id[p]; } return root; } public boolean connected(int p , int q){ return find(p)==find(q); } public int count(){ return count; }} 参考：《算法第四版》1.5节","link":"/posts/20200310-union-find.html"},{"title":"顺序查找和二分查找----java实现","text":"一、基于无序链表的顺序查找优点：适用小型问题缺点：对大型符号表很慢 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104/** * 顺序查找（基于无序链表） * 未命中和命中都需要N次比较 * 命中最坏需要N次比较 * @author MaoLin Wang * @date 2020/3/118:01 */public class SequentialSearchST&lt;Key, Value&gt; { /** * 首节点 */ private Node first; private int size; private class Node { private Key key; private Value value; private Node next; public Node(Key key, Value value, Node next) { this.key = key; this.value = value; this.next = next; } } /** * 根据key查询对应的值，一个个往下遍历直到找到相等的key，返回对应的值，否则返回null * @param key * @return */ public Value get(Key key) { for (Node x = first; x != null; x = x.next) { if (key.equals(x.key)) { return x.value; } } return null; } /** * 加入一个元素 * @param key * @param value */ public void put(Key key, Value value) { for (Node x = first; x != null; x = x.next) { //key已存在，更新对应的值 if (key.equals(x.key)) { x.value = value; return; } } //key不存在，新添加一个节点 first = new Node(key, value, first); size++; } public boolean isEmpty() { return size == 0; } private int size() { return size; } public boolean contains(Key key) { if (key == null) throw new IllegalArgumentException(\"argument to contains() is null\"); return get(key) != null; } /** * 删除key对应的节点 * @param key */ public void delete(Key key) { if (key == null) throw new IllegalArgumentException(\"argument to delete() is null\"); first = delete(first, key); } /** * 递归查找，直到找到相等的key，正常删除链表节点 * @param x * @param key * @return */ private Node delete(Node x, Key key) { if (x == null) return null; if (key.equals(x.key)) { size--; return x.next; } x.next = delete(x.next, key); return x; } public Iterable&lt;Key&gt; keys() { Queue&lt;Key&gt; queue=new Queue&lt;&gt;(); while (first!=null){ queue.enqueue(first.key); first=first.next; } return queue; }} 二、基于有序数组的二分查找查找很简单，先让目标值与中值比较，如果比中值小，则在左半边继续查找，如果比中值大，则继续要右半边查找。这里定义了rank()方法，返回比目标key小的key的数量 1234567891011121314151617181920212223/** * 返回小于给定键key的key的数量 * 1.找到给定key，则返回对应的mid坐标 * 2.找不到给定key，返回left指针，此时left指向大于等于给定key的最小位置 * 两种情况返回的都是小鱼给定key的key的数量 * @param key * @return */ public int rank(Key key){ int left=0,right=size-1; while (left&lt;=right){ int mid=left+(right-left)/2; int result=keys[mid].compareTo(key); if (result&lt;0){ left=mid+1; }else if (result &gt; 0){ right=mid-1; }else { return mid; } } return left; } 基本数据结构如下：使用泛型Key保存键，泛型Value保存值 12345678910public class BinarySearchST&lt;Key extends Comparable&lt;Key&gt;,Value&gt; { private Key[] keys; private Value[] values; private int size; public BinarySearchST(int size) { keys= (Key[]) new Comparable[size]; values= (Value[]) new Comparable[size]; }} 查找操作： 123456789101112public Value get(Key key){ if (isEmpty()){ return null; } int i=rank(key); //如果key存在，且i&lt;size，则keys[i]一定等于key，返回对应的value if (i&lt;size &amp;&amp; keys[i].compareTo(key)==0){ return values[i]; }else { return null; } } 添加一对数据 1234567891011121314151617181920212223242526public void put(Key key,Value value){ if (key==null){ return; } //value等于null，默认不存储null，删除对应的key-value if (value==null){ delete(key); return; } int i=rank(key); if (i&lt;size &amp;&amp; keys[i].compareTo(key)==0){ //存在key，则更新值 values[i]=value; }else { if (size == keys.length) resize(2*keys.length); //不存在，则将从i到size的所有元素向后移动一个位置，再将新的值加入到位置i for (int j = size; j &gt; i; j--) { keys[j]=keys[j-1]; values[j]=values[j-1]; } keys[i]=key; values[i]=value; size++; } } 删除一对数据： 12345678910111213141516171819public void delete(Key key){ if (key==null)throw new IllegalArgumentException(\"key为空\"); if (isEmpty()) return; //待删除key的位置 int i=rank(key); if (i&lt;size &amp;&amp; keys[i].compareTo(key)==0){ //如果key存在，则将i+1到size-1的元素向左移动一位 for (int j = i; j &lt; size-1 ; j++) { keys[j]=keys[j+1]; values[j]=values[j+1]; } //置最后一位为null size--; keys[size]=null; values[size]=null; return ; } } 其他完整代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183/** * N个键的有序数组最多需要N+1次比较 * @author MaoLin Wang * @date 2020/3/118:43 */public class BinarySearchST&lt;Key extends Comparable&lt;Key&gt;,Value&gt; { private Key[] keys; private Value[] values; private int size; public BinarySearchST(int size) { keys= (Key[]) new Comparable[size]; values= (Value[]) new Comparable[size]; } public int Size(){ return size; } public Value get(Key key){ if (isEmpty()){ return null; } int i=rank(key); if (i&lt;size &amp;&amp; keys[i].compareTo(key)==0){ return values[i]; }else { return null; } } public void put(Key key,Value value){ if (key==null){ return; } if (value==null){ delete(key); return; } int i=rank(key); if (i&lt;size &amp;&amp; keys[i].compareTo(key)==0){ //存在key，则更新值 values[i]=value; }else { if (size == keys.length) resize(2*keys.length); //不存在，则将从i到size的所有元素向后移动一个位置，再将新的值加入到位置i for (int j = size; j &gt; i; j--) { keys[j]=keys[j-1]; values[j]=values[j-1]; } keys[i]=key; values[i]=value; size++; } } /** * 返回小于给定键key的key的数量 * @param key * @return */ public int rank(Key key){ int left=0,right=size-1; while (left&lt;=right){ int mid=left+(right-left)/2; int result=keys[mid].compareTo(key); if (result&lt;0){ left=mid+1; }else if (result &gt; 0){ right=mid-1; }else { return mid; } } return left; } public boolean isEmpty(){ return size==0; } public Key minKey(){ return keys[0]; } public Key maxKey(){ return keys[size-1]; } public Key selectKey(int k){ return keys[k]; } /** * 向上取整 找出大于等于该键的最小键 * @param key * @return */ public Key ceiling(Key key){ int i=rank(key); return keys[i]; } /** * 向下取整 找出小于等于该键的最小键 * @param key * @return */ public Key floor(Key key){ if (key==null)throw new IllegalArgumentException(\"key为空\"); int i=rank(key); if (i&lt;size &amp;&amp; keys[i].compareTo(key)==0){ return keys[i]; }else if (i==0){ return null; }else { return keys[i-1]; } } public void delete(Key key){ if (key==null)throw new IllegalArgumentException(\"key为空\"); if (isEmpty()) return; int i=rank(key); if (i&lt;size &amp;&amp; keys[i].compareTo(key)==0){ for (int j = i; j &lt; size-1 ; j++) { keys[j]=keys[j+1]; values[j]=values[j+1]; } size--; keys[size]=null; values[size]=null; return ; } } private void resize(int capacity) { Key[] tempKey = (Key[]) new Comparable[capacity]; Value[] tempValue = (Value[]) new Object[capacity]; for (int i = 0; i &lt; size; i++) { tempKey[i] = keys[i]; tempValue[i] = values[i]; } values = tempValue; keys = tempKey; } public void delMin(){ delete(minKey()); } public void delMax(){ delete(maxKey()); } public Iterable&lt;Key&gt; keys(Key lo,Key hi){ Queue&lt;Key&gt;queue=new Queue&lt;&gt;(); int right = rank(hi); for (int i = rank(lo); i &lt; right; i++) { queue.enqueue(keys[i]); } if (contains(hi)){ queue.enqueue(keys[right]); } return queue; } public boolean contains(Key key) { if (key == null) throw new IllegalArgumentException(\"argument to contains() is null\"); return get(key) != null; } public static void main(String[] args) { BinarySearchST&lt;String,Integer&gt; binarySearchST=new BinarySearchST&lt;&gt;(5); binarySearchST.put(\"a\",3); binarySearchST.put(\"d\",2); binarySearchST.put(\"c\",1); binarySearchST.put(\"b\",0); binarySearchST.put(\"e\",4); System.out.println(binarySearchST.size); binarySearchST.delete(\"b\"); String s = binarySearchST.selectKey(3); System.out.println(s); }} 二分查找平均情况下的插入成本为 lgN，最坏情况下为lgN，一般情况比顺序查找快的多但是在键是随机的情况下，构造一个有序数组所需要访问数组的次数是数组长度的平方级别。因此最坏情况下，插入的成本为2N 优点：最优的查找效率和控件需求，能够进行有序性相关的操作缺点：插入操作慢","link":"/posts/20200310-seq-binary-find.html"},{"title":"优先队列（堆）以及堆排序-------java实现","text":"实现优先队列的基本数据结构是使用二叉堆 一、二叉堆二叉堆即用一颗完全二叉树（底层元素从左向右填入）。如果所示，因此我们可以使用一个数组来表示二叉堆，而不使用链表: 120 1 2 3 4 5 6 7 8 9 10 A B C D E F G H I 可以发现，对于任意节点 i，其 左二子在 2i 位置，右儿子在 2i+1位置 关于优先队列，我们可以规定最大元优先或最小元优先，对应的堆就是大顶堆和小顶堆。大顶堆： 即树上每个节点都小于等于其父亲节点，除了根节点，因为根节点没有父亲小顶堆：即树上每个节点都大于等于其父亲节点。同上 二、基本的堆操作（以小顶堆为例）1.插入1.可以在下一个可用位置处创建一个空节点，将待插入节点x放在0位置（0位置为空）2.然后循环比较待加入节点和空节点的父亲比较，如果父节点大于x，则将让父节点置于空节点，空节点上冒到原父节点；如果父节点小于x，则直接将x放在空位置，此时不会改变堆序 若创建大顶堆，则和父亲节点比较时，同小顶堆相反即可。 实现如下：先看基本的数据结构： 12345678910111213141516public class BinaryHeap&lt;T extends Comparable&lt;? super T&gt;&gt; { private static final int DEFAULT_CAPACITY = 10; //当前堆大小(元素个数) private int currentSize; //数组表示二叉堆 private T[] array; public BinaryHeap() { this(DEFAULT_CAPACITY); } public BinaryHeap(int capacity) { this.currentSize = 0; array = (T[]) new Comparable[capacity + 1]; }} 插入操作： 123456789101112131415161718192021222324252627/** * 先建立一个空位置 hole,上滤直到找到满足堆序的位置，将x插入到该位置 * array[0]暂存待插入元素x * @param x */ public void insert(T x) { //扩容操作 if (currentSize == array.length - 1) { enlargeArray(array.length * 2 + 1); } //让下一个节点为空节点 int hole=++currentSize; //将待插入节点放在0处 array[0]=x; //从空节点开始上冒 percolateUp(hole,array[0]); } /** * 上冒 * @param hole */ private void percolateUp(int hole,T x){ for ( ; x.compareTo(array[hole/2])&lt;0 ;hole /= 2) { array[hole]=array[hole/2]; } array[hole]=x; } 2. 删除最小值（出队）在二叉堆中，最小值即第arr[1]元素，但是删除它后，根节点变为空，因此我们需要把最后一个节点X放在这个空元素上，同时让当前堆大小减一，如果整个堆有序，则直接返回最小值，但是显然不可能保持堆序。因此我们就需要从该空节点开始进行下滤操作：下滤与上冒相反，就是沿着空节点开始包含最小儿子的路径上找到一个位置可以放入X。 图例：删除最小节点AB比I小，因此将空节点下滤：D比I小，因此空节点移动到D位置：此时I放在当前的空节点位置可以保持堆序：实现如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546/** * 删除最小元素，下滤 * 1.找到最小元素，移除（currentSize--,并将最后一个元素放在最小元素位置） * 2.对该元素进行下滤 * @return */ public T deleteMin(){ if (isEmpty()){ System.out.println(\"堆为空\"); } T min = findMin(); array[1]=array[currentSize--]; percolateDown(1); return min; } /** * 从hole开始下滤 * @param hole */ private void percolateDown(int hole) { int child; T temp = array[hole]; for ( ; hole*2&lt;=currentSize ;hole=child ) { child=hole*2; if (child!=currentSize&amp;&amp; //偶数个节点的情况下，最后一个hole只有一个左儿子，如果没有此条件array[child+1]会出现空指针异常 array[child+1].compareTo(array[child])&lt;0){//右儿子比左儿子还小 child++;//child指向右儿子 } //如果temp大于两个儿子中最小的一个节点，则让空节点下移到child if (array[child].compareTo(temp)&lt;0){ array[hole]=array[child]; }else break; } array[hole]=temp; } public T findMin(){ if (isEmpty()){ System.out.println(\"堆为空\"); } return array[1]; } 完整代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147/** * 堆(优先队列) * * @author MaoLin Wang * @date 2020/2/1611:26 */public class BinaryHeap&lt;T extends Comparable&lt;? super T&gt;&gt; { private static final int DEFAULT_CAPACITY = 10; private int currentSize; private T[] array; public BinaryHeap() { this(DEFAULT_CAPACITY); } public BinaryHeap(int capacity) { this.currentSize = 0; array = (T[]) new Comparable[capacity + 1]; } public BinaryHeap(T[] array) { currentSize = array.length; this.array = (T[]) new Comparable[(currentSize + 2) * 11 / 10]; int i = 1; for (T arr : array) { array[i++] = arr; } buildHead(); } private void buildHead() { for (int i = currentSize/2; i &gt;0 ; i--) { percolateDown(i); } } private void enlargeArray(int newSize) { T[] old = array; array = (T[]) new Comparable[newSize]; for (int i = 0; i &lt; old.length; i++) { array[i] = old[i]; } } /** * 先建立一个空位置 hole,上滤直到找到满足堆序的位置，将x插入到该位置 * array[0]暂存待插入元素x * @param x */ public void insert(T x) { if (currentSize == array.length - 1) { enlargeArray(array.length * 2 + 1); } int hole=++currentSize; array[0]=x; percolateUp(hole,array[0]); } /** * 上滤 * @param hole */ private void percolateUp(int hole,T x){ for ( ; x.compareTo(array[hole/2])&lt;0 ;hole /= 2) { array[hole]=array[hole/2]; } array[hole]=x; } /** * 删除最小元素，下滤 * 1.找到最小元素，移除（currentSize--,并将最后一个元素放在最小元素位置） * 2.对该元素进行下滤 * @return */ public T deleteMin(){ if (isEmpty()){ System.out.println(\"堆为空\"); } T min = findMin(); array[1]=array[currentSize--]; percolateDown(1); return min; } /** * 从hole开始下滤 * @param hole */ private void percolateDown(int hole) { int child; T temp = array[hole]; for ( ; hole*2&lt;=currentSize ;hole=child ) { child=hole*2; if (child!=currentSize&amp;&amp; //保证偶数个节点的情况下，最后一个hole只有一个左儿子 array[child+1].compareTo(array[child])&lt;0){ child++; } if (array[child].compareTo(temp)&lt;0){ array[hole]=array[child]; }else break; } array[hole]=temp; } public T findMin(){ if (isEmpty()){ System.out.println(\"堆为空\"); } return array[1]; } public void print(){ for (int i = 1; i &lt;currentSize ; i++) { System.out.println(array[i]); } } private boolean isEmpty() { return currentSize==0; } // Test program public static void main( String [ ] args ) { BinaryHeap&lt;Integer&gt; heap = new BinaryHeap&lt;&gt;(); heap.insert(13); heap.insert(14); heap.insert(16); heap.insert(19); heap.insert(21); heap.insert(19); heap.insert(68); heap.insert(65); heap.insert(26); heap.insert(32); heap.insert(31); System.out.println(\"-----\"); while (!heap.isEmpty()){ //依此出队 System.out.println(heap.deleteMin()); } }} 结果：1314161919212631326568 大顶堆的下滤操作也基本相同，只是改变一个比较的符号。 三、堆排序讲完了优先队列的实现后，再实现堆排序就很容易了。进行优先队列时，我们构造了大顶堆或小顶堆。这里依然以小顶堆为例：1.如果我们想让一个小顶堆数组变成有序数组，只需从最后一个元素开始，与根节点交换（相当于在优先队列中删除最小值，但是这里把最小值保存到了最后一个元素的位置），同时让currentSize减一。2.对新的根节点进行下滤操作，直到currentSize3.这样循环直到交换完所有元素，就得到了一个从大到小的有序数组 实现如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344/** * 使用小顶堆 ---&gt;从大到小排序 * @param arr */public static void heapSort(int[] arr){ for (int i = arr.length/2-1; i &gt;=0 ; i--) { //从 arr.length/2-1 即倒数第一个非叶子节点开始，逐一下滤，形成小顶堆 perDownMin(arr,i,arr.length); } for (int i = arr.length-1; i &gt;0 ; i--) { //将根节点，即最小的节点与最后一个节点交换，让最小值逐一放在最后 swap(arr,i,0); //从根节点开始重新生成小顶堆 perDownMin(arr,0,i); }} /** * 小顶堆下滤 * @param arr * @param i * @param length */private static void perDownMin(int[]arr, int i, int length){ int child; int temp; for (temp=arr[i];leftChild(i)&lt;length ;i=child) { child=leftChild(i); if (leftChild(i)!=length-1&amp;&amp;arr[child+1]&lt;arr[child]){ child++; } if (temp&gt;arr[child]){ arr[i]=arr[child]; }else { break; } } arr[i]=temp;}private static void swap(int[] arr, int index1, int index2){ int temp=arr[index1]; arr[index1]=arr[index2]; arr[index2]=temp;} 需要注意的是，这里不需要像优先队列进行删除（出队）和插入（入队）操作，因此数组是从0开始而不是从1开始，在个别判断有所不同。 同样的方法以大顶堆实现堆排序： 1234567891011121314151617181920212223242526272829303132333435363738/** * 使用大顶堆 ----&gt; 从小到大排序 * @param arr * @param &lt;T&gt; */ public static &lt;T extends Comparable&lt;? super T&gt;&gt;void heapSort(T[] arr){ for (int i = arr.length/2-1; i &gt;=0 ; i--) { perDownBig(arr,i,arr.length); } for (int i = arr.length-1; i &gt;0 ; i--) { swap(arr,0,i); perDownBig(arr,0,i); } } /** * 大顶堆下滤 * @param arr * @param i * @param length * @param &lt;T&gt; */ private static &lt;T extends Comparable&lt;? super T&gt;&gt;void perDownBig(T[] arr, int i, int length){ int child; T temp; for(temp=arr[i];leftChild(i)&lt;length;i=child){ child=leftChild(i); if (child!= length-1 &amp;&amp; arr[child].compareTo(arr[child+1])&lt;0){ child++; } if (temp.compareTo(arr[child])&lt;0){ arr[i]=arr[child]; }else { break; } } arr[i]=temp; } leftChild是一个私有的计算孩子节点位置的方法： 123private static int leftChild(int i){ return 2*i+1; } 测试： 123456789101112131415161718192021public static void main(String[] args) {/* int[] array =new int[8000000]; for (int i=0;i&lt;8000000;i++){ array[i]=(int)(Math.random()*8000000); } long begintime=System.currentTimeMillis(); heapSort(array); long endtime=System.currentTimeMillis(); System.out.println(\"用时：\"+(endtime-begintime)+\"ms\");*/ int[] array =new int[10]; for (int i=0;i&lt;10;i++){ array[i]=(int)(Math.random()*100); } heapSort(array); for (int i:array){ System.out.println(i); } } 123456789109777726965433219175 堆排序的时间复杂度为 NlogN空间复杂度为 1","link":"/posts/20200310-HeapPQ.html"},{"title":"《算法4》最短路径问题笔记","text":"一、最短路径的定义：在一幅加权有向图中，从顶点s到顶点t的最短路径是所有从s到t的路径中的权重最小者。 二、最短路径树一幅加权有向图中，以s为起点的一颗最短路径树是图的一个子图，包含了s和从s可达的所有顶点。该有向树的根节点为s，树的每条路径都是有向图中的一条最短路径。即我们可以找到从s到达图中任何顶点的最短路径。 三、加权有向边12345678910111213141516171819202122232425262728293031323334353637public class DirectedEdge { /** * 边的起点 */ private final int v; /** * 边的终点 */ private final int w; /** * 边的权重 */ private final double weight; public DirectedEdge(int v, int w, double weight) { this.v = v; this.w = w; this.weight = weight; } public double weight(){ return weight; } public int from(){ return v; } public int to(){ return w; } @Override public String toString() { return String.format(\"%d-&gt;%d %.2f\",v,w,weight); }} 四、加权有向图同前面讲图一样，我们在这里实现所需的加权有向图的类： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990public class EdgeWeightedDigraph { private static final String NEWLINE = System.getProperty(\"line.separator\"); //顶点数 private final int V; //边数 private int E; //顶点v的入度 private int[] indegree; // indegree[v] = indegree of vertex v private Bag&lt;DirectedEdge&gt;[] adj; public EdgeWeightedDigraph(int v){ this.V=v; this.E=0; this.adj=new Bag[V]; this.indegree = new int[V]; for (int i = 0; i &lt; V; i++) { adj[i]=new Bag&lt;&gt;(); } } //添加一条有向边 public void addEdge(DirectedEdge edge) { int from = edge.from(); validateVertex(from); int to = edge.to(); validateVertex(to); adj[from].add(edge); indegree[to]++; E++; } //顶点v的邻边，即由v发出的边 public Iterable&lt;DirectedEdge&gt; adj(int v) { validateVertex(v); return adj[v]; } /** * 顶点v的出度 * @param v * @return */ public int outdegree(int v) { validateVertex(v); return adj[v].size(); } /** * 顶点v的入度 * @param v * @return */ public int indegree(int v) { validateVertex(v); return indegree[v]; } public int V() { return V; } public int E() { return E; } //返回所有的边 public Iterable&lt;DirectedEdge&gt; edges(){ Bag&lt;DirectedEdge&gt;bag=new Bag&lt;&gt;(); for (int v = 0; v &lt; V; v++) { for (DirectedEdge edge:adj[v]){ bag.add(edge); } } return bag; } private void validateVertex(int v) { if (v &lt; 0 || v &gt;= V) throw new IllegalArgumentException(\"vertex \" + v + \" is not between 0 and \" + (V-1)); } public String toString() { StringBuilder s = new StringBuilder(); s.append(V + \" \" + E + NEWLINE); for (int v = 0; v &lt; V; v++) { s.append(v + \": \"); for (DirectedEdge e : adj[v]) { s.append(e + \" \"); } s.append(NEWLINE); } return s.toString(); }} 五、最短路径的数据结构 最短路径树中的边和前面讲的DFS、BFS以及Prim算法一样，这里使用DirectedEdge[] edgeTo数组来保存最短路径树中的边。其中edgeTo[v] 表示 树中连接v和其父节点的边（也是从s到v的最短路径上的最后一条边） 任意一个顶点v和起点s的距离使用edgeTo[] 数组保存起点s到任意顶点v的已知最短路径长度 同时做以下约定：对于起点s： edgeTo[s]= null; distTo[s] =0.0如果v从s不可达：distTo[v] = Double.POSITIVE_INFINITY 六、最短路径的求解思路边的松弛要想求得最短路径，每加入一个新的边，都必须对边进行“松弛”操作。先看如下示例： 已知distTo[v] = 3.0，即从s到v的最短路径权重为3.0；而到w的最短路径为3.4假设 待加入的新边 v -&gt; w 的权重为0.2， 此时 distTo[v]+0.2 =3.2 小于原本distTo[w]=3.4，因此从s到w的最短路径应该经过v再到w，且权重为3.2 因此我们需要更新distTo[w]的值为 distTo[v]+0.2，这样才能得到一个更短的路径；并且更新edgeTo[w]=边v-&gt;w，此时边 q -&gt; w 就不会再存放于最短路径树中，已经失效。 我们将如上的这样一个操作叫做对该边的一次成功的松弛(放松) 而如果distTo[v]加上边v-&gt;w的权重大于distTo[w]，则不做更新，它会让 边v-&gt;w 失效。因此我们可以得到松弛的定义： 放松边v -&gt; w意味着从s到w的最短路径是否是先从s到v，再从v到w。如果是，则根据该情况更新数据结构的内容。 由上我们可以得到通用的最短路径算法：1.将distTo[s]初始化为0，其他顶点的distTo为无穷大2.放松有向图中的任意一个边，直到不存在有效边为止 经过上述步骤，我们就可以保证对于任意一个从s可达的顶点w，distTo[w] 一定是从s到w的最短路径，且edgeTo[w] 为s到w的最短路径上的最后一条边。 七、Dijkstra（迪杰斯特拉）算法有了上面的基础，我们再来引入最终解决最短路径的Dijkstra算法（其实上面已经说的差不多了）：Dijkstra的思路跟Prim类似，但是Prim算法每次添加的都是距离树最近的非树顶点，而Dijkstra算法每次添加的是离起点s最近的非树顶点。 因此我们也需要借助索引优先队列(索引优先队列的讲解与实现参考文章https://wbml.top/posts/20200310-indexPQ.html)来实现，将顶点v作为索引，从s到v的最短路径的权重值作为索引关联的值。 步骤如下： 将distTo[s]初始化为0，数组的其他元素初始化为无穷大，并将s和distTo[s]加入索引优先队列； 取出队列中优先级最高的索引（顶点），对从该顶点出发的邻边进行放松，并将放松成功的边的另一个顶点及其对应的distTo值加入到优先队列中（第一次访问到该点时，尚未将其加入到队列中，即distTo为无穷大）或更新优先队列中对应的值（该顶点新的distTo值比原来小）； 当优先队列非空时，每次都取出一个索引（顶点），按2的方式进行放松，直到队列为空（即所有顶点都被加入到生成树中） 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051public class DijkstraSP { private DirectedEdge[] edgeTo; private double[] distTo; /** * 索引优先队列：顶点v作为索引，从起点到v的最短路径的权值作为索引关联的对象 */ private IndexMinPQ&lt;Double&gt; pq; public DijkstraSP(EdgeWeightedDigraph digraph,int s){ for (DirectedEdge e : digraph.edges()) { if (e.weight() &lt; 0) throw new IllegalArgumentException(\"边 \" + e + \" 的权重为负值！\"); } edgeTo=new DirectedEdge[digraph.V()]; distTo=new double[digraph.V()]; pq=new IndexMinPQ&lt;&gt;(digraph.V()); //初始化为无穷大 for (int v = 0; v &lt; digraph.V(); v++) { distTo[v]=Double.POSITIVE_INFINITY; } distTo[s]=0; pq.insert(s,0.0); while (!pq.isEmpty()){ relax(digraph,pq.delMin()); } } /** * 对顶点v的邻边放松 * @param digraph * @param v */ private void relax(EdgeWeightedDigraph digraph, int v) { for (DirectedEdge edge:digraph.adj(v)){ int to=edge.to(); if (distTo[to]&gt;distTo[v]+edge.weight()){ distTo[to]=distTo[v]+edge.weight(); edgeTo[to]=edge; if (pq.contains(to)){ pq.changeKey(to,distTo[to]); }else { pq.insert(to,distTo[to]); } } } }} 因此，我们就可以解决如下几个问题：1.该图的最短路径树；2.从s到任意顶点v的最短路径3.是否存在从s到v的最短路径，只要distTo[v] 非无穷大即存在。 123456789101112131415161718192021222324252627282930313233/** * 从起点到顶点v的最短路径权值 * @param v * @return */public double distTo(int v){ return distTo[v];}/** * 是否存在从s到v的最短路径 * @param v * @return */public boolean hasPathTo(int v){ return distTo[v]&lt;Double.POSITIVE_INFINITY;}/** * 返回从s到v的最短路径 * @param v * @return */public Iterable&lt;DirectedEdge&gt; pathTo(int v){ if (!hasPathTo(v))return null; Stack&lt;DirectedEdge&gt; path=new Stack&lt;&gt;(); for (DirectedEdge edge=edgeTo[v];edge!=null;edge=edgeTo[edge.from()]) { path.push(edge); } return path;} 将Dijkstra算法稍作改动就可以实现任意顶点对之间的最短路径问题： 123456789101112131415161718public class DijkstraAllPairsSP { private DijkstraSP[]all; public DijkstraAllPairsSP(EdgeWeightedDigraph digraph){ all=new DijkstraSP[digraph.V()]; for (int i = 0; i &lt; digraph.V(); i++) { all[i]=new DijkstraSP(digraph,i); } } public Iterable&lt;DirectedEdge&gt; path(int s,int t){ return all[s].pathTo(t); } public double distBetween(int s,int t){ return all[s].distTo(t); }} Dijkstra算法适用于加权有向非负权值的单起点图的最短路径问题，有环无环都不影响正确性。 八、无环加权有向图中的最短路径算法许多应用中的加权有向图都是不含有有向环的，因此我们介绍一个基于无环的加权有向图的最短路径算法，该算法比Dijkstra算法要快，能够在线性时间内解决该问题，且能够处理负权值的边，并找出最长路径。 该算法的思想是： 按照图的拓扑排序一个个放松所有的顶点，就能在和E+V成正比的时间内解决无环加权有向图的单点最短路径问题。 证明如下：每条边v-&gt;w只会被放松一次。因为顶点v被放松时，distTo[w]&lt;=distTo[v]+e.weight()，在算法结束前，该不等式始终成立。因为我们是按照拓扑排序放松顶点，所以v被放松后，就不会处理任何指向v的边，而distTo[w]的值只能变小。 实现如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546public class AcyclicSP { private DirectedEdge[] edgeTo; private double[] distTo; public AcyclicSP(EdgeWeightedDigraph digraph,int s){ edgeTo=new DirectedEdge[digraph.V()]; distTo=new double[digraph.V()]; for (int v=0;v&lt;digraph.V();v++){ distTo[v]=Double.POSITIVE_INFINITY; } distTo[s]=0.0; //先求出拓扑排序 TopologicalSort sort=new TopologicalSort(digraph); if (!sort.hasOrder()){ throw new IllegalArgumentException(\"Digraph is not acyclic.\"); } //按照拓扑排序放松顶点 for(int v:sort.order()){ relax(digraph,v); } } private void relax(EdgeWeightedDigraph digraph, int v) { for (DirectedEdge edge:digraph.adj(v)){ int to=edge.to(); if (distTo[to]&gt;distTo[v]+edge.weight()){ distTo[to]=distTo[v]+edge.weight(); edgeTo[to]=edge; } } } public double distTo(int v){ return distTo(v); } public boolean hasPathTo(int v){ return distTo(v)&lt;Double.POSITIVE_INFINITY; } public Iterable&lt;DirectedEdge&gt; pathTo(int v){ Stack&lt;DirectedEdge&gt; path=new Stack&lt;&gt;(); for ( DirectedEdge edge=edgeTo[v]; edge!=null ; edge=edgeTo[edge.from()]) { path.push(edge); } return path; }} 如果我们对上述算法稍作修改，即将distTo的初始值设为无穷小，将放松时distTo[w]&gt;&lt;distTo[v]+edge.weight()的条件修改为distTo[w]&lt;distTo[from]+edge.weight()，就可以实现无环加权有向图中的单点最长路径： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556/** * 加权有向无环图的最长路径 * @author MaoLin Wang * @date 2020/2/2416:38 */public class AcyclicLP { private double[] distTo; private DirectedEdge[] edgeTo; public AcyclicLP(EdgeWeightedDigraph digraph,int s) { distTo=new double[digraph.V()]; edgeTo=new DirectedEdge[digraph.V()]; for (int i = 0; i &lt; digraph.V(); i++) { //初始化为无穷小 distTo[i]=Double.NEGATIVE_INFINITY; } distTo[s]=0.0; TopologicalSort sort=new TopologicalSort(digraph); if (sort.order()==null){ throw new IllegalArgumentException(\"参数错误\"); } for (int w:sort.order()){ relax(digraph,w); } } private void relax(EdgeWeightedDigraph digraph, int v) { for (DirectedEdge edge:digraph.adj(v)){ int to=edge.to(),from = edge.from(); if (distTo[to]&lt;distTo[from]+edge.weight()){ //修改为&lt; distTo[to]=distTo[from]+edge.weight(); edgeTo[to]=edge; } } } public double distTo(int v) { return distTo[v]; } public boolean hasPathTo(int v) { return distTo[v] &gt; Double.NEGATIVE_INFINITY; } public Iterable&lt;DirectedEdge&gt; pathTo(int v){ if (!hasPathTo(v)){ return null; } Stack&lt;DirectedEdge&gt; path=new Stack&lt;&gt;(); for (DirectedEdge edge=edgeTo[v];edge!=null;edge=edgeTo[edge.from()]){ path.push(edge); } return path; }} 九、一般加权有向图中的最短路径算法该算法解决既可能含有环，也可能含有负权值边的加权有向图的最短路径算法。 这个仅做记录吧，可能个人讲的不太明白。 解决该问题的算法试Bellman-Ford算法，实现如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118/** * 基于队列的Bellman-Ford算法 * 在任意含有V个顶点的加权有向图中给定起点s，从s无法到达任何负权重环 * 将distTo[s]初始化为0，其他distTo[]元素为无穷大，以任意顺序放松有向图的所有边，重复V轮 * @author MaoLin Wang * @date 2020/2/2421:41 */public class BellmanFordSP { private double[] distTo; private DirectedEdge[] edgeTo; /** * 该顶点是否在队列中 */ private boolean[] onQ; /** * 正在被放松的顶点 */ private Queue&lt;Integer&gt; queue; /** * relax()的调用次数 */ private int cost; /** * edgeTo[]中是否有负权重环 */ private Iterable&lt;DirectedEdge&gt; cycle; public BellmanFordSP(EdgeWeightedDigraph digraph,int s) { distTo=new double[digraph.V()]; edgeTo=new DirectedEdge[digraph.V()]; onQ=new boolean[digraph.V()]; queue=new Queue&lt;&gt;(); for (int v = 0; v &lt; digraph.V(); v++) { distTo[v]=Double.POSITIVE_INFINITY; } distTo[s]=0.0; queue.enqueue(s); onQ[s]=true; while (!queue.isEmpty() &amp;&amp; !hasNegativeCycle()){ int v=queue.dequeue(); onQ[v]=false; relax(digraph,v); } } private void relax(EdgeWeightedDigraph digraph, int v) { for (DirectedEdge edge:digraph.adj(v)){ int to=edge.to(); if (distTo[to]&gt;distTo[v]+edge.weight()){ distTo[to]=distTo[v]+edge.weight(); edgeTo[to]=edge; if (!onQ[to]){ queue.enqueue(to); onQ[to]=true; } } //调用V次relax后查找负权重环 if (cost++ % digraph.V()==0){ findNegativeCycle(); } } } /** * 查找负权重环，没有则返回null */ private void findNegativeCycle() { int V=edgeTo.length; EdgeWeightedDigraph digraph; digraph=new EdgeWeightedDigraph(V); for (int v = 0; v &lt; V; v++) { if (edgeTo[v]!=null){ digraph.addEdge(edgeTo[v]); } } EdgeWeightedDirectedCycle directedCycle; directedCycle=new EdgeWeightedDirectedCycle(digraph); cycle=directedCycle.cycle(); } /** * 是否含有负权重环 * @return */ public boolean hasNegativeCycle() { return cycle!=null; } public Iterable&lt;DirectedEdge&gt; negativeCycle(){ return cycle; } public boolean hasPathTo(int v){ return distTo[v]&lt;Double.POSITIVE_INFINITY; } public double distTo(int v){ return distTo[v]; } public Iterable&lt;DirectedEdge&gt; pathTo(int v){ if (hasNegativeCycle()) throw new UnsupportedOperationException(\"Negative cost cycle exists\"); if (!hasPathTo(v)) return null; Stack&lt;DirectedEdge&gt; path = new Stack&lt;DirectedEdge&gt;(); for (DirectedEdge e = edgeTo[v]; e != null; e = edgeTo[e.from()]) { path.push(e); } return path; } }","link":"/posts/20200310-sp-dijkstra.html"},{"title":"《算法4》红黑树的原理解析---java实现","text":"前面讲了AVL平衡树的实现https://wbml.top/posts/20200310-avltree.htm，但由于AVL是高度平衡的树（高度差小于等于1），而红黑树是根据颜色来不严格的实现平衡，因此在插入和删除节点时，红黑树的调整次数较少，尤其是在大量数据面前时，红黑树的效率会更高。其是AVL树的一个变种。 一、定义介绍首先我们需要知道什么是2-节点，什么是3-节点。2-节点就是我们常说的二叉节点，一个节点两个链接3-节点则是两个节点三个链接 红黑树中，树的链接有两种类型：红链接和黑链接一个红链接将两个2-节点连接起来，形成一个3-节点黑链接就是一个普通连接，如下：上面的2-3树对应下面的红黑树 定义如下：1.红链接都是左链接，不允许为右链接（仅因减小代码量）2.没有任何一个节点同时和两条红链接相连3.该树是完美黑色平衡的，即任意空连接到根节点的路径上的黑链接数量相同。 二、数据结构如下：每个节点增加了一个布尔类型color变量，表示指向该节点的链接的颜色，color的取值为RED（true）和BLACK(false) 1234567891011121314151617181920212223242526272829303132public class RedBlackTree&lt;Key extends Comparable&lt;Key&gt;,Value&gt; { private static final boolean RED=true; private static final boolean BLACK= false; private Node root; private class Node{ // 左右孩子 private Node left,right; /** * 其父节点指向该节点的链接颜色 */ private boolean color; //键 private Key key; //键关联的值 private Value value; /** * 子树中的节点总数 */ private int size; public Node( boolean color,Key key,Value value, int size) { this.key=key; this.color = color; this.value = value; this.size = size; } }} 三、旋转操作在对红黑树进行操作时，难免会出现连续的两个红链接相连，红链接可能是连续两个左链接，也可能是一个右链接，因此我们需要旋转链接进行修复。红黑树的旋转一共有两个情况：1.对一个右红链接左旋转如下图，对右链接为红色的节点f进行左旋转，变为下面一个图：代码如下： 代码如下： 1234567891011121314151617181920/** * 左旋转(右链接为红色) * @param node * @return */ private Node rotateLeft(Node node){ //这里旋转逻辑同AVL Node right=node.right; node.right=right.left; right.left=node; //但是需要修改两个节点的颜色 //将右节点的颜色改为node的颜色 right.color=node.color; //将node 的颜色改为红色，因为是把红链接旋转过来，这里必然是红色 node.color=RED; right.size=node.size; node.size=1+size(node.left)+size(node.right); return right; } 2.对一个左红链接右旋转如下图，对左链接为红色的节点b进行右旋转，变为下面一个图：代码如下：逻辑和上面一样，相反而已 123456789101112131415161718/** * 右旋转(左链接为红色) * @param node * @return */ private Node rotateRight(Node node){ Node left=node.left; node.left=left.right; left.right=node; left.color=node.color; node.color=RED; left.size=node.size; node.size=1+size(node.left)+size(node.right); return left; } 四、插入操作我们在插入一个节点的时候，默认让其颜色为红色，这样就会出现以下几种情况： 当插入到一个2-节点时：此时有两种情况： 指向新节点的链接是父节点的左链接：此时父链接直接成了一个3-节点，如下图，插入节点a，此时a与父节点b成为一个3-节点 指向新节点的链接是父节点的右链接： 此时是一个错误的3-节点，因为我们规定红链接必须的左链接，因此我们需要对其进行左旋转： 如下图新插入了一个节点c，指向它的链接为父链接节点b的右链接 对齐进行左旋转修正，如下图： 当插入到一个3-节点时：1.插入的是3-节点的右链接此时需要将两个链接都变为黑色：这个过程叫做颜色转换： 12345private void flipColors(Node node){ node.color = !node.color; node.left.color = !node.left.color; node.right.color = !node.right.color; } 书上给的是让node变为红色，左右孩子变为黑色，但因为后面还要用到这个方法，并且是转换为与原来颜色对应的颜色，所以这里直接写成这样，同样适用。在我们每次插入后都会让根节点变为黑色，而如果根节点从红变为黑是，就意味着其高度加1 2.插入的是3-节点的中链接 此时需要先对节点a进行左旋转变成右边的图，然后再对节点c进行右旋转，如下：此时变成了第一种情况，按第一种情况继续处理即可 3.插入的是3-节点的左链接如上图，插入节点a，此时变成了第二种情况左旋转后的状态，按上面的步骤处理即可。 综合可以得出插入算法的步骤：1.如果插入的是2-节点，只需按2-节点的两种情况操作即可2.如果插入的是3-节点，则临时创建了一个4-节点，我们需要将其分解并将红链接向上传递，直到遇到一个2-节点或根节点。观察上面的几种方法，都是为了完成这个目标。 而在代码中的体现就是：1.如果右孩子是红色，左孩子为黑色，则左旋转2.如果左孩子和左孩子的左孩子都是红色， 则进行右旋转3.如果左孩子和右孩子都是红色，则进行颜色转换 观察上述3点，其可以涵盖我们上面的任意情况。 插入算法如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152public void put(Key key,Value value){ if (key == null) throw new IllegalArgumentException(\"key为空\"); if(value==null){ delete(key); return; } root=put(root,key,value); //插入后将根节点颜色变为黑色 root.color=BLACK; } private Node put(Node node,Key key,Value value) { if (node==null){ //插入的节点，总是让它的颜色初始化为红 return new Node(RED,key,value,1); } int result=key.compareTo(node.key); if (result&lt;0){ node.left=put(node.left,key,value); }else if (result&gt;0){ node.right=put(node.right,key,value); }else { node.value=value; } /* 右链接为红色 1.即向2-节点右边插入 2 或是 向3-节点中间插入 */ if (isRed(node.right)&amp;&amp;!isRed(node.left)){ //左旋转 node=rotateLeft(node); } //3.指向新节点的链接为3-节点的左链接 //4.或是情况2左旋转后的状态 if (isRed(node.left)&amp;&amp;isRed(node.left.left)){ //右旋转 node=rotateRight(node); } //5.左右链接均为红，即成为一个4-节点(3、4 右旋转后的状态) if (isRed(node.left)&amp;&amp;isRed(node.right)){ //转换颜色 flipColors(node); } node.size=size(node.left)+size(node.right)+1; return node; } private int size(Node node) { return node==null?0:node.size; } 判断当前节点是否被红链接指向： 五、删除最小值删除操作比较麻烦，也是看的很久才看懂(hhhh)如果待删除的节点是一个3-节点，那么直接删除就好了，但是如果是一个2-节点，删除后便后印象树的结构，因此删除最小值的思路如下：从根节点开始向下寻找最小值，路径上的每一个节点都需要满足以下条件之一：1.当前节点的左孩子是3-节点，过2.当前节点的左孩子是2-节点，但是兄弟节点是3-节点，此时可以向兄弟节点借一个过来，保证自己不是2-节点；3.当前节点左孩子右孩子都是2-节点，则向父节点借一个，并将借的节点和左孩子右孩子合并。 按如上操作遍历到最小值处，此时最小值就在一个3-节点或者4-节点中，删除接即可。然后就可以自底向上修复临时的4-节点（同前面的步骤）。 123456789101112131415161718192021public void delMin(){ if (isEmpty()){ throw new NoSuchElementException(\"树为空\"); } if(!isRed(root.left) &amp;&amp; !isRed(root.right)){ root.color = RED; // 如果根节点的左右子节点是2-节点，我们要先根设为红的，这样才能进行后面的moveRedLeft操作，因为左孩子要从根节点借一个 } root = delMin(root); root.color = BLACK; // 借完以后，我们将根节点的颜色复原 } private Node delMin(Node node) { if (node.left==null){ return null; } if (!isRed(node.left) &amp;&amp; !isRed(node.left.left)){ // node的左节点如果是2-节点，则按上面的方法编程3-节点或是临时4-节点 node=moveRedLeft(node); } node.left=delMin(node.left); return balance(node); // 平衡临时组成的4-节点 } 以下是2-节点变3-节点或4-节点的方法： 123456789101112131415161718private Node moveRedLeft(Node node) { /** * 因为我们规定红链接只能在左， * 因此当前节点的左右子节点都是2-节点，这时候我们就需要通过颜色转换，将这三个节点合并在一起 */ flipColors(node); //如果兄弟节点为2-节点的话，那么到上一步就结束了 if(isRed(node.right.left)){ // 而如果兄弟节点不是2-节点的话，我们就需要通过旋转从兄弟节点借一个过来 node.right = rotateRight(node.right); node = rotateLeft(node); // 因为条件2要求我们只向兄弟节点借一个， // 而一开始从父节点那里借了一个，因此需要还一个给父节点 flipColors(node); } return node; } 删除完毕后，我们需要自顶向上分解临时的4-节点：以下代码和上面的put最后几个if相同，只是在开始添加了一个条件，但是这个条件去掉后也不影响，因为如果第一个if左旋转后，第二个if必然不会再走，因为左孩子必然是红色；如果去掉第一个if，如果左黑右红，则进行左旋转，如果左红右红，那就属于最后一个情况，转换颜色即可，不影响结果 1234567891011121314151617private Node balance(Node node){ if (isRed(node.right)) { node = rotateLeft(node); } if (isRed(node.right) &amp;&amp; !isRed(node.left)) { node=rotateLeft(node); } if (isRed(node.left) &amp;&amp; isRed(node.left.left)) { node=rotateRight(node); } if (isRed(node.left) &amp;&amp; isRed(node.right)) { flipColors(node); } node.size = size(node.left)+size(node.right)+1; return node; } 六、删除最大值逻辑同删除最小值相同，方向相反。 12345678910public void delMax(){ if (isEmpty()){ throw new NoSuchElementException(\"树为空\"); } if (!isRed(root.left) &amp;&amp; !isRed(root.right)){ root.color=RED; } root=delMax(root); root.color=BLACK; } 在删除中需要添加一个左孩子是否为红链接的判断，因为最大值要么不存在子孩子，要么最多存在一个左链接（从以上几个平衡旋转可以发现，最大值节点一定是这两个情况）如果有左红链接，则应该将此节点右旋转，让最大值没有一个孩子，这样就可以直接删除，否则会破坏树的结构，丢失该左孩子 1234567891011121314private Node delMax(Node node) { if(isRed(node.left)){ node = rotateRight(node); } if (node.right==null){ return null; } if (!isRed(node.right) &amp;&amp; !isRed(node.right.left)){ node=moveRedRight(node); } node.right=delMax(node.right); return balance(node); } 七、删除任意key删除操作则就是将删除最小值和删除最大值组合在一起，但需要考虑key不在树底的情况，此时按二叉查找树的删除逻辑删除即可，具体如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243public void delete(Key key) { if (key == null) throw new IllegalArgumentException(\"argument to delete() is null\"); if (!contains(key)) return; if (!isRed(root.left) &amp;&amp; !isRed(root.right)) root.color = RED; root = delete(root, key); if (!isEmpty()) root.color = BLACK; } private Node delete(Node node, Key key) { if (key.compareTo(node.key) &lt; 0) { //key在左子树，按删除最小值一样删除 if (!isRed(node.left) &amp;&amp; !isRed(node.left.left)) node = moveRedLeft(node); node.left = delete(node.left, key); } else {//key在右子树，按删除最大值一样删除 if (isRed(node.left)) node = rotateRight(node); //需首先判断待删除的节点是否在树底，否则下一步的node.right.left会出现空指针 if (key.compareTo(node.key) == 0 &amp;&amp; (node.right == null)) return null; //递归在右子树中删除 if (!isRed(node.right) &amp;&amp; !isRed(node.right.left)) node = moveRedRight(node); //如果待删除的节点不在树底 if (key.compareTo(node.key) == 0) { //像二叉查找树一样删除，从node右子树找到最小的节点放在当前位置，然后再将该最小节点从右子树删除 Node x = min(node.right); node.key = x.key; node.value = x.value; node.right = delMin(node.right); } else { //key仍然大于该node，继续在右子树递归 node.right = delete(node.right, key); } } return balance(node); } 获取给定键的值，同前面二叉查找树相同。 12345678910111213141516171819public Value get(Key key){ if (key==null){ return null； } return get(root,key); } private Value get(Node node, Key key) { while (node!=null){ int result=key.compareTo(node.key); if (result&lt;0){ node=node.left; }else if (result&gt;0){ node=node.right; } else { return node.value; } } return null; } 八、总结： 一颗大小为N的红黑树的高度不会超过2lgN 红黑树最坏情况下的运行时间的增长数量级：查找：2lgN删除：2lgN平均情况：查找：lgN插入：lgN AVL树追求完美平衡，读取的性能略高；但维护较慢，空间开销较大。红黑树的读取性能略低（但最多也就多比较一次左右），空间复杂度同AVL差不多，但数据量大时，红黑树的综合性能更高 因此在查找大于插入或删除的场景时，使用AVL树，如果次数都差不多，就用红黑树。**","link":"/posts/20200310-RedBlackTree.html"},{"title":"《算法4》最小生成树讲解笔记（Prim的延时和即使实现，Kruskal算法）","text":"生成树： 图的生成树就是一颗含有其所有顶点的无环连通子图。最小生成树： 即给定一个加权无向图，找到它的一颗最小生成树（权值最小）。 因此最小生成树的研究范围是：带权无向图，且是连通图。 如下给出加权无向图的数据结构：带权重的边： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253/** * 带权重的边 * @author MaoLin Wang * @date 2020/2/239:49 */public class Edge implements Comparable&lt;Edge&gt;{ private final int v; private final int w; private final double weight; public Edge(int v, int w, double weight) { if (v &lt; 0) throw new IllegalArgumentException(\"vertex index must be a nonnegative integer\"); if (w &lt; 0) throw new IllegalArgumentException(\"vertex index must be a nonnegative integer\"); if (Double.isNaN(weight)) throw new IllegalArgumentException(\"权重必须为数值\"); this.v = v; this.w = w; this.weight = weight; } /** * 返回权重 * @return */ public double weight() { return weight; } /** * 返回边两端的顶点之一 * @return */ public int either() { return v; } /** * 返回另一个顶点 * @param vertex * @return */ public int other(int vertex) { if (vertex == v) return w; else if (vertex == w) return v; else throw new IllegalArgumentException(\"Illegal endpoint\"); } @Override public int compareTo(Edge edge) { return Double.compare(this.weight, edge.weight); } public String toString() { return String.format(\"%d-%d %.5f\", v, w, weight); }} 加权无向图：同之前将的几个图基本一样，只是这是添加边是通过Edge对象还要注意的是，在返回所有的边时，要考虑自环的情况。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778/** * 加权无向图 * @author MaoLin Wang * @date 2020/2/239:54 */public class EdgeWeightedGraph { private static final String NEWLINE = System.getProperty(\"line.separator\"); private final int V; private int E; private Bag&lt;Edge&gt;[] adj; public EdgeWeightedGraph(int V) { if (V &lt; 0) throw new IllegalArgumentException(\"Number of vertices must be nonnegative\"); this.V = V; this.E = 0; adj = (Bag&lt;Edge&gt;[]) new Bag[V]; for (int v = 0; v &lt; V; v++) { adj[v] = new Bag&lt;Edge&gt;(); } } //添加一条边 private void addEdge(Edge e) { int v = e.either(); int w = e.other(v); validateVertex(v); validateVertex(w); adj[v].add(e); adj[w].add(e); E++; } //返回顶点v的邻边 public Iterable&lt;Edge&gt; adj(int v) { validateVertex(v); return adj[v]; } //顶点v的度 public int degree(int v) { validateVertex(v); return adj[v].size(); } //返回所有边 public Iterable&lt;Edge&gt; edges() { Bag&lt;Edge&gt; list = new Bag&lt;Edge&gt;(); for (int v = 0; v &lt; V; v++) { int selfLoops = 0; for (Edge e : adj(v)) { if (e.other(v) &gt; v) { list.add(e); } else if (e.other(v) == v) { //是自环 如 1-1 if (selfLoops % 2 == 0) list.add(e);//对于自环，只需要添加一个副本即可，因为我们在addEdge时，添加了两条一样的边 selfLoops++; } } } return list; } private void validateVertex(int v) { if (v &lt; 0 || v &gt;= V) throw new IllegalArgumentException(\"vertex \" + v + \" is not between 0 and \" + (V-1)); } public int V() { return V; } public int E() { return E; } @Override public String toString() { return \"顶点：\" + V + \", 边=\" + E + \"\\n\" + Arrays.toString(adj); }} 一、Prim算法Prim算法的每一步都会为一颗正在生长的树添加一条边。树是从一个顶点开始的，然后每次添加一条边，该边是下一条 连接树中的顶点和不在树中的顶点且权重最小的边。 该算法能够得到任意加权连通图的最小生成树。 在这之前要讲一下切分定理： 图的一种切分就是将图的所有顶点分为两个非空的且不重叠的集合。横切边是一条连接两个属于不同集合的顶点的边（一边连接这个集合，一边接连另一个集合）。切分定理就是给定任意切分，横切边中权值最小的边必然属于最小生成树； Prim的延时实现1.1数据结构我们需要如下的数据结构来实现Prim算法，其中BinaryHeap是前面讲过的优先队列（小顶堆实现），需要的可以看这篇文章：优先队列（堆）以及堆排序——-java实现 1234567891011121314/** * 最小生成树的顶点 */ private boolean[] marked; /** * 最小生成树的边 */ private Queue&lt;Edge&gt; mst; /** * 横切边（包括失效的边） */ private BinaryHeap&lt;Edge&gt; pq; 1.2 实现思路1.选择一个顶点标记它，然后将连接这个顶点和其他所有不再树中的顶点的边加入优先队列中（优先队列按边的权重从小到大排列）；2.从优先队列中取出权重最小的边，如果边的两个顶点都被访问过了，则代表该边失效了，继续取下一个最小的边；3.如果权重最小的边（即横切边）没有失效，则将其加入最小生成树队列，将对该边未被访问的点再次进行 步骤1的操作，直到优先队列为空，此时最小生成树的边都在mst队列中了。如下图：选取0作为开始的顶点，然后将与0相连的且其他不在树中的边加入优先队列（后边直接展示优先队列状态）：*表示新加入的边，△表示失效的边，图中红色的边为加入最小生成树中的边，蓝色的边未优先队列中的边；橙色的节点表示最小生成树，绿色的表示未加入 12345 边 权重* 0-7 0.16* 0-2 0.26* 0-4 0.38* 6-0 0.58 将权重最小的边0-7从优先队列取出，并加入最小生成树，继续对未被访问的顶点7进行上述操作： 1234567* 1-7 0.19 0-2 0.26* 5-7 0.28* 2-7 0.34* 4-7 0.37 0-4 0.38 6-0 0.58 将边 1-7取出加入生成树： 123456789 0-2 0.26 5-7 0.28* 1-3 0.29* 1-5 0.32 2-7 0.34* 1-2 0.36 4-7 0.37 0-4 0.38 6-0 0.58 将边0-2取出加入生成树： 12345678910* 2-3 0.17 5-7 0.28 1-3 0.29 1-5 0.32 △ 2-7 0.34△ 1-2 0.36 4-7 0.37 0-4 0.38* 6-2 0.40 6-0 0.58 将2-3取出加入生成树： 1234567891011 5-7 0.28△ 1-3 0.29 1-5 0.32 △ 2-7 0.34△ 1-2 0.36 4-7 0.37 0-4 0.38 6-2 0.40* 3-6 0.52 6-0 0.58 取出5-7加入生成树： 12345678910△ 1-3 0.29△ 1-5 0.32 △ 2-7 0.34* 5-4 0.35△ 1-2 0.36 4-7 0.37 0-4 0.38 6-2 0.40 3-6 0.52 6-0 0.58 此时前面三个边已经失效了，全部移除，将边5-4加入生成树： 1234567△ 1-2 0.36△ 4-7 0.37△ 0-4 0.38 6-2 0.40 3-6 0.52 6-0 0.58 6-4 0.93 将未失效的6-2加入生成树：此时优先队列剩余边全部失效，mst队列已经得到了该图从0开始的最小生成树。 1.3 Prim的延时实现123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778public class LazyPrimMST { /** * 最小生成树的顶点 */ private boolean[] marked; /** * 最小生成树的边 */ private Queue&lt;Edge&gt; mst; /** * 横切边（包括失效的边） */ private BinaryHeap&lt;Edge&gt; pq; public LazyPrimMST(EdgeWeightedGraph G){ pq=new BinaryHeap&lt;&gt;(); marked=new boolean[G.V()]; mst=new Queue&lt;&gt;(); //假设G是连通的 visit(G,0); while (!pq.isEmpty()){ //从pq中得到权重最小的边 Edge edge = pq.deleteMin(); int v=edge.either(),w=edge.other(v); if (marked[v]&amp;&amp;marked[w]){//已失效，忽略 continue; } //当前边加入最小生成树 mst.enqueue(edge); //访问当前横切边未被访问的那个顶点v或w if (!marked[v]){ visit(G,v); } if (!marked[w]){ visit(G,w); } } } /** * 将所有与v连接且未被标记的顶点的边加入横切边 * @param G * @param v */ private void visit(EdgeWeightedGraph G, int v) { marked[v]=true; for (Edge edge:G.adj(v)){ if (!marked[edge.other(v)]){ pq.insert(edge); } } } /** * 返回最小生成树的所有边 * @return */ public Iterable&lt;Edge&gt; edges(){ return mst; } /** * 最小生成树的权重和 * @return */ public double weight(){ double weight=0; for (Edge edge:mst){ weight+=edge.weight(); } return weight; }} Prim算法的延时实现（V个顶点E条边）所需空间与E成正比，所需时间与ElogE成正比（最坏情况） 1.4 Prim算法的即时实现对于上面的延时实现，我们发现优先队列中存在大量失效的边，如果我们可以将失效的边从中删除就好了。对于每个非树顶点w，我们不需要保存所有从w到树顶点的边，而只要保存权重最小的那个边就可以了，添加顶点v到树中后，就需要更新权重最小的边，因为可能 v-w 的权重比之前w到另外一个树顶点的边更小。而对于最小权重之外的边，其早晚会失效。 在即时实现中，我们使用edgeTo[v]保存v和树最近的边，用distTo[v]保存该边的权重，distTo[v]应始终保持v到树顶点的最小权重值。另外使用索引优先队列将顶点v作为索引，顶点v到树顶点最小的边权重distTo[v]作为索引关联的值（索引优先队列即按该权重进行排序）（索引优先队列参考 算法4》索引优先队列笔记—–java实现一文） 如下： 123456789101112131415161718192021222324252627282930313233343536373839public class PrimMST { /** * edgeTo[v] 顶点v距离树最近的边 */ private Edge[] edgeTo; /** * distTo[v] 保存顶点v到树顶点最小边的权重 */ private double[] distTo; private boolean[] marked; private double weight=0.0; /** * 有效的横切边：索引优先队列，顶点v作为索引，disTo[v]作为索引关联的值 */ private IndexMinPQ&lt;Double&gt;pq; public PrimMST(EdgeWeightedGraph G){ edgeTo=new Edge[G.V()]; distTo=new double[G.V()]; marked=new boolean[G.V()]; for (int v = 0; v &lt; G.V(); v++) { //初始化为无穷大 distTo[v]=Double.POSITIVE_INFINITY; } pq=new IndexMinPQ&lt;&gt;(G.V()); //如果是连通的，则直接走prim()，这个循环不需要加 for (int v = 0; v &lt; G.V(); v++) { if (!marked[v]){ prim(G,v); } } }} 举例说明（仍使用上面的图）：如下图，以0为起点，此时我们将连接0和非树节点的边加入索引优先队列，edgeTo和distTo的状态为： 12345 edgeTo[] distTo[]2 0-2 0.264 0-4 0.386 0-6 0.587 0-7 0.16 索引优先队列为： 12345index Key 7 0.16 2 0.26 4 0.38 6 0.58 接着从索引优先队列取出第一个索引7，然后更新edgeTo和distTo： 1234567 edgeTo[] distTo[]1 7-1 0.19 2 0-2 0.26 因为边7-2的权重大于边0-2的0.26 因此不需要更新索引优先队列中索引为2的关联的对象4 7-4 0.37 因为边7-4的权重小于边0-4的0.38 因此需要更新索引优先队列中索引为4的关联的对象5 7-5 0.286 0-6 0.587 0-7 0.16 队列中的状态： 123456index Key 1 0.19 2 0.26 //新的权重()比0.26大，所以不做更新 4 0.37 //由原来的0.38更新为较小的0.37 5 0.28 6 0.58 到此就可以看到，索引优先队列中保存的永远是顶点v距离树最近的边（每加入一个顶点到树中就做更新），而不像上面延时版本一样保存了所有的边，这样直到队列为空，便可以得到一颗最小生成树。 实现如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192public class PrimMST { /** * edgeTo[v] 顶点v距离树最近的边 */ private Edge[] edgeTo; /** * distTo[v] 保存顶点v到树顶点最小边的权重 */ private double[] distTo; private boolean[] marked; /** * 最小生成树的权重 */ private double weight=0.0; /** * 有效的横切边：索引优先队列，顶点v作为索引，disTo[v]作为索引关联的值 */ private IndexMinPQ&lt;Double&gt;pq; public PrimMST(EdgeWeightedGraph G){ edgeTo=new Edge[G.V()]; distTo=new double[G.V()]; marked=new boolean[G.V()]; for (int v = 0; v &lt; G.V(); v++) { //初始化为无穷大 distTo[v]=Double.POSITIVE_INFINITY; } pq=new IndexMinPQ&lt;&gt;(G.V()); //如果是连通的，则直接走prim()，这个循环不需要加 for (int v = 0; v &lt; G.V(); v++) { if (!marked[v]){ prim(G,v); } } check(G); } private void prim(EdgeWeightedGraph G,int v) { distTo[v]=0.0; //将当前顶点作为索引，当前顶点距离树权重最小的边的权重作为关联的key加入索引优先队列 pq.insert(v,distTo[v]); while (!pq.isEmpty()){ //取出权重最小的索引（顶点） int w = pq.delMin(); visit(G,w); } } private void visit(EdgeWeightedGraph G, int v) { marked[v]=true; weight+=distTo[v]; for (Edge e:G.adj(v)){ int w=e.other(v); if (marked[w]){ continue; } if (e.weight()&lt;distTo[w]){//只有当新的边的权重小于之前的distTo[w]值的时候，才更新值 edgeTo[w]=e; distTo[w]=e.weight(); if (pq.contains(w)){ //索引优先队列有这个索引，更新对应的权重值 pq.changeKey(w,distTo[w]); }else {//否则插入新的 pq.insert(w,distTo[w]); } } } } public Iterable&lt;Edge&gt; edges(){ Queue&lt;Edge&gt; mst = new Queue&lt;Edge&gt;(); for (int v = 0; v &lt; edgeTo.length; v++) { Edge e = edgeTo[v]; if (e != null) { mst.enqueue(e); } } return mst; } public double weight(){ return weight; } } 二、Kruskal法Kruskal算法的思想是：按照边的权重从小到大的顺序处理它们，每次将权重最小的边加入树中，新加入的边不会与已经加入的边构成环，直到树中有V-1条边为止。是从边出发。 该算法的实现有两个关键：1. 需要将所有边按权重大小排序，这样每次才能取出权重最小的一条边，实现此需要用到前面的优先队列（小顶堆）2. 为了避免形成环，我们需要借助前面讲过的并查集判断树加入新取出的边后是否有环，即如果该边的两个顶点属于同一个属性集，则会形成环；否则将该边加入生成树，并将边的两个顶点连接 依然以上面的图为例： 一开始每个顶点都属于单独的分量 1.先选择权重最小的边 0-7，将0和7两个顶点使用union(0,7)连接，此时0和7在一个分量中2.选取下一个最小边2-3，将2-3加入生成树，并用union连接，此时2和3在一个分量中3.选取1-7加入生成树，连接1和7，此时1加入7所在的分量3.选取0-2加入生成树，连接0和2，此时2和3加入0所在分量4.这时边 1-3 ， 1-2 和 7-2 失效，因为这任意一条边连接都构成了环（任意一条边两个顶点都在同一个分量中），只能选取下一个权重最小边5-7然后是5-4和2-6，最终得到一个最小生成树： 实现如下：关于并查集的实现可以看前面的文章：《算法第四版》—union-find并查集笔记 12345678910111213141516171819202122232425262728293031323334353637383940414243444546public class KruskalMST { /** * 最小生成树权重 */ private double weight=0.0; /** * 最小生成树所有边 */ private Queue&lt;Edge&gt; mst; public KruskalMST(EdgeWeightedGraph G){ mst=new Queue&lt;&gt;(); //创建一个优先队列 BinaryHeap&lt;Edge&gt; pq= new BinaryHeap&lt;&gt;(); for (Edge e: G.edges()){ //将所有边加入队列中，按权重大小从小到大排序 pq.insert(e); } //创建一个并查集 ComPathWeightedQuickUnionFind uf=new ComPathWeightedQuickUnionFind(G.V()); //队列非空且边的个数小于顶点数-1时循环 while (!pq.isEmpty() &amp;&amp; mst.size()&lt;G.V()-1){ //得到权重最小的边 Edge edge = pq.deleteMin(); int v=edge.either(),w=edge.other(v); if (uf.connected(v,w)){ //忽略失效的边 continue; } uf.union(v,w);//合并分量 mst.enqueue(edge);//加入生成树 weight+=edge.weight(); } } public Iterable&lt;Edge&gt; edges(){ return mst; } public double weight(){ return weight; }}","link":"/posts/20200310-prim-kruskal.html"},{"title":"《算法4》无向图和有向图的有关问题详解（DFS,BFS,环,拓扑排序,连通性和强连通性）","text":"本文仅作为《算法》第四版图的相关知识的个人笔记。 几个概念：1.连通图：从任意一个顶点都存在一条路径到达另一个任意顶点。非连通图由若干连通图组成，都是极大连通子图。2.树是一个无环连通图。连通图的生成树是其一个子图，拥有图的所有顶点。3.二分图一种能够将所有节点分为两部分的图。简单的说，如果按双色上色，二分图的任意两个相邻的顶点的颜色不同。 两个顶点通过一条边连接，称为相邻的。顶点的度数为与他相连的边的总数。有向图中的度数分为入度和出度，入度为指向该顶点的边的总数，出度为从该顶点指出的边的总数。 自环：一条连接顶点和其自身的边 一对顶点的两条边称为平行边。 PartOne:无向图相关算法一、无向图1.1 数据结构123456789101112/** * 顶点数目 */ private final int V; /** * 边的数目 */ private int E; /** * 邻接表，Bag为背包，为一个只入不出的队列，adj[v]即表示与顶点v相连的顶点，因此相邻的两个顶点v和w分别会出现在对方的邻接表中 */ private Bag&lt;Integer&gt;[] adj; 1.2 构造12345678public Graph(int v) { V = v; this.E=0; adj=new Bag[V]; for (int i = 0; i &lt; V; i++) { adj[i]=new Bag&lt;&gt;(); } } 1.3 相关方法两顶点是否相邻： 123456789public boolean hasEdge(int v,int w){ //遍历顶点v的邻接表，查找有无顶点w for(int x:adj(v)){ if (x==w){ return true; } } return false; } 添加一条边： 12345678public void addEdge(int v,int w){ //也可以通过判断v==w和hasEdge(v,w)决定是否允许自环和平行边 adj[v].add(w); adj[w].add(v); E++; } 12345678910111213141516171819202122232425262728293031//顶点度数 public int degree(int v){ int degree=0; for (int w:adj(v)){ degree++; } return degree; } //最大度数 public int maxDegree(){ int max=0; for (int v = 0; v &lt; V; v++) { int degree = degree(v); if (degree&gt;max){ max=degree; } } return max; } //自环数 public int numOfSelfLoops(Graph graph){ int loops=0; for (int i = 0; i &lt; graph.V(); i++) { for(int w:graph.adj(i)){ if (w==i){ loops++; } } } return loops/2; } 二、深度优先搜索简单的说就是 从给定顶点出发，一直向下走，直到下面没有路了，然后返回上一个顶点，继续进行同样方式遍历，直到遍历完所有的顶点。 因此我们需要如下的数据结构： 1234567891011121314/** * 标记顶点i是否被访问 */ private boolean[] marked; /** * 从起点到一个顶点的已知路径上的最后一个顶点 * 如 v-&gt;w-&gt;x 则edgeTo[w]=v,edgeTo[x]=w */ private int[] edgeTo; /** * 遍历的起点 */ private final int s; 构造函数： 1234567public DepthFirstPaths(Graph G, int s) { this.s = s; //初始化两个数组 edgeTo = new int[G.V()]; marked = new boolean[G.V()]; dfs(G, s); } 深度优先遍历： 1234567891011121314private void dfs(Graph G, int v) { //标记当前顶点为true marked[v] = true; //遍历与当前顶点相邻的顶点 for (int w : G.adj(v)) { //如果没有被访问 if (!marked[w]) { //标记起点到当前顶点的最后一个路径 edgeTo[w] = v; //从当前节点继续进行遍历 dfs(G, w); } } } 是否存在从起点到指定顶点的路径： 1234public boolean hasPathTo(int v) { validateVertex(v); return marked[v]; } 返回从起点到指定顶点的路径，如果不存在返回null： 1234567891011121314public Iterable&lt;Integer&gt; pathTo(int v) { if (!hasPathTo(v)){ //没有到达路径，返回null return null; } //因为edgeTo保存的是到达当前节点的父节点，因此使用栈结构，这样从当前节点到起始顶点的顶点依此入栈，遍历的时候便是从起点到该顶点的完整路径 Stack paths=new Stack(); for (int i = v; i !=s ; i=edgeTo[i]) { paths.push(i); } paths.push(s); return paths; } 测试： 12345678910111213141516public static void main(String[] args) { Graph graph=new Graph(6); graph.addEdge(0,2); graph.addEdge(0,1); graph.addEdge(0,5); graph.addEdge(2,1); graph.addEdge(2,3); graph.addEdge(2,4); graph.addEdge(3,5); graph.addEdge(3,4); DepthFirstPaths dfs=new DepthFirstPaths(graph,0); Iterable&lt;Integer&gt; paths = dfs.pathTo(4); for (Integer i:paths){ System.out.println(i.toString()); } } 结果： 12340534 三、广度优先搜索：广度优先搜索的思想是，从当前节点，先遍历与该节点相邻的所有节点，然后再对相邻顶点进行广度优先遍历。深度优先是纵向遍历，广度优先是横向遍历。 数据结构：广度优先搜索的数据结构同深度基本一样： 123456789101112public class BreadthFirstPaths { private final int start; private int[] edgeTo; private boolean[] marked; public BreadthFirstPaths(Graph graph,int start) { this.start = start; edgeTo=new int[graph.V()]; marked=new boolean[graph.V()]; bfs(graph,start); }} 但在遍历的时候采用队列进行辅助，思想如下：1.将当前顶点加入队列2.从出队出队一个顶点（第一次时出队的就是当前节点），遍历该顶点的所有相邻顶点，置marked[v]为true，并依此入队。3.当队列非空时，循环步骤2 代码如下： 12345678910111213private void bfs(Graph graph, int start) { Queue&lt;Integer&gt; queue=new Queue&lt;&gt;(); queue.enqueue(start); marked[start]=true; while (!queue.isEmpty()){ int v = queue.dequeue(); for (int w:graph.adj(v)){ queue.enqueue(w); edgeTo[w]=v; marked[w]=true; } } } 四、连通分量数据结构如下： 12345678910111213141516public class CC { private boolean[] marked; /** * 顶点属于哪个连通分量 如 顶点v属于第count个连通分量，则id[v]=count */ private int[] id; /** * 第count个连通分量的顶点数 */ private int[] size; /** * 连通分量数 */ private int count; } 思想如下：遍历所有的顶点，对每个顶点都执行dfs深度优先遍历，如果两个顶点在同一个连通分量，那么在对一个顶点进行dfs遍历的时候，两个顶点必然会在构造函数的一个dfs中被访问到，属于同一个连通分量。构造函数： 12345678910111213141516171819202122232425public CC(Graph G) { marked = new boolean[G.V()]; id = new int[G.V()]; size = new int[G.V()]; //代码1 for (int v = 0; v &lt; G.V(); v++) { if (!marked[v]) { dfs(G, v); //与顶点v连通的所有顶点都遍历完毕后，说明该连通分量所有顶点已遍历完毕，增加count count++; } } } private void dfs(Graph G, int v) { marked[v] = true; //顶点v属于第count个分量 id[v] = count; //第count个分量的顶点数加1 size[count]++; for (int w : G.adj(v)) { if (!marked[w]) { dfs(G, w); } } } 五、判断是否为无环图对于无向图而言，判断其是否为无环图很简单，在对某个顶点进行dfs遍历时，假如它的相邻顶点已被访问过，那么有两种可能：以 3-4-5-3为例 每次dfs都传递要遍历的节点，和当前刚刚被遍历过的节点一开始三个顶点都未被访问1.现在对3进行dfs，访问到5,5被标记为true；2.再对5进行dfs，此时3已经被访问，但是此时的3属于顶点5的父级，不构成环，再访问4，标记4为true；3.接着对4进行dfs，此时顶点5被访问，同2一样，顶点5属于顶点4的“父级”，不构成环，但是3也被访问了，且3不是顶点4的“父级”，因此此处出现环。关键代码如下： 12345678910111213141516171819202122private boolean[] marked; private boolean hasCycle; public Cycle(Graph G) { marked=new boolean[G.V()]; for (int i = 0; i &lt; G.V(); i++) { if (!marked[i]){ dfs(G,i,i); } } } private void dfs(Graph G,int v, int u){ marked[v]=true; for(int w:G.adj(v)){ if (!marked[w]){ dfs(G,w,v); }else if (w!=u){//如 3:5 5:3 就不构成环 hasCycle=true; } } } 六、二分图问题这个同无环图问题类型，在对一个顶点进行dfs遍历时，将其未被访问的临接顶点置为与该顶点对立的颜色，若已经被访问，则判断该顶点的颜色与当前顶点的颜色是否不一样，如果一样，则不是二分图。 关键代码如下： 123456789101112private void dfs(Graph graph, int v) { marked[v]=true; for (int w: graph.adj(v)){ if (!marked[w]){ color[w]=!color[v]; dfs(graph,w); }else if (color[w]==color[v]){ isTwoColorable=false; break; } } } PartTwo:有向图相关算法有向图的定义和无向图基本一样，这里也是基于临接表实现，但在插入边的时候，有向图只需要操作边的始点的邻接表，不需像无向图一样两个顶点的邻接表都插入对应的顶点。 123456789101112131415161718192021222324252627282930313233343536373839public class Digraph { private final int V; private int E; private Bag&lt;Integer&gt;[] adj; public Digraph(int v) { V = v; this.E=0; adj=new Bag[V]; for (int i = 0; i &lt; v; i++) { adj[i]=new Bag&lt;&gt;(); } } public int V(){ return V; } public int E(){ return E; } public void addEdge(int v,int w){ adj[v].add(w); E++; } public Iterable&lt;Integer&gt; adj(int v){ return adj[v]; } /** * 获取当前有向图的反转图 */ public Digraph reverse(){ Digraph R=new Digraph(V); for (int v = 0; v &lt; V; v++) { for (int w: adj(v)){ R.addEdge(w,v); } } return R; }} 一、有向图的可达性：这里同无向图一样，只需将Graph换为Digraph即可：进行DFS遍历: 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758public class DirectedDFS { private boolean[] marked; /** * 单点可达性 * 经过此方法，从marked(int v)返回是否存在一条从s到达给定顶点v的有向路径 * @param digraph * @param s */ public DirectedDFS(Digraph digraph,int s) { marked=new boolean[digraph.V()]; dfs(digraph,s); } /** * 多点可达性 * 是否存在一条从集合中的任意顶点到达给定顶点v的有向路径 * @param digraph * @param sources */ public DirectedDFS(Digraph digraph,Iterable&lt;Integer&gt; sources) { marked=new boolean[digraph.V()]; for (int s:sources){ if (!marked[s]){ dfs(digraph,s); } } } private void dfs(Digraph digraph, int v) { marked[v]=true; for (int w:digraph.adj(v)){ if (!marked[w]){ dfs(digraph,w); } } } public boolean marked(int v){ return marked[v]; } public static void main(String[] args) { Digraph graph=new Digraph(6); graph.addEdge(0,2); graph.addEdge(0,1); graph.addEdge(0,5); graph.addEdge(2,1); graph.addEdge(2,3); graph.addEdge(4,5); DirectedDFS dfs=new DirectedDFS(graph,0); System.out.println(dfs.marked(3)); }} 顶点对的可达性借助DirectedDFS数组，我们可以实现顶点对的可达性：无论对于稀疏还是稠密的图，它都是理想的解决方案，但不适用于实际应用中的大型有向图，因为构造函数所需的空间和V²成正比，所需时间和V（V+E）成正比 1234567891011121314151617181920public class TransitiveClosure { private DirectedDFS[] directedDFS; // tc[v] = reachable from v /** * 构造函数 * 所需空间与V²成正比 * 所需时间与 V(V+E)成正比 * @param G */ public TransitiveClosure(Digraph G) { directedDFS = new DirectedDFS[G.V()]; for (int v = 0; v &lt; G.V(); v++) directedDFS[v] = new DirectedDFS(G, v); } boolean reachable(int v,int w){ return directedDFS[v].marked(w); }} 二、单点有向路径和单点最短有向路径同无向图一样，单点有向路径就是借助DFS，对从s到v路径上的每一个顶点，使用edgeTo数组保存从s到该顶点的路径上的最后一个顶点坐标；而单点最短路径就是以同样的方式借助BFS保存从s到指定顶点的路径，这样得出的路径就是到达该顶点的最短路径。 三、环和无环图（拓扑排序）在调度问题中，限制条件是这些任务的执行方法和起始时间，但最重要的限制条件叫做有限制级限制，它指明了任务间执行的先后顺序。 我们需要在一个有优先级限制的任务中，按该限制条件找出安排完成任务的顺序。这也等价于一个基本问题：拓扑排序，即在一个有向图中，将所有顶点排序，满足所有的有向边均从排在前面的元素指向排在后面的元素（或指出无法做到这一点）。 以高校课程安排为例，一些课程的开课必须要求学生修完前面的某些课，而拓扑排序就是在这种限制条件下，找出学生选修课程的顺序。 而一旦一个优先级限制的问题中存在有向环，那么这个问题一定是无解的。因此我们需要进行有向环的检测。有向无环图就是不含有有向环的有向图 检测有向环的思路如下：对有向图的每个顶点都进行DFS遍历，假设从顶点v开始深度优先遍历，将从该顶点递归调用路径上的所有顶点marked标记后再使用一个boolean[] onStack标记是否在递归栈上，如果对一个顶点的DFS递归调用没有发现有向环，则递归结束前再让该节点的onStack状态改为false；而如果对某个顶点的递归调用时发现另一个顶点已经被标记了，且onStack为true，则说明这个路径上一定存在有向环，这时将该环上的所有点加入Stack cycle栈中。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859public class DirectedCycle { private boolean[]marked; private int[] edgeTo; /** * 有向环中的所有顶点（如果存在） */ private Stack&lt;Integer&gt;cycle; /** * 递归调用的栈上的所有顶点 */ private boolean[] onStack; public DirectedCycle(Digraph digraph) { marked=new boolean[digraph.V()]; edgeTo=new int[digraph.V()]; onStack=new boolean[digraph.V()]; for (int v = 0; v &lt; digraph.V(); v++) { if (!marked[v]){ dfs(digraph,v); } } } /** * 使用不带权的Digraph * @param digraph * @param v */ private void dfs(Digraph digraph, int v) { onStack[v]=true; marked[v]=true; for (int w: digraph.adj(v)){ if (this.hasCycle()){ //如果已经找到有向环，则返回 return; } else if (!marked[w]){ edgeTo[w]=v; dfs(digraph,w); }else if (onStack[w]){ cycle=new Stack&lt;&gt;(); for (int x = v; x != w; x=edgeTo[x]) { cycle.push(x); } cycle.push(w); cycle.push(v); } } //对v的一次递归调用后，如果没发现环，则重置为false onStack[v]=false; } public Iterable&lt;Integer&gt;cycle(){ return cycle; } public boolean hasCycle(){ return cycle!=null; }} 测试： 12345678910111213141516public static void main(String[] args) { Digraph digraph=new Digraph(4); digraph.addEdge(0,1); digraph.addEdge(2,3); digraph.addEdge(3,1); digraph.addEdge(1,2); //存在环3&gt;1-&gt;2&gt;3 DirectedCycle cycle = new DirectedCycle(digraph); if (cycle.hasCycle()){ System.out.println(\"存在环\"); Stack&lt;Integer&gt; stack = cycle.cycle; while (!stack.isEmpty()){ System.out.println(stack.pop()); } } } 结果： 12345存在环3123 《算法4》中给出： 一幅有向无环图的拓扑排序就是所有顶点的逆后排序 那么什么是逆后排序呢？我们规定：前序： 在对顶点v递归调用前就将该顶点加入队列，最后出队的顺序就是前序后序：在对顶点v递归调用后将该顶点加入队列，最后出队的顺序就是后序逆后序：在对顶点v递归调用后将该顶点加入栈中，最后出栈的顺序就是逆后序 实现如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061/** * 有向图中基于深度优先搜索的顶点排序 * @author MaoLin Wang * @date 2020/2/2214:55 */public class DepthFirstOrder { private boolean[]marked; /** * 所有顶点的前序遍历(递归调用前加入队列) */ private Queue&lt;Integer&gt; pre; /** * 所有顶点的后序遍历(递归调用后加入队列) */ private Queue&lt;Integer&gt; post; /** * 所有顶点的逆后序遍历(递归调用后压入栈) */ private Stack&lt;Integer&gt; reversePost; public DepthFirstOrder(Digraph digraph) { pre=new Queue&lt;&gt;(); post=new Queue&lt;&gt;(); reversePost=new Stack&lt;&gt;(); marked=new boolean[digraph.V()]; for (int v = 0; v &lt; digraph.V(); v++) { if (!marked[v]){ dfs(digraph,v); } } } private void dfs(Digraph digraph, int v) { System.out.println(\"dfs(\"+v+\")\"); pre.enqueue(v); marked[v]=true; for (int w: digraph.adj(v)){ if (!marked[w]){ dfs(digraph,w); } } System.out.println(v+\"完成\"); post.enqueue(v); reversePost.push(v); } public Iterable&lt;Integer&gt;pre(){ return pre; } public Queue&lt;Integer&gt;post(){ return post; } public Iterable&lt;Integer&gt;reversePost(){ return reversePost; }} 我们先测试一下一张有向无环图的各个排序的顺序： 12345678910111213141516171819202122public static void main(String[] args) { Digraph digraph = new Digraph(13); digraph.addEdge(0,5); digraph.addEdge(0,1); digraph.addEdge(0,6); digraph.addEdge(2,0); digraph.addEdge(2,3); digraph.addEdge(3,5); digraph.addEdge(5,4); digraph.addEdge(6,4); digraph.addEdge(6,9); digraph.addEdge(7,6); digraph.addEdge(8,7); digraph.addEdge(9,10); digraph.addEdge(9,11); digraph.addEdge(9,12); digraph.addEdge(11,12); DepthFirstOrder depthFirstOrder = new DepthFirstOrder(digraph); Stack&lt;Integer&gt; reversePost = depthFirstOrder.reversePost; } 调用结果及形成的队列如下：边的构造顺序不一样，得到的拓扑排序也会不一样，但是结果一定是满足拓扑排序优先级限制的。 123456789101112131415161718192021222324252627 pre post reversePostdfs(0) 0 dfs(6) 0 6 dfs(9) 0 6 9 dfs(12) 0 6 9 12 12完成 12 12 dfs(11) 0 6 9 12 11 11完成 12 11 11 12 dfs(10)0 6 9 12 11 10 10完成 12 11 10 10 11 12 9完成 12 11 10 9 9 10 11 12 dfs(4) 0 6 9 12 11 10 4 4完成 12 11 10 9 4 4 9 10 11 12 6完成 12 11 10 9 4 6 6 4 9 10 11 12dfs(1) 0 6 9 12 11 10 4 1 1完成 12 11 10 9 4 6 1 1 6 4 9 10 11 12dfs(5) 0 6 9 12 11 10 4 1 55完成 12,11,10,9,4,6,1,5 5 1 6 4 9 10 11 120完成 12,11,10,9,4,6,1,5,0 0,5,1,6,4,9,10,11,12dfs(2) 0,6,9,12,11,10,4,1,5,2 dfs(3) 0,6,9,12,11,10,4,1,5,2,3 3完成 12,11,10,9,4,6,1,5,0,3 3,0,5,1,6,4,9,10,11,122完成 12,11,10,9,4,6,1,5,0,3,2 2,3,0,5,1,6,4,9,10,11,12dfs(7) 0,6,9,12,11,10,4,1,5,2,3,77完成 12,11,10,9,4,6,1,5,0,3,2,7 7,2,3,0,5,1,6,4,9,10,11,12dfs(8)8完成 12,11,10,9,4,6,1,5,0,3,2,7,8 8,7,2,3,0,5,1,6,4,9,10,11,12 我们发现其逆后序就是我们要的拓扑排序，那么为什么逆后序就是拓扑排序呢？ 对于任意边v-&gt;w，调用dfs(v)时，一定会出现以下三种情况之一：1.dfs（w）已调用过，且已经结束（w被标记过了）2.dfs（w）未被调用（w没被标记），因此dfs（v）时会调用dfs（w），且dfs(w)会在dfs(v)之前返回3.dfs（w）被调用过了，且没有返回。这个就是有有向环时会出现的情况，但进行拓扑排序的前提的没有有向环，因为该情况不会出现。因此 情况1和2都是w在v之前结束调用，则w在后序排序中，一定在v之前，相反，在逆后序中，w一定在v之后，因此对于任意v-&gt;w都是排名较前点指向排名较后的点。 这样我们就可以得到拓扑排序的实现： 1234567891011121314151617181920212223public class TopologicalSort { //顶点的拓扑排序 private Iterable&lt;Integer&gt;order; public TopologicalSort(Digraph digraph) { DirectedCycle directedCycle=new DirectedCycle(digraph); //排序前进行有向环检测，没有环才可以进行拓扑排序 if (!directedCycle.hasCycle()){ //返回拓扑排序 DepthFirstOrder dfs=new DepthFirstOrder(digraph); order=dfs.reversePost(); } } public Iterable&lt;Integer&gt;order(){ return order; } public boolean hasOrder(){ return order!=null; }} 四、有向图的强连通性定义：如果两个顶点是互相可达的，则称是强连通的。如果一个有向图的任意两个顶点都是强连通的，则该有向图是强连通的。有向图的极大强连通子图，称为强连通分量(strongly connected components)。如下：每个颜色代表一个强联通分量。计算强连通分量的最常用的方法是Kosaraju算法：其思想是：1.使用DFS查找给定有向图G的反向图G^R2.根据反向图G^R求得其逆后序列3.对2求得的逆后序进行DFS遍历，访问未被标记的点4.在构造函数中，所有在同一个dfs调用中被访问的顶点都在同一个强连通分量中，按无向图中求连通分量的方法求强连通分量。 有关该思想的证明如下：我们只要证明以下两个问题即可：（树上的证明猛一看可能看的不太懂，下面用自己的理解讲的细一点）==1.每个和s强连通的顶点v都会在构造函数调用的dfs(G,s)中被访问到2.构造函数调用的dfs(G,s)所到达的任意顶点v都必然是和s强连通的。== 对命题1，我们使用反证法：1.假设一个和s强连通的顶点v在dfs(G,s)的调用中没有被访问到2.由于存在一条从s-&gt;v的路径，所以如果顶点v没有在dfs(G,s)中被访问，就一定在之前调用了dfs(G,v)，并且访问到了v。3.又因为s和v是强连通的，所以也存在v-&gt;s的路径，在dfs(G,v)中，s一定会被标记，而s被标记，就一定不会再次进行dfs(G,s)的调用，矛盾，因此命题1成立。 对命题2：1.要证明s和任意顶点v强连通，只要证明s-&gt;v且v-&gt;s，因为v是dfs(G,s)调用中访问到的任意顶点，所以一定存在s-&gt;v，接下来只要证明存在v-&gt;s即可。2.要证明存在v-&gt;s，就相当于证明反向图中存在s1-&gt;v1如下：因为我们是按照逆后序进行深度优先遍历的，按照逆序，我们是在dfs(G,s)的调用中调用dfs(G,v)，即先访问s再访问v，所以在反向图GR中，我们就应该是先访问v再访问s，对应上图GR中的点就是，先访问s1再访问v1。即只要证明dfs(G,v1)在dfs（G,s1）之前结束，则这样就有如下两个情况： 1. dfs（G，v1）在调用dfs(G,s1)之前，且在dfs（G，s1）的调用开始前结束。2. dfs（G，v1）在调用dfs（G,s1）之后，且在dfs（G,s1）的调用结束前结束。 如果出现情况1，这显然不可能，因为如果v1在s1之前就结束了，那么得出的逆后序应该是s1,v1，对应G中的v和s，先调用v再调用s，但是显然G是先调用s再调用v，所以该情况不存在。如果是情况2，则说明存在一条路径s1&gt;v1，即原图G中存在一条路径v-&gt;s，命题2正确。 下面是Kosaraju算法的实现： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051/** * 计算强连通分量的Kosaraju算法 * @author MaoLin Wang * @date 2020/2/2216:54 */public class KosarajuSCC { private boolean[] marked; /** * 强连通分量的标识符 */ private int[] id; /** * 强连通分量个数 */ private int count; public KosarajuSCC(Digraph digraph){ marked=new boolean[digraph.V()]; id=new int[digraph.V()]; //求反向图的逆后序 DepthFirstOrder order=new DepthFirstOrder(digraph.reverse()); //对逆后序进行dfs遍历 for(int s: order.reversePost()){ if (!marked[s]){ dfs(digraph,s); count++; } } } private void dfs(Digraph digraph, int v) { marked[v]=true; //顶点v属于第count个强连通分量 id[v]=count; for (int w: digraph.adj(v)){ if (!marked[w]){ dfs(digraph,w); } } } /*v和w是否强连通*/ public boolean stronglyConnected(int v,int w){ return id[v]==id[w]; } public int id(int v){ return id[v]; } public int count(){ return count; }}","link":"/posts/20200310-graphDetails.html"}],"tags":[{"name":"elasticsearch","slug":"elasticsearch","link":"/tags/elasticsearch/"},{"name":"docker","slug":"docker","link":"/tags/docker/"},{"name":"centos7","slug":"centos7","link":"/tags/centos7/"},{"name":"firewall","slug":"firewall","link":"/tags/firewall/"},{"name":"linux","slug":"linux","link":"/tags/linux/"},{"name":"gulp,压缩静态资源","slug":"gulp-压缩静态资源","link":"/tags/gulp-%E5%8E%8B%E7%BC%A9%E9%9D%99%E6%80%81%E8%B5%84%E6%BA%90/"},{"name":"jib","slug":"jib","link":"/tags/jib/"},{"name":"文件上传","slug":"文件上传","link":"/tags/%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0/"},{"name":"fdfs","slug":"fdfs","link":"/tags/fdfs/"},{"name":"排序","slug":"排序","link":"/tags/%E6%8E%92%E5%BA%8F/"},{"name":"数据结构","slug":"数据结构","link":"/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"二叉树","slug":"二叉树","link":"/tags/%E4%BA%8C%E5%8F%89%E6%A0%91/"},{"name":"调度算法","slug":"调度算法","link":"/tags/%E8%B0%83%E5%BA%A6%E7%AE%97%E6%B3%95/"},{"name":"分治","slug":"分治","link":"/tags/%E5%88%86%E6%B2%BB/"},{"name":"并发编程","slug":"并发编程","link":"/tags/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"},{"name":"fork/join","slug":"fork-join","link":"/tags/fork-join/"},{"name":"CountDownLatch","slug":"CountDownLatch","link":"/tags/CountDownLatch/"},{"name":"CyclicBarrier","slug":"CyclicBarrier","link":"/tags/CyclicBarrier/"},{"name":"Semaphore","slug":"Semaphore","link":"/tags/Semaphore/"},{"name":"Runnable","slug":"Runnable","link":"/tags/Runnable/"},{"name":"Callable","slug":"Callable","link":"/tags/Callable/"},{"name":"Future","slug":"Future","link":"/tags/Future/"},{"name":"FutureTask","slug":"FutureTask","link":"/tags/FutureTask/"},{"name":"多线程","slug":"多线程","link":"/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"},{"name":"CAS","slug":"CAS","link":"/tags/CAS/"},{"name":"原子操作类","slug":"原子操作类","link":"/tags/%E5%8E%9F%E5%AD%90%E6%93%8D%E4%BD%9C%E7%B1%BB/"},{"name":"AtomicXXX","slug":"AtomicXXX","link":"/tags/AtomicXXX/"},{"name":"AQS","slug":"AQS","link":"/tags/AQS/"},{"name":"显示锁Lock","slug":"显示锁Lock","link":"/tags/%E6%98%BE%E7%A4%BA%E9%94%81Lock/"},{"name":"LockSupport","slug":"LockSupport","link":"/tags/LockSupport/"},{"name":"ReentrantLock","slug":"ReentrantLock","link":"/tags/ReentrantLock/"},{"name":"ReentrantReadWriteLock","slug":"ReentrantReadWriteLock","link":"/tags/ReentrantReadWriteLock/"},{"name":"读写锁","slug":"读写锁","link":"/tags/%E8%AF%BB%E5%86%99%E9%94%81/"},{"name":"BST","slug":"BST","link":"/tags/BST/"},{"name":"二叉查找树","slug":"二叉查找树","link":"/tags/%E4%BA%8C%E5%8F%89%E6%9F%A5%E6%89%BE%E6%A0%91/"},{"name":"AVL","slug":"AVL","link":"/tags/AVL/"},{"name":"平衡树","slug":"平衡树","link":"/tags/%E5%B9%B3%E8%A1%A1%E6%A0%91/"},{"name":"散列表","slug":"散列表","link":"/tags/%E6%95%A3%E5%88%97%E8%A1%A8/"},{"name":"索引优先队列","slug":"索引优先队列","link":"/tags/%E7%B4%A2%E5%BC%95%E4%BC%98%E5%85%88%E9%98%9F%E5%88%97/"},{"name":"优先队列","slug":"优先队列","link":"/tags/%E4%BC%98%E5%85%88%E9%98%9F%E5%88%97/"},{"name":"IndexPQ","slug":"IndexPQ","link":"/tags/IndexPQ/"},{"name":"数据结构与算法","slug":"数据结构与算法","link":"/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"},{"name":"union-find","slug":"union-find","link":"/tags/union-find/"},{"name":"并查集","slug":"并查集","link":"/tags/%E5%B9%B6%E6%9F%A5%E9%9B%86/"},{"name":"路径压缩","slug":"路径压缩","link":"/tags/%E8%B7%AF%E5%BE%84%E5%8E%8B%E7%BC%A9/"},{"name":"查找","slug":"查找","link":"/tags/%E6%9F%A5%E6%89%BE/"},{"name":"堆","slug":"堆","link":"/tags/%E5%A0%86/"},{"name":"堆排序","slug":"堆排序","link":"/tags/%E5%A0%86%E6%8E%92%E5%BA%8F/"},{"name":"PriorityQueue","slug":"PriorityQueue","link":"/tags/PriorityQueue/"},{"name":"最短路径","slug":"最短路径","link":"/tags/%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84/"},{"name":"Dijkstra","slug":"Dijkstra","link":"/tags/Dijkstra/"},{"name":"红黑树","slug":"红黑树","link":"/tags/%E7%BA%A2%E9%BB%91%E6%A0%91/"},{"name":"最小生成树","slug":"最小生成树","link":"/tags/%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91/"},{"name":"prim","slug":"prim","link":"/tags/prim/"},{"name":"kruskal","slug":"kruskal","link":"/tags/kruskal/"},{"name":"图","slug":"图","link":"/tags/%E5%9B%BE/"},{"name":"dfs","slug":"dfs","link":"/tags/dfs/"},{"name":"bfs","slug":"bfs","link":"/tags/bfs/"},{"name":"拓扑排序","slug":"拓扑排序","link":"/tags/%E6%8B%93%E6%89%91%E6%8E%92%E5%BA%8F/"},{"name":"二分图","slug":"二分图","link":"/tags/%E4%BA%8C%E5%88%86%E5%9B%BE/"},{"name":"连通性","slug":"连通性","link":"/tags/%E8%BF%9E%E9%80%9A%E6%80%A7/"}],"categories":[{"name":"docker","slug":"docker","link":"/categories/docker/"},{"name":"linux","slug":"linux","link":"/categories/linux/"},{"name":"工具","slug":"工具","link":"/categories/%E5%B7%A5%E5%85%B7/"},{"name":"springboot","slug":"springboot","link":"/categories/springboot/"},{"name":"数据结构","slug":"数据结构","link":"/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"排序","slug":"数据结构/排序","link":"/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%8E%92%E5%BA%8F/"},{"name":"二叉树","slug":"数据结构/二叉树","link":"/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E4%BA%8C%E5%8F%89%E6%A0%91/"},{"name":"操作系统","slug":"操作系统","link":"/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"},{"name":"并发编程","slug":"并发编程","link":"/categories/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"},{"name":"并发工具类","slug":"并发编程/并发工具类","link":"/categories/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/%E5%B9%B6%E5%8F%91%E5%B7%A5%E5%85%B7%E7%B1%BB/"},{"name":"原子操作CAS","slug":"并发编程/原子操作CAS","link":"/categories/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/%E5%8E%9F%E5%AD%90%E6%93%8D%E4%BD%9CCAS/"},{"name":"显示锁和AQS","slug":"并发编程/显示锁和AQS","link":"/categories/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/%E6%98%BE%E7%A4%BA%E9%94%81%E5%92%8CAQS/"},{"name":"查找","slug":"数据结构/查找","link":"/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%9F%A5%E6%89%BE/"},{"name":"散列表","slug":"数据结构/散列表","link":"/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%95%A3%E5%88%97%E8%A1%A8/"},{"name":"优先队列","slug":"数据结构/优先队列","link":"/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E4%BC%98%E5%85%88%E9%98%9F%E5%88%97/"},{"name":"并查集","slug":"数据结构/并查集","link":"/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E5%B9%B6%E6%9F%A5%E9%9B%86/"},{"name":"图","slug":"数据结构/图","link":"/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E5%9B%BE/"}]}