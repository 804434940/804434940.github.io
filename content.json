{"pages":[{"title":"文章分类","text":"","link":"/categories/index.html"},{"title":"","text":"图片搜集于互联网，侵权请留言，马上处理😊。","link":"/gallery/index.html"},{"title":"相册","text":"","link":"/photo/index.html"},{"title":"标签","text":"","link":"/tags/index.html"}],"posts":[{"title":"docker安装ES","text":"123456789101112131415161718192021222324docker pull elasticsearch:6.4.0 //再低就是5.x了1.vim /etc/security/limits.d/90-nproc.conf 添加：soft nproc 40962. vim /etc/sysctl.conf 添加vm.max_map_count=655360 执行sysctl -p刷新配置//根据自己的内存大小适当调整，太大会启动失败3.docker run -e ES_JAVA_OPTS=\"-Xms512m -Xmx512m\" -d -p 9200:9200 -p 9300:9300 --name=myES 容器id4.docker exec -it 容器名 /bin/bash 进入容器命令行5.vim config/elasticsearch.yml 地址改为0.0.0.0可能会vim不可用 执行 yum update yum install -y vim6.安装ik分词器先上传到宿主机，再使用以下命令copy到容器中docker cp 宿主机ik分词器地址 容器名:/usr/share/elasticsearch/plugins/ik","link":"/posts/20200106-docker_es.html"},{"title":"centos7查看防火墙以及开放和关闭端口","text":"查看某个端口是否开放 1firewall-cmd --query-port=22122/tcp yes/no 开放/未开放 开放指定端口1firewall-cmd --add-port=22122/tcp --permanent firewall-cmd –zone=public –add-port=80/tcp –permanent-zone #作用域-permanent 没有该参数重启后失效 重新加载端口： 1firewall-cmd --reload 3.关闭某个端口 1firewall-cmd --permanent --remove-port=22122/tcp 重新加载 4. 查看防火墙状态 123firewall-cmd --state或者:systemctl status firewalld 打开/关闭防火墙 启动：systemctl start firewalld关闭： systemctl stop firewalld开机启用 ： systemctl enable firewalld禁止firewall开机启动 ：systemctl disable firewalld.service启动服务：systemctl start firewalld.service关闭服务：systemctl stop firewalld.service重启服务：systemctl restart firewalld.service 查看端口占用情况 1netstat -anp 查看防火墙已开放的端口 1firewall-cmd --list-ports","link":"/posts/20200107-centos7_firewall.html"},{"title":"hexo压缩静态资源","text":"1.安装gulp1.1首先全局安装gulp1npm install gulp -g 1.2 再局部安装相关插件1npm install gulp-imagemin gulp gulp-minify-css gulp-minify-html gulp-uglify -- 1234567# 解决【Gulp打包问题】 GulpUglifyError: unable to minify JavaScript# 解决 gulp-uglify 压缩JavaScript 不兼容 es5 语法的问题npm install babel-core@6.26.3 --savenpm install gulp-babel@7.0.1 --savenpm install babel-preset-es2015@6.24.1 --save# gulp-babel 取消严格模式方法(\"use strict\")npm install babel-plugin-transform-remove-strict-mode --save 2.在网站根目录创建gulpfile.js文件，用来配置压缩1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859var gulp = require('gulp');//Plugins模块获取var minifycss = require('gulp-minify-css');var uglify = require('gulp-uglify');var minifyhtml = require('gulp-minify-html');var imagemin = require('gulp-imagemin')var babel = require('gulp-babel');// 压缩 public 目录 css文件gulp.task('minify-css', function () { return gulp.src('./public/**/*.css') .pipe(minifycss()) .pipe(gulp.dest('./public'));});// 压缩 public 目录 html文件gulp.task('minify-html', function () { return gulp.src('./public/**/*.html') .pipe(minifyhtml()) .pipe(gulp.dest('./public'))});// 压缩js文件gulp.task('minify-js', function (done) { return gulp.src(['./public/**/*.js', '!./public/**/*.min.js','!./public/js/src/snow.js']) .pipe(babel({ //将ES6代码转译为可执行的JS代码 presets: [['es2015',{strict:false}]] // es5检查机制 })) .pipe(uglify()) .pipe(gulp.dest('./public')); done();});// 压缩public/posts 目录 图片文件gulp.task('minify-img', function () { return gulp.src(['./public/images/**/*.*','./source/gallery/**']) .pipe(imagemin( [ imagemin.gifsicle({ 'optimizationLevel': 3 }), imagemin.jpegtran({ 'progressive': true }), imagemin.optipng({ 'optimizationLevel': 7 }), imagemin.svgo() ], { 'verbose': true })) .pipe(gulp.dest('./public'))});// 分别执行css、heml、js和图片的压缩任务gulp.task('build', gulp.series('minify-css', 'minify-html', 'minify-js', 'minify-img')); 3.在网站根目录创建.babelrc1234{ 'presets': ['es2015'], \"plugins\": [\"transform-remove-strict-mode\"]} 4.执行压缩1hexo clean&amp;&amp;hexo g &amp;&amp;gulp build 不兼容ES5的解决参考:https://segmentfault.com/a/1190000019842178?utm_source=tag-newest","link":"/posts/20200111-hexo-gulp.html"},{"title":"jib打包项目到阿里镜像","text":"​ Jib 将处理将应用打包到容器镜像过程中的所有步骤，它直接与 Maven 和 Gradle Java 开发环境集成，不需要你编写 Dockerfile 或安装 Docker（但想要运行还是要本地安装docker） ，只需将其作为插件添加到你的构建中，就可以立即将 Java 应用容器化。 图片来源于https://www.oschina.net/news/97892/google-opensource-jib 一、在pom文件中引入jib插件1234567891011121314151617181920212223242526272829303132333435363738394041424344&lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt; &lt;/plugin&gt; &lt;plugin&gt; &lt;groupId&gt;com.google.cloud.tools&lt;/groupId&gt; &lt;artifactId&gt;jib-maven-plugin&lt;/artifactId&gt; &lt;version&gt;1.7.0&lt;/version&gt; &lt;configuration&gt; &lt;!--拉取的镜像的配置，默认为gcr.io/distroless/java--&gt; &lt;from&gt; &lt;image&gt;基础镜像地址&lt;/image&gt; &lt;auth&gt; &lt;username&gt;阿里云用户名&lt;/username&gt; &lt;password&gt;阿里云密码&lt;/password&gt; &lt;/auth&gt; &lt;/from&gt; &lt;to&gt; &lt;image&gt;基础镜像地址&lt;/image&gt; &lt;auth&gt; &lt;username&gt;阿里云用户名&lt;/username&gt; &lt;password&gt;阿里云密码&lt;/password&gt; &lt;/auth&gt; &lt;tags&gt; &lt;tag&gt;版本号&lt;/tag&gt; &lt;/tags&gt; &lt;/to&gt; &lt;allowInsecureRegistries&gt;true&lt;/allowInsecureRegistries&gt; &lt;/configuration&gt; &lt;executions&gt; &lt;execution&gt; &lt;phase&gt;package&lt;/phase&gt; &lt;goals&gt; &lt;goal&gt;build&lt;/goal&gt; &lt;/goals&gt; &lt;/execution&gt; &lt;/executions&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/build&gt; 版本号这里一开始指定的自定义版本，但是使用jib:build时报错，说找不到latest版本，不知道是不是默认拉取latest，但是网上其他博主好像并没有这个情况，这里就只好将tag设为latest了 二、github创建仓库添加Dockerfile文件 三、阿里云创建镜像仓库3.1 创建仓库点击下一步，根据提示选择Dockerfile所在仓库 进入新创建的仓库，点击添加规则这里版本起名latest，原因上面解释了，有知道的伙伴还请告知 感谢~ 点击构建，等待一会，下方日志中会显示构建的镜像和状态 最后返回基本信息，复制公网地址，放在from和to的image中，一定要填写username和password最后执行 jib:build即可成功 成功! 最后在docker中拉取就可以了 1docker run -d --name testjib-p 8081:8081 刚刚复制的公网地址:latest(对应的镜像版本号)","link":"/posts/20200106-jib_ali.html"},{"title":"mavon-editor+springboot+fdfs上传文件","text":"一、安装mavon直接npm install下就可以了，然后在main.js引入：12import mavonEditor from 'mavon-editor'Vue.use(mavonEditor) 二、页面使用1234567891011&lt;mavon-editor v-show=\"!articleModal\" id=\"editor\" v-model=\"value\" fontSize=\"16px\" ref=\"md\" @imgAdd=\"$imgAdd\" @imgDel=\"$imgDel\" @change=\"handleChange\" @fullScreen=\"handleFullScreen\" /&gt; 这里只需要关注@imgAdd，为添加图片的事件 三、上传文件这里使用的是批量上传，所以每触发一次@imgAdd就向文件集合添加一次 1234567/** * 添加文件到文件集合中 */ $imgAdd(pos, $file) { // 缓存图片信息 this.img_file[pos] = $file; }, data中定义如下： 1img_file: {}, //文件集合 上传文件方法： 123456789101112131415161718192021222324/** * 上传文件 */ uploadimg($e) { var formdata = new FormData(); for (var _img in this.img_file) { formdata.append(\"files\", this.img_file[_img]); } uploadApi.uploadFileList(formdata).then(res =&gt; { console.log(res); const resData = res.data.data; /** * 例如：返回数据为 res = [[pos, url], [pos, url]...] * pos 为原图片标志（0） * url 为上传后图片的url地址 */ // 第二步.将返回的url替换到文本原位置![...](0) -&gt; ![...](url) for (var i = 0; i &lt; resData.length; i++) { this.$refs.md.$img2Url(i + 1, resData[i]); } }); } 然后在需要上传的时候调用一下这个方法就可以啦 四、后台进行上传4.1Controller123456789101112131415/** * 文章多文件上传 * @param files * @return 返回图片地址 */ @PostMapping(value = \"/files\",produces = MediaType.APPLICATION_JSON_UTF8_VALUE) public Result uploadMultiFiles(@RequestParam(\"files\") MultipartFile[] files){ try { List&lt;String&gt; resultList = uploadService.uploadMultiFiles(files); return new Result(true,StatusCode.OK,\"上传成功\",resultList); }catch (Exception e){ return new Result(false,StatusCode.ERROR,\"啊哦~图片上传出现了点小错误，请稍后再上传\"); } } 4.2、Service123456789101112131415161718192021222324252627282930313233343536/** * 批量上传 * @param files */ public List&lt;String&gt; uploadMultiFiles(MultipartFile[] files) { List&lt;String&gt; resultList=new ArrayList&lt;&gt;(); for (MultipartFile file : files) { try { //校验文件内容 BufferedImage image = ImageIO.read(file.getInputStream()); if (image == null) { throw new MyException(ExceptionEnum.INVALID_FILE_TYPE); } //获取拓展名 String extension = StringUtils.substringAfterLast(file.getOriginalFilename(), \".\"); //上传到FastDFS StorePath storePath = storageClient.uploadFile(file.getInputStream(), file.getSize(), extension, null); //不加http://前端无法显示 resultList.add(\"http://\"+uploadProperties.getBaseUrl() + storePath.getFullPath()); //返回路径 } catch (IOException e) { //上传失败 LOGGER.error(\"[文件上传]文件\"+file.getOriginalFilename()+\"上传失败!\", e); throw new MyException(ExceptionEnum.UPLOAD_FILE_ERROR); } } return resultList; } Fdfs的相关配置在这篇文章写啦(不好意思比较懒)：https://blog.csdn.net/weixin_43696529/article/details/102727220","link":"/posts/20200106-mavon_boot_fdfs.html"},{"title":"冒泡排序---------java实现","text":"一、冒泡排序 平均时间复杂度: O(n²)最差时： O(n²)是否稳定： 稳定空间开销：O（1）适合n较小时 原始数组：3 ， 9， -1， 8, 2 第一趟排序：（1） 3， 9， -1， 8，2（2） 3， -1， 9，8， 2（3） 3， -1， 8， 9， 2（4）3， -1， 8， 2， 9 9确定 第二趟排序：（1）-1，3， 8， 2， 9（2）-1, 3， 8， 2， 9（3）-1，3，2， 8， 9 8 , 9确定第三趟排序：（1）-1，3 ，2 ，8 ， 9（2）-1， 2， 3 ，8 ，9 3， 8， 9确定第四趟排序：（1）-1， 2， 3， 8， 9 (2， 3， 8， 9确定) 实现： 123456789101112131415161718int[] array = {3, 9, -1, 8, 2}; int temp=0; for (int i=0; i&lt; array.length-1;i++){ System.out.println(\"开始第\"+(i+1)+\"趟排序\"); for (int j=0;j&lt;array.length-1-i;j++){ if (array[j]&gt;array[j+1]){ temp=array[j]; array[j]=array[j+1]; array[j+1]=temp; } System.out.println(Arrays.toString(array)); } System.out.println(\"第\"+(i+1)+\"趟排序结果：\"); System.out.println(Arrays.toString(array)); System.out.println(\"------------------\"); } 结果：1234567891011121314151617181920212223242526开始第1趟排序[3, 9, -1, 8, 2][3, -1, 9, 8, 2][3, -1, 8, 9, 2][3, -1, 8, 2, 9]第1趟排序结果：[3, -1, 8, 2, 9]------------------开始第2趟排序[-1, 3, 8, 2, 9][-1, 3, 8, 2, 9][-1, 3, 2, 8, 9]第2趟排序结果：[-1, 3, 2, 8, 9]------------------开始第3趟排序[-1, 3, 2, 8, 9][-1, 2, 3, 8, 9]第3趟排序结果：[-1, 2, 3, 8, 9]------------------开始第4趟排序[-1, 2, 3, 8, 9]第4趟排序结果：[-1, 2, 3, 8, 9]------------------ 总结：1.共进行数组大小-1次循环2.每次排序的次数逐渐减少 优化：若一趟排序中没有一次交换，则停止循环增加标志变量flag=false，发生交换时，置flag为true，一次循环后判断flag，若为true，则重置flag为false继续循环，否则break； 1234567891011121314151617181920212223242526272829int[] array = {3, 9, -1, 8, 2}; boolean flag=false; int temp=0; for (int i=0; i&lt; array.length-1;i++){ System.out.println(\"开始第\"+(i+1)+\"趟排序\"); for (int j=0;j&lt;array.length-1-i;j++){ if (array[j]&gt;array[j+1]){ temp=array[j]; array[j]=array[j+1]; array[j+1]=temp; flag=true; } System.out.println(Arrays.toString(array)); } System.out.println(\"第\"+(i+1)+\"趟排序结果：\"); System.out.println(Arrays.toString(array)); System.out.println(\"------------------\"); if (!flag){ //未发生一次交换，flag为false break; }else { //发生了交换，flag被置为true flag=false; //重置flag，继续循环 } } 这里因为数据原因仍然执行了4次可以换一组数据:{3,9,-1,8,10}结果： 123456789101112131415161718192021开始第1趟排序[3, 9, -1, 8, 10][3, -1, 9, 8, 10][3, -1, 8, 9, 10][3, -1, 8, 9, 10]第1趟排序结果：[3, -1, 8, 9, 10]------------------开始第2趟排序[-1, 3, 8, 9, 10][-1, 3, 8, 9, 10][-1, 3, 8, 9, 10]第2趟排序结果：[-1, 3, 8, 9, 10]------------------开始第3趟排序[-1, 3, 8, 9, 10][-1, 3, 8, 9, 10]第3趟排序结果：[-1, 3, 8, 9, 10]------------------ 可以看到只执行了三次排序 测试十万条数据执行时间:12345678910111213//创建50000个随机数组 int[] array =new int[100000]; for (int i=0;i&lt;100000;i++){ array[i]=(int)(Math.random()*100000); } long begintime=System.currentTimeMillis(); System.out.println(\"开始时间\"+begintime); bubbleSort(array); long endtime=System.currentTimeMillis(); System.out.println(\"结束时间\"+endtime); System.out.println(\"用时：\"+(endtime-begintime)+\"ms\"); 结果： 123开始时间1572061280770结束时间1572061302883用时：22113ms 当然每次执行时间不一样，但当数据大的时候总体效率还是很低的","link":"/posts/20200107-bubbleSort.html"},{"title":"基数排序-------------java实现","text":"一、基本思想1.基数排序(Radix Sort)属于分配式排序（distribution sort），又称”桶子法”(Bucket Sort或Bin Sort)，它是通过键值的各个位的值，将要排序的元素分配至某些“桶”中，达到排序的作用。2.基数排序属于稳定的排序，基数排序法的是效率高的稳定性排序法 3.基数排序(Radix Sort)是桶排序的扩展4.将所有待比较数值统一为同样的数位长度，数位较短的数前面补零。然后，从最低位开始，依次进行一次排序。这样从最低位排序一直到最高位排序完成以后, 数列就变成一个有序序列。 平均时间复杂度： O(n+k) 最优情况： O(n+k) 最坏情况： O(n²) 空间复杂度: O(n+k) 稳定性： 稳定 二、举例说明现有一组数据：{43,3,535,738,14,21,0} 第一轮排序： 第1轮排序后：0,21,43,4,14,535,738 第二轮排序：第二轮排序结果：0,4，14,21,535,738,43 第三轮排序：第三轮排序结果：0,4，14,21,43,535,738 三、代码实现1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768package com.wml.sort;import java.util.Arrays;/** * @author MaoLin Wang * @date 2019/10/3012:53 */public class RadixSort { public static void main(String[] args) { int[] arr={53,3,542,748,14,21,0}; radixSort(arr); } public static void radixSort(int[] arr){ //求最大数的位数 int max = arr[0]; for (int i = 1;i &lt; arr.length; i++){ if (arr[i] &gt;max){ max = arr[i]; } } //得到最大数的位数 int maxLength = (max+\"\").length(); //为防止数据溢出，应将列数设为数组长度 int [][] bucket=new int[10][arr.length]; //记录每个桶中实际存放了多少数据 int[] bucketElementCounts=new int[10]; /** * n代表位数，初始化为1，代表个位 */ for (int i=0 ,n = 1;i&lt; maxLength;i++,n *=10){ for (int j=0;j&lt;arr.length;j++){ //取出个位的值 int value= arr[j] /n %10; //放入个位值为value的桶的第bucketElementCounts[value]个位置，刚开始bucketElementCounts[value]为0，每放入一个数据就+1 bucket[value][bucketElementCounts[value]]=arr[j]; bucketElementCounts[value]++; } int index = 0;//原始数组下边，初始为0 // System.out.println(Arrays.toString(bucketElementCounts)); //遍历每个桶，将桶中数据放回原来数组 for (int k=0;k&lt;bucketElementCounts.length;k++){ //第k个桶 不等于0，即该桶有数据 if (bucketElementCounts[k] !=0){ //遍历该桶数据，放入原数组 for (int m=0;m&lt;bucketElementCounts[k];m++){ //取出元素放到arr arr[index++] = bucket[k][m]; } } //第i+1轮处理后，需要将每个bucketElementCounts[k] = 0 bucketElementCounts[k]=0; } System.out.println(\"第\"+(i+1)+\"轮结果\"+ Arrays.toString(arr)); } }} 结果：第1轮结果[0, 21, 542, 53, 3, 14, 748]第2轮结果[0, 3, 14, 21, 542, 748, 53]第3轮结果[0, 3, 14, 21, 53, 542, 748] 测试80w条数据耗时12345678910111213int[] arr =new int[800000]; for (int i=0;i&lt;800000;i++){ arr[i]=(int)(Math.random()*800000); } long begintime=System.currentTimeMillis(); System.out.println(\"开始时间\"+begintime); radixSort(arr); long endtime=System.currentTimeMillis(); System.out.println(\"结束时间\"+endtime); System.out.println(\"用时：\"+(endtime-begintime)+\"ms\"); 结果：开始时间1572416316975结束时间1572416317084用时：109ms 很明显比之前的归并、快速排序都快的多，但是其缺点也是很明显的，对于任何位数上的基数进行“装桶”操作时，都需要n+k个临时空间(k为桶数)，非常耗费空间","link":"/posts/20200107-jishuSort.html"},{"title":"希尔排序-----------java实现","text":"首先看一下之前使用简单插入排序存在的问题： 当存在一个数组，其最后一个数据为最小值，如：arr={5,6,16,34,33,2} 这样的话需要循环到最后一次，也就是第6次的时候，才可以将2排到前边，效率非常低 但是希尔排序可以很好的解决这个问题，其是简单插入排序改进后的一个效率较高的排序方式，也叫缩小增量排序 复杂度： 平均时间： O（nlogn） 最差: O(n²) 最优: O(n^1/3) 空间复杂度：O(1) 稳定性： 不稳定 一、基本思想希尔排序按某个增量分组，对每个分组使用直接插入排序实现，随着增量逐渐减小，每组数据逐渐增加，当增量减少至1时，仅剩下完整的一组，排序结束。 二、排序分析) 图片引用自https://blog.csdn.net/qq_28081081/article/details/80598960 三、代码实现1234567891011121314151617181920212223242526272829303132/** * 希尔排序 * @author MaoLin Wang * @date 2019/10/2817:43 */public class ShellSort { public static void main(String[] args) { int[] arr={214,32,11,2,3,2,66,33,54,12}; shellSort(arr); } public static void shellSort(int[]arr){ int temp=0; int count=0; for (int group =arr.length/2;group&gt;0;group/=2){ for (int i=group;i&lt;arr.length;i++){ for (int j=i-group;j&gt;=0;j-=group){ if (arr[j]&gt;arr[j+group]){ temp=arr[j]; arr[j]=arr[j+group]; arr[j+group]=temp; } } } System.out.println(\"第\"+(++count)+\"次排序结果：\"); System.out.println(Arrays.toString(arr)); } }} 结果： 123456第1次排序结果：[2, 32, 11, 2, 3, 214, 66, 33, 54, 12]第2次排序结果：[2, 2, 3, 12, 11, 32, 54, 33, 66, 214]第3次排序结果：[2, 2, 3, 11, 12, 32, 33, 54, 66, 214] 测试100000条数据耗时： 123456789101112int[] arr =new int[100000];for (int i=0;i&lt;100000;i++){ arr[i]=(int)(Math.random()*100000);}long begintime=System.currentTimeMillis();System.out.println(\"开始时间\"+begintime);shellSort(arr);long endtime=System.currentTimeMillis();System.out.println(\"结束时间\"+endtime);System.out.println(\"用时：\"+(endtime-begintime)+\"ms\"); 结果： 123开始时间1572260920132结束时间1572260930389用时：10257ms 发现用了10000多ms，不但没有提高效率，反而低了非常多，这是为什么呢？ 仔细看我们的代码进行交换的条件，发现只要满足arr[j]&gt;arr[j+group]就要进行交换，无疑增加了系统开销 接下来对代码进行优化： 123456789101112131415161718192021222324252627282930313233public static void shellSort2(int arr[]) { for (int group = arr.length / 2; group &gt; 0; group /= 2) { for (int i = group; i &lt; arr.length; i++) { int j = i; int temp = arr[j]; if (arr[j] &lt; arr[j - group]) { while ((j - group) &gt;= 0 &amp;&amp; temp &lt; arr[j - group]) { /** * 开始移动，将比arr[j]大的arr[j-group]、arr[j-group-group]......按顺序移动到后一个增量的位置 * 如 3, 2, 11, 21, 66, 32, 214, 4 * 在group减少到2，比较32和4的时候 * 1. 4&lt;32 且满足while条件， 所以将32移动到4,temp=4，j=5，指向32的位置 * 此时的数据为:3, 2, 11, 21, 66, 32, 214, 32 * 2.继续while循环 * j-group=3&gt;0 temp=4&lt;arr[3]=21，满足while条件 * 执行arr[j]=arr[j-group] -&gt; 将21的位置移动到32,temp仍然为一开始的4,j=3，指向21的位置 * 此时数据为：3, 2, 11, 21, 66, 21, 214, 32 * 3.继续循环while * j-group=1&gt;0 temp=4&gt;arr[1]=2 不满足while条件，退出循环 * 4.此时j=3，将temp=4赋值给arr[j] * 此时数据为：3, 2, 11, 4, 66, 21, 214, 32 */ arr[j] = arr[j - group]; j -= group; } //结束while循环后，将temp插入到arr[j] arr[j] = temp; } } } } 同样测试10000条数据排序的耗时： 123开始时间1572264172662结束时间1572264172692用时：30ms 耗时从1w多ms减小到30ms，多次测试上下波动也不会超过20ms","link":"/posts/20200107-shellSort.html"},{"title":"归并排序-------------java实现","text":"归并排序采用分治策略实现 平均时间复杂度 : O（nlogn） 最差时间复杂度: O(nlogn) 稳定性： 稳定 空间复杂度：O(n) 归并排序时以空间换时间的排序方法，空间消耗很大，一般内部排序使用快速排序较多 假设有这样一组数据：[10,4,8,7,1,3,2,9] 一、分) 如上将8个数组分成8个单独的数据 二、合1.将 10和 4合并 ) 2.将8和7合并 ) 3. 将4,10和7,8合并 )、 4.同样将右半部分也按此合并得到如下两组数据 ) 5.最后将两组数据合并在一起 ) 三、代码实现12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879package com.wml.sort;import java.util.Arrays;/** * @author * @date 2019/10/2919:17 */public class MergeSort { public static void main(String[] args) { int arr[] = {10,4,8,7,1,3,2}; int[] temp=new int[arr.length]; mergeSort(arr,0,arr.length-1,temp); System.out.println(Arrays.toString(arr)); } public static void mergeSort(int[] arr,int left,int right,int[] temp){ if (left &lt; right){ int mid= (left + right ) / 2; //向左递归分解 mergeSort(arr,left,mid,temp); //向右递归分解 mergeSort(arr,mid+1,right,temp); //合并 merge(arr,left,right,mid,temp); } } /** * * @param arr 待排序数组 * @param left 左边有序序列的初始索引 * @param right 右边索引 * @param mid * @param temp 临时数组 */ public static void merge(int[] arr,int left, int right,int mid,int[] temp){ int l = left; //初始化i，左边有序序列的初始索引 int r = mid+1; //右边有序序列的初始索引 int current = 0; // 指向临时数组的当前索引 //1.先把左边两边的有序数据按规则填充到临时数组，直到任意一方处理完毕 while ( l&lt;= mid &amp;&amp; r &lt;= right){ if (arr[l] &lt;= arr[r]){ //当前左边的元素小于等于右边的，将左边的数据拷贝到临时数组 temp[current] = arr[l]; current +=1; //current后移 l +=1; //左边指针右移 }else { //右边的元素移到临时数组 temp[current] = arr[r]; current += 1; r +=1; } } //2.将有剩余的一边全部移动到临时数组 while ( l &lt;= mid){//左边有剩余 temp[current] = arr[l]; current+=1; l+=1; } while ( r &lt;= right){//右边有剩余 temp[current] = arr[r]; current+=1; r+=1; } //3.将临时数组拷贝到原始数组 current = 0; int tempLeft=left; while (tempLeft &lt;= right){ arr[tempLeft] = temp[current]; current+=1; tempLeft +=1; } }} 结果： [1, 2, 3, 4, 7, 8, 10]","link":"/posts/20200107-guibingSort.html"},{"title":"快速排序-------------java实现","text":"一、基本思想选择一个基准数，通过一趟排序将待排序数据分成两个独立的部分，其中一部分的所有数都比基准数小，另一部分都比基准数大，然后再使用此方法递归对两部分数据进行快排，最终实现整个数据的有序。 二、详解排序过程现有待排序数据： 1{-21, 312, 44, 11, -23, 2, 10}; 蓝色为左哨兵，记为left，黄色为右哨兵记为right，红色为基数 基数=(左哨兵坐标+右坐标)/2 第一轮排序： ​ ↓ ↓ ​ -21， 312， 44， 11， -23， 2， 10 ​ 左哨兵找到第一个比基数11大的数停止，即在312停止，此时left=1 ​ 右哨兵找到第一个比基数小的数停止，即在10停止，此时right=6 ​ 此时两个哨兵尚未相遇，交换 312 和 10 交换后： ​ ↓ ↓ ​ -21， 10， 44， 11， -23， 2， 312 左哨兵继续移动，到比11大的44时停止，此时left=2 右哨兵继续移动，到比11小的2处停止，此时right=5 两个哨兵仍然未相遇 ，不需要break；交换 44 和 2 交换后： ​ ↓ ↓ ​ -21， 10， 2， 11， -23， 44， 312 左哨兵继续移动，到基数11停止，因为左边已经没有比11小的数了，此时left=3 右哨兵继续移动，到比 11小的 -23处停止，此时right = 4 交换11 和-23 交换后： ​ ↓ ↓ ​ -21， 10， 2， -23， 11， 44， 312 此时再继续移动，两个哨兵相遇，一轮结束 当哨兵相遇时，让right–，left++，分别指向-23 和44 此时左半部分为：-21, 10, 2, -23 left为-21，right为-23 右半部分为： 44， 312 left为44，right为312 两边继续按上述步骤递归排序 三、代码实现：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667/** * 快速排序 * @author * @date 2019/10/2917:06 */public class QuickSort { public static void main(String[] args) { int[] arr={-21,312,44,11,-23,2,10}; quickSort(arr,0,arr.length-1); System.out.println(Arrays.toString(arr)); } public static void quickSort(int[] arr, int left, int right) { int l = left; int r = right; //基准数 int pivot = arr[(left + right) / 2]; int temp=0;//临时变量 //让比基数小的放在左边，比基数大的放在右边 while (l &lt; r){ //在基数左边找到大于等于基数的值才退出 while (arr[l] &lt; pivot){ l += 1; } //在基数右边找到小于等于基数的值才退出 while (arr[r] &gt; pivot){ r -=1; } //左右两个哨兵相遇，即说明基数左边的数已经全部小于基数，右边的数已经全部大于基数 if( l &gt;= r){ break; } //否则进行交换 temp = arr[l]; arr[l] = arr[r]; arr[r] = temp; //如果交换完后，发现arr[l] == 基数，r向左移 if (arr[l] == pivot){ r -= 1; } //如果交换完后，发现arr[r] == 基数，l向右移 if (arr[r] == pivot){ l += 1; } } if (l == r){ l +=1; r -=1; } //向左递归 if (left&lt;r){ quickSort(arr,left,r); } //向右递归 if (right &gt; l){ quickSort(arr,l,right); } }} 结果： [-23, -21, 2, 10, 11, 44, 312] 四、测试10W条数据耗时123456789101112int[] arr =new int[100000];for (int i=0;i&lt;100000;i++){ arr[i]=(int)(Math.random()*100000);}long begintime=System.currentTimeMillis();System.out.println(\"开始时间\"+begintime);quickSort(arr,0,arr.length-1);long endtime=System.currentTimeMillis();System.out.println(\"结束时间\"+endtime);System.out.println(\"用时：\"+(endtime-begintime)+\"ms\"); 结果： 123开始时间1572344644967结束时间1572344645031用时：64ms 此时与希尔排序看不出很大的差距，将数据增加到80W条测试结果： 希尔： 开始时间1572344777821结束时间1572344778134用时：313ms 快速： 开始时间1572344758536结束时间1572344758711用时：175ms 经过多次测试，偶尔会有希尔排序比快速快的情况，但是多数情况下还是快速比希尔快","link":"/posts/20200107-quickSort.html"},{"title":"插入排序-----------java实现","text":"一、复杂度12345平均时间复杂度： O(n²)最差时： O(n²)是否稳定： 稳定空间开销： O(1)在大部分数据已经排好序时性能较好 二、基本思想将n个待排序元素看成一个有序表和一个无序表，开始有序表只有一个元素，每次排序从无需表中取第一个元素，将它的值依此和有序表元素的数据比较，插入到有序表的适当位置，形成新的有序表 详解： 初始数据：18, 5, 54, 2, 33, 12 第一次排序：5， 18， 54， 2， 33，12 第二次排序：2，5， 18， 54， 33，12 第三次排序：2，5，12 18， 54， 33 第四次排序：2，5，12 18，33， 54 第五次排序：2，5，12 18，33，54 三、代码实现12345678910111213141516171819202122232425262728293031323334353637/** * 插入排序 * @author ** * @date 2019/10/2816:55 */public class InsertSort { public static void main(String[] args) { int[] arr= {213,43,22,11,324,11,4}; insertSort(arr); } public static void insertSort(int[] arr){ for (int i=1;i&lt;arr.length;i++){ //待插入数据 int insertVal=arr[i]; //待插入位置下标 int insertIndex=i-1; /** * 如果待插入下标小于零，说明待插入数据最小，应放在第一个位置 * 如果待插入值大于arr[inserIndex]，则停止循环，说明待插入值在有序表中是最大的，应插入到当前insertIndex后一个位置 */ while (insertIndex&gt;=0 &amp;&amp; insertVal&lt;arr[insertIndex]){ arr[insertIndex+1]=arr[insertIndex]; insertIndex--; } arr[insertIndex+1]=insertVal; System.out.println(\"第\"+i+\"次排序结果：\"); System.out.println(Arrays.toString(arr)); } }} 结果： 123456789101112第1次排序结果：[43, 213, 22, 11, 324, 11, 4]第2次排序结果：[22, 43, 213, 11, 324, 11, 4]第3次排序结果：[11, 22, 43, 213, 324, 11, 4]第4次排序结果：[11, 22, 43, 213, 324, 11, 4]第5次排序结果：[11, 11, 22, 43, 213, 324, 4]第6次排序结果：[4, 11, 11, 22, 43, 213, 324] 四、测试100000条数据耗时123456789101112131415161718192021222324252627282930313233343536373839404142434445464748package com.wml.sort;import java.util.Arrays;/** * @author *** * @date 2019/10/2816:55 */public class InsertSort { public static void main(String[] args) { int[] array =new int[100000]; for (int i=0;i&lt;100000;i++){ array[i]=(int)(Math.random()*100000); } long begintime=System.currentTimeMillis(); System.out.println(\"开始时间\"+begintime); insertSort(array); long endtime=System.currentTimeMillis(); System.out.println(\"结束时间\"+endtime); System.out.println(\"用时：\"+(endtime-begintime)+\"ms\"); } public static void insertSort(int[] arr){ for (int i=1;i&lt;arr.length;i++){ //待插入数据 int insertVal=arr[i]; //待插入位置下标 int insertIndex=i-1; /** * 如果待插入下标小于零，说明待插入数据最小，应放在第一个位置 * 如果待插入值大于arr[inserIndex]，则停止循环，说明待插入值在有序表中是最大的，应插入到当前insertIndex后一个位置 */ while (insertIndex&gt;=0 &amp;&amp; insertVal&lt;arr[insertIndex]){ arr[insertIndex+1]=arr[insertIndex]; insertIndex--; } arr[insertIndex+1]=insertVal; } }} 结果： 123开始时间1572254640158结束时间1572254641586用时：1428ms 相比上一篇的选择排序的5811ms总体又快了许多","link":"/posts/20200107-insertSort.html"},{"title":"选择排序  ------java实现","text":"一、选择排序的思想第一次从arr[0]~arr[n-1]中选取最小值与arr[0]交换，第二次从arr[1]到arr[n-1]中选取最小值与arr[1]交换，第三次从arr[2]到arr[n-1]中选取最小值与arr[2]交换，以此类推，总共循环n-1次，得到一个从小到大的有序序列。 二、思路详解待排序元素： [34] 54 123 55 11 22 第一次排序： [11,34] 54 123 55 22第二次排序 : [11,22,34] 54 123 55第三次排序： [11,22,34,54] 123 55第四次排序： [11,22,34,54,55] 123 说明(这里按从小到大)： 1.选择排序共进行数组大小-1次排序2.每次排序中，先设当前的数是最小值，然后依次和后面的数进行比较，如果发现有比这个数小的，就让最小的数为这个数，得到最小值下标，遍历一个循环后，得到最小值和下标3.如果该小标与一开始的不一样，说明存在比开始设定的最小的数还小的数，将二者交换，进行下一次循环 三、代码实现12345678910111213141516171819202122232425public static void selectSort(int[] arr){ for (int i=0;i&lt;arr.length-1;i++){ int minIndex=i; int min=arr[i]; for (int j=i+1;j&lt;arr.length;j++){ if (min&gt;arr[j]){ min=arr[j]; minIndex=j; } } //将最小值放在arr[0]。即交换 if (minIndex!=i){ arr[minIndex]=arr[i]; arr[i]=min; } System.out.println(\"第\"+(i+1)+\"轮后结果\"); System.out.println(Arrays.toString(arr)); } } public static void main(String[] args) { int[] array={101,222,119,1}; SelectSort.selectSort(array); } 结果： 123456第1轮后结果[1, 222, 119, 101]第2轮后结果[1, 101, 119, 222]第3轮后结果[1, 101, 119, 222] 测试100000条数据执行时间： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748package com.wml.sort;import java.util.Arrays;/** * 选择排序 * @author MaoLin Wang * @date 2019/10/2811:24 */public class SelectSort { public static void main(String[] args) { //int[] array={101,222,119,1}; int[] array =new int[100000]; for (int i=0;i&lt;100000;i++){ array[i]=(int)(Math.random()*100000); } long begintime=System.currentTimeMillis(); System.out.println(\"开始时间\"+begintime); SelectSort.selectSort(array); long endtime=System.currentTimeMillis(); System.out.println(\"结束时间\"+endtime); System.out.println(\"用时：\"+(endtime-begintime)+\"ms\"); } public static void selectSort(int[] arr){ for (int i=0;i&lt;arr.length-1;i++){ int minIndex=i; int min=arr[i]; for (int j=i+1;j&lt;arr.length;j++){ if (min&gt;arr[j]){ min=arr[j]; minIndex=j; } } //将最小值放在arr[0]。即交换 if (minIndex!=i){ arr[minIndex]=arr[i]; arr[i]=min; } //System.out.println(\"第\"+(i+1)+\"轮后结果\"); //System.out.println(Arrays.toString(arr)); } }} 结果：用时： 123开始时间1572251978745结束时间1572251984556用时：5811ms 相比上一篇冒泡排序的22113ms快了许多 平均时间： O(n²)最差： O（n²）是否稳定： 不稳定空间复杂度： O（1）备注： n小时较好","link":"/posts/20200107-selectSort.html"},{"title":"Linux命令整理-------------文件管理相关(一)","text":"cat说明：用来显示文本内容(小文件)，对于大文件推荐使用more命令 格式： cat +选项+指定文件 ​ 选项： 123&gt; -n 或 --number：显示行号；&gt; -b 或 --number-nonblank：编号时忽略空白行&gt; -A：显示不可打印字符，行尾显示“$”； 如： 1234567echo xxx&gt;test 若test不存在，则自动创建test并写入xxx，否则直接写入cat 123.txt 屏幕显示123.txt内容cat 文本1 文本2 ... 显示多个文本内容cat 文本1 文本2 &gt; 文本3 将文本1和2的内容合并到文本3中cat 文本1 &gt; 文本2 将文本1内容拷贝到文本2cat /dev/null &gt; 文本1 清空文本1的内容cat &gt;test1.txt &lt;&lt;stop 向test1.txt写入内容，输入stop结束 注意：每次合并时，文本3的内容会被重新覆盖 more全屏幕显示文本文件内容 选项：12345-数字：每屏显示指定行-c：不进行滚屏操作。每次刷新这个屏幕；-s：将多个空行压缩成一行显示；-u：禁止下划线；+数字：从指定数字的行开始显示。 查看时可用命令： Space键：显示文本的下一屏内容。 Enter键：每次刷新一行 H键：显示相关的帮助信息 B键：查看上一屏 q键：退出 ​​ cd1.cd : 进入目录 2.cd ~: 进入用户目录 3.cd - : 进入历史上一级目录，即进此目录之前的那个目录 4.cd .. ：返回上级目录 cd ../../ 有几个.../就返回上几级目录 ls 显示目标列表 选项 -a 显示所有文件（在linux中以.开头的文件为隐藏文件） -l 显示文本的详情包括(权限、拥有者、文件大小、最后修改时间等) -r 将文件反序显示(默认按照英文字母顺序) -t 按照创建时间列出 -A 同 -a ，但不列出 &quot;.&quot; (目前目录) 及 &quot;..&quot; (父目录) -F 在文件名称后加一个符号： *：代表可执行档 /： 代表目录 -R 有文件的目录，也会将其子文件列出 ​ -R举例： -F举例：test2是一个目录。所以在后边显示了一个/ pwd 显示当前工作目录（绝对路径） head 显示指定文件前N行 选项： -n：指定显示前n行 -v：显示文件名的头信息； -q：不显示文件名的头信息。 tail 显示指定文件的末尾N行，默认10行 选项： -c,–bytes=：显示文件尾部的N（N为整数）个字节内 -f&lt;name/descriptor&gt;：动态显示文件尾部内容，如某个动态更新的日志，可以使用-f查看最新的内容 -n：输出文件的尾部N（N位数字）行内容。 –pid=&lt;进程号&gt;：与“-f”选项连用，当指定的进程号的进程终止时退出该命令-q,–quiet,–silent：当有多个文件参数时，不输出各个文件名； -s&lt;秒数&gt;,–sleep-interal=&lt;秒数&gt;：与“-f”连用，指定文件变化时间隔(s) -v,–verbose：当有多个文件参数时，总是输出各个文件名； –help：帮助信息 –version：指令版本 举例： 12345tail test 不指定行数默认显示文件test的最后10行tail -n +10 test 从第10行到最后tail -c 10 test 显示该文件的最后10个字符tail -25 nginx.log 显示最后的 25 行tail -f nginx.log 动态刷新该文件最后的内容 chmod修改文件或目录的权限 权限范围：u: –&gt; User ，当前文件/目录的拥有者g: –&gt; Group ， 所属组o: –&gt; Other ， 除User和所属群组之外的所有用户a: –&gt; All ， 所有用户r: –&gt; 读权限，数字 4w:–&gt; 写权限，数字 2x: 执行/切换权限，数字 1- 无权限，数字 0 语法： chmod [options][参数] 选项： 1234567891011121314151617+ 添加某些权限- 取消某些权限= 指定文件权限r 读权限w 写权限x 可执行权限- 无权限X 给可执行文件设置可执行权限t 只有目录或文件的所有者才可以删除目录下的文件-c ,--changes 效果类似“-v”参数，但仅回报更改的部分，如果文件权限已经改变，显示其操作信息；-f , --quiet, --silent 操作过程中不显示任何错误信息；-R, --recursive 以递归更改其本身及子目录-v, --verbose 显示详情信息--reference=&lt;参考文件或目录&gt; 指定参考文件，非自定义权限--help 显示帮助信息--version 显示版本信息 权限结构： 1-rwxr--r-- 1 user staff 651 Nov 11 11:02 .ignore 第一个 -: 代表是普通文件，若是 d，则代表目录 第一组rwx：即上边的rw-,表示u属组 第二组rwx: 即上边中间的r–，表示g属组 第三组rwx: 即上边最后的r–， 表示其他人的权限 r:读 4 w：写 2 x：执行 1 举例: 1234567chmod u+w,g+r test1 为test1设置当前用户可写，组可读的权限chmod u=rwx,g=rw,o=r test1 当前用户可读写执行，组可读写，其他用户只能读chmod 764 test1 当前用户读写执行，组读写，其他只可读chmod a+r test1 所有用户都只可读test1chmod ugo-r test1 所有用户减掉可读权限 chmod -R 755 /usr/local/test/ 递归修改test目录下的子文件的权限为 755,7即4+2+1，5即4+1chown john:student test1 把test1给John，添加到student组 chown 改变文件或目录的拥有者或所属群组 可以给某个用户授权，使该用户变成指定文件的所有者或者改变文件所属的组。 语法： chown [options][参数] 选项： 12345-c，--changes：显示修改的部分；-f ：不显示错误信息；-h：只对符号连接的文件作修改，而不更改其他任何相关文件；-R：递归处理指定目录下的所有文件及子目录-v：显示指令执行过程信息 123chown -R wml:mygroup /usr/local/test1 将/usr/local/test下面的所有文件以及子目录的文件拥有者改为wml,群组为mygroup - ## cmp 比较两个二进制文件是否有差异，若无差异则不显示任何信息，若有差异则显示第一个不同的地方的字符和列数 **语法：** cmp [options][参数] **选项：** 12-l：对于每处不同，显示十进制的字节数和八进制的不同字节。；-s，--quit，--silent：不显示错误信息； **举例:** 123.txt ： 我是123 222 222.txt: 我是222 222 1cmp 123.txt 222.txt --结果--&gt;123.txt 222.txt differ: byte 1, line 1 - ## diff 比较两个文件的不同，该命令是采取逐行比较的方式， **选项：** 12345678910111213-&lt;行数&gt;：指定显示多少行的文本-a，--text：将文件当做文本文件处理-b：忽略空格字符造成的不同；-B，--ignore-blank-lines：忽略空白行；-c：显示两个文件的全部内容，并标出不同之处-H，--speed-large-files：加速大文件检索-i，--ignore-case：忽略大小写不同-l或——paginate：分页-q或--brief：仅显示有无差异，不显示详细的信息 有不同的结果:Files 123.txt and 222.txt differ-r，--recursive：比较子目录中的文件-T：每行对齐输出-y：并列打印 举例： ![在这里插入图片描述](https://img-blog.csdnimg.cn/20191028231857879.png) - ## file 检测目标文件类型 **选项：** 1234-b：不显示文件名称L-L：直接显示符号连接所指向的文件类别；-v：显示版本信息；-z：尝试去解读压缩文件的内容。 **举例：** 123[admin@ test]$ file 123.txt 222.txt123.txt: UTF-8 Unicode text222.txt: UTF-8 Unicode text find查询指定目录下的文件选项： 123456789101112131415161718192021-depth：从指定目录的最深层的子目录开始查找-maxdepth&lt;目录深度&gt;：最大目录深度-mindepth&lt;目录深度&gt;：最小目录层级；-empty：查找大小为0 的文件或空目录-exec&lt;要执行的指令&gt;：若find指令返回True，就执行目标指令(如找到空的就执行rm删除目标文件)-fstype&lt;文件系统类型&gt;：只寻找该文件系统类型下的文件或目录；-ls：将文件或目录名称列出到标准输出(权限信息，所属用户、组，时间信息等)-name&lt;inputname&gt;，-iname：查询名称符合inputname的文件，-iname忽略大小写-anewer test : 比文件 file 更晚被读取过的文件-path&lt;testPath&gt;，-ipath&lt;testPath&gt;：路径符合testPath的文件,-ipath 忽略大小写-perm&lt;权限值&gt;：查找符合指定的权限数值的文件-print：将文件或目录名称列出到标准输出。格式为每列一个名称，每个名称前皆有“./”字符串；-printf&lt;输出格式&gt;：自定义格式输出-size&lt;文件大小&gt;：查找符合指定大小的文件-type&lt;文件类型&gt;：指定的文件类型的文件-user&lt;拥有者名称&gt;：指定用户拥有的文件 举例： 1.find. 列出当前目录的所有文件及其子文件 123456789 find . 结果：../333.txt./222.txt./test2./test2/123.txt./123.txt./empty.txt 2.find /usr/test -name “*.txt”：查找test目录下后缀名为txt的文件 1234567find /usr/test -name \"*.txt\"结果：/usr/test/333.txt/usr/test/222.txt/usr/test/test2/123.txt/usr/test/123.txt/usr/test/empty.txt 3.find /usr/test ! -name “*.txt”：查找test目录下后缀名不是txt的文件 4.根据文件类型查找 -type: 1find . -type 参数 类型参数： f ：普通文件 l ：符号连接 d ：目录 c ：字符设备 b ：块设备 s ：套接字 p ：Fifo 5.查找小于3k的文件 1find . -size -3k 结果： ./333.txt ./222.txt ./test2/123.txt ./123.txt ./empty.txt 6.查找大小为0的文件 12[root@ test] find -empty./empty.txt 7.查找指定权限的文件 首先给123.txt赋予77权限： 1chmod 777 123.txt 查看下结果： 12345-rwxrwxrwx 1 777 root 21 Oct 28 23:08 123.txt-rw-r--r-- 1 root root 15 Oct 28 22:57 222.txt-rw-r--r-- 1 root root 23 Oct 27 22:46 333.txt-rw-r--r-- 1 root root 0 Oct 29 15:20 empty.txtdrwxr-xr-x 2 root root 4096 Oct 27 19:52 test2 只有123.txt的权限为777, 执行查找： 1find -perm 777 结果： 1./123.txt ​ 持续更新………","link":"/posts/20200106-linux_file_1.html"},{"title":"（复习）二叉树的三种遍历方式、查找和删除----------Java实现","text":"一、概念：二叉树二叉树的每个节点最多只能由两个子节点 性质： 二叉树的第 i 层最多有 2 ^ (i-1) 个节点 深度为 k （ k≥0 ）的二叉树最少有 k 个节点(一层一个)，最多有 （2^k ）-1 个节点 （空树k=0，只有一个根节点k=1） 对于任意一个非空二叉树，若其 叶子节点数为 n，度为2的非叶子节点数为 m，则 ==n=m+1==，（度 即节点所拥有的子树的个数） 如果节点总数为 2^n-1 且所有叶子节点都在最后一层，则该树为==满二叉树== 如果该二叉树的所有叶子节点都在最后一层或者倒数第二层，而且最后一层的叶子节点在左边连续，倒数第二层的叶子节点在右边连续，则称为==完全二叉树==。如下： 二、三种遍历方式2.1前序遍历根节点 —&gt; 左孩子 —&gt; 右孩子以上图为例，前序遍历结果为：11，21,14,81,91,15,31，61,71 2.2 中序遍历左孩子 –&gt; 根节点 —&gt; 右孩子 上图为例，结果为：81,14,91,21,15,11,61,31,71 2.3 后序遍历左孩子 –&gt; 右孩子 —&gt; 根节点 上图为例，结果为：81,91,14,15,21,61,71,31,11 三、代码实现遍历3.1首先创建TreeNode类作为数节点这里方便使用直接都设为了public 12345678910111213141516171819class TreeNode { public int no;//节点编号 public TreeNode lchild;//左孩子 public TreeNode rchild;//右孩子 public TreeNode() { } public TreeNode(int no) { this.no = no; } @Override public String toString() { return \"TreeNode{\" + \"no=\" + no + '}'; }} 3.2 创建二叉树类12345678//定义二叉树class BinaryTree { private TreeNode root; public void setRoot(TreeNode root) { this.root = root; }} 3.3 前序遍历方法： 1.首先输出根节点 2.左孩子非空时，递归遍历左孩子 3.右孩子非空时，递归遍历右孩子 1234567891011121314/** * 前序遍历： 根节点-&gt;左节点-&gt;右节点 */ public void preOrder() { System.out.println(this);//先输出父节点 //向左递归 if (this.lchild != null) { this.lchild.preOrder(); } //向右递归 if (this.rchild != null) { this.rchild.preOrder(); } } 3.4 中序遍历方法： 1.左孩子非空时，递归遍历左孩子 2.首先输出根节点 3.右孩子非空时，递归遍历右孩子 123456789101112131415/** * 中序遍历： 左节点-&gt;根节点-&gt;右节点 */ public void midOrder() { //向左递归 if (this.lchild != null) { this.lchild.midOrder(); } System.out.println(this);//输出根节点 //向右递归 if (this.rchild != null) { this.rchild.midOrder(); } } 3.5 后序遍历方法： 1.左孩子非空时，递归遍历左孩子 2.右孩子非空时，递归遍历右孩子 3.首先输出根节点 12345678910111213141516/** * 后序遍历： 左节点-&gt;右节点-&gt;根节点 */ public void postOrder() { //向左递归 if (this.lchild != null) { this.lchild.postOrder(); } //向右递归 if (this.rchild != null) { this.rchild.postOrder(); } System.out.println(this);//输出根节点 } 其实就是把输出根节点的位置按先中后的顺序换来换去 3.6 在二叉树中调用一下方法应先判断根节点是否为空，不为空时才遍历 123456789101112131415161718192021222324//前序遍历 public void preOrder(){ if (this.root!=null){ this.root.preOrder(); }else { System.out.println(\"二叉树为空\"); } } //中序遍历 public void midOrder(){ if (this.root!=null){ this.root.midOrder(); }else { System.out.println(\"二叉树为空\"); } } //后续遍历 public void postOrder(){ if (this.root!=null){ this.root.postOrder(); }else { System.out.println(\"二叉树为空\"); } } 测试按照一开始的那个图创建二叉树： 12345678910111213141516171819202122232425262728293031BinaryTree binaryTree=new BinaryTree(); //创建根节点 TreeNode root = new TreeNode(11); TreeNode treeNode2 = new TreeNode(21); TreeNode treeNode3 = new TreeNode(31); TreeNode treeNode4 = new TreeNode(14); TreeNode treeNode5 = new TreeNode(15); TreeNode treeNode6 = new TreeNode(61); TreeNode treeNode7 = new TreeNode(71); TreeNode treeNode8 = new TreeNode(81); TreeNode treeNode9 = new TreeNode(91); root.lchild =treeNode2; root.rchild =treeNode3; treeNode3.rchild =treeNode7; treeNode3.lchild =treeNode6; treeNode2.lchild =treeNode4; treeNode2.rchild =treeNode5; treeNode4.lchild =treeNode8; treeNode4.rchild =treeNode9; binaryTree.setRoot(root); System.out.println(\"中序-------\"); binaryTree.midOrder(); System.out.println(\"前序--------\"); binaryTree.preOrder(); System.out.println(\"后续--------\"); binaryTree.postOrder(); 结果： 123456789101112131415161718192021222324252627282930中序-------TreeNode{no=81}TreeNode{no=14}TreeNode{no=91}TreeNode{no=21}TreeNode{no=15}TreeNode{no=11}TreeNode{no=61}TreeNode{no=31}TreeNode{no=71}前序--------TreeNode{no=11}TreeNode{no=21}TreeNode{no=14}TreeNode{no=81}TreeNode{no=91}TreeNode{no=15}TreeNode{no=31}TreeNode{no=61}TreeNode{no=71}后续--------TreeNode{no=81}TreeNode{no=91}TreeNode{no=14}TreeNode{no=15}TreeNode{no=21}TreeNode{no=61}TreeNode{no=71}TreeNode{no=31}TreeNode{no=11} 四、三种遍历查询某个节点返回节点编号4.1 前序遍历方法：1.判断当前节点是否满足，满足的话返回该节点，不满足进行 22.判断当前节点的左孩子是否为空，不为空的话递归前序遍历左孩子3.判断当前节点的右孩子是否为空，不为空的话递归前序遍历右孩子实现： 1234567891011121314151617181920212223242526272829303132/** * 前序遍历查找 * @param no * @return */ public TreeNode preOrderFind(int no){ if (this.no==no){ return this; } TreeNode treeNode=null; /** * 判断当前当前节点的左孩子是否为空，不为空 -&gt; 递归前序遍历查找， * 若找到，就返回 */ if (this.lchild !=null){ treeNode=this.lchild.preOrderFind(no); } if (treeNode!=null){ return treeNode; } /** * 判断右孩子是否为空，不为空-&gt;递归前序遍历，无论找没找到都返回treeNode */ if (this.rchild !=null){ treeNode=this.rchild.preOrderFind(no); } return treeNode; } 4.2 中序遍历方法：将当前节点放在左孩子和右孩子中间就好了，其他同上实现： 1234567891011121314151617181920212223242526272829303132/** * 中序遍历查找 * @param no * @return */ public TreeNode midOrderFind(int no){ TreeNode treeNode=null; /** * 判断当前当前节点的左孩子是否为空，不为空 -&gt; 递归前序遍历查找， * 若找到，就返回 */ if (this.lchild !=null){ treeNode=this.lchild.midOrderFind(no); } if (treeNode!=null){ return treeNode; } if (this.no==no){ return this; } /** * 判断右孩子是否为空，不为空-&gt;递归前序遍历，无论找没找到都返回treeNode */ if (this.rchild !=null){ treeNode=this.rchild.midOrderFind(no); } return treeNode; } 4.3 后序遍历方法：将当前节点的比较放在最后就好了，其他同上实现： 1234567891011121314151617181920212223242526272829303132333435363738/** * 后序遍历查找 * @param no * @return */ public TreeNode postOrderFind(int no){ TreeNode treeNode=null; /** * 判断当前当前节点的左孩子是否为空，不为空 -&gt; 递归前序遍历查找， * 若找到，就返回 */ if (this.lchild !=null){ treeNode=this.lchild.postOrderFind(no); } if (treeNode!=null){ return treeNode; } /** * 判断右孩子是否为空，不为空-&gt;递归前序遍历，无论找没找到都返回treeNode */ if (this.rchild !=null){ treeNode=this.rchild.postOrderFind(no); } if (treeNode!=null){ return treeNode; } //左右孩子都没找到，找根节点 if (this.no==no){ return this; } return treeNode; } 4.4 二叉树调用查找方法12345678910111213141516171819202122232425262728293031323334353637/** * 前序遍历查找 * @param no * @return */ public TreeNode preOrderFind(int no){ if (root!=null){ return root.preOrderFind(no); }else { return null; } } /** * 中序遍历查找 * @param no * @return */ public TreeNode midOrderFind(int no){ if (root!=null){ return root.midOrderFind(no); }else { return null; } } /** * 后序遍历查找 * @param no * @return */ public TreeNode postOrderFind(int no){ if (root!=null){ return root.postOrderFind(no); }else { return null; } } 测试：查找6112345678910111213141516171819202122232425//前序遍历查找 System.out.println(\"前序遍历查找==============\"); TreeNode treeNode = binaryTree.preOrderFind(61); if (treeNode!=null){ System.out.println(\"找到了：编号为\"+treeNode.no); }else { System.out.println(\"没找到\"); } //中序遍历查找 System.out.println(\"中序遍历查找====================\") TreeNode midOrderFind = binaryTree.midOrderFind(61); if (midOrderFind!=null){ System.out.println(\"找到了：编号为：\"+midOrderFind.no); }else { System.out.println(\"没找到\"); } //后序遍历查找 System.out.println(\"后序遍历查找=============\"); TreeNode postOrderFind = binaryTree.postOrderFind(61); if (postOrderFind!=null){ System.out.println(\"找到了：编号为\"+postOrderFind.no); }else { System.out.println(\"没找到\"); } 结果： 123456前序遍历查找==============找到了：编号为61中序遍历查找====================找到了：编号为：61后序遍历查找=============找到了：编号为61 五、删除节点当节点为叶子节点时直接删除当节点为非叶子节点时连同其子树一起删除；(不删除子树的方法后续补充)方法：每次的比较对象为当前节点的左右孩子，当左孩子非空且编号与目标节点相同，让左孩子为null当右孩子非空且编号与目标节点相同，让右孩子为null当左右孩子非空时，递归遍历 12345678910111213141516171819/** * 递归删除 */ public void deleteNode(int no){ if (this.lchild !=null &amp;&amp; this.lchild.no==no){ this.lchild =null; return; } if (this.rchild !=null &amp;&amp;this.rchild.no==no){ this.rchild =null; return; } if (this.lchild !=null){ this.lchild.deleteNode(no); } if (this.rchild !=null){ this.rchild.deleteNode(no); } }","link":"/posts/20200107-binarytree.html"},{"title":"模拟先来先服务、短作业优先、时间片轮转以及最高响应比优先调度算法的JAVA实现","text":"这里记录一下操作系统的实验，几个调度算法的原理很好理解，网上也有很多解释，这里不再解释，直接上代码。 一、JCB类1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950public class JCB { public int id; /** * 剩余服务时间 */ public int leftTime; /** * 要求服务时间 */ public int serviceTime; /** * 到达时间 */ public int arriveTime; /** * 开始时间 */ public int beginTime; /** * 结束时间 */ public int finishTime; /** * 优先权 */ public float priority; public JCB(int id, int serviceTime, int arriveTime,float priority) { this.id = id; this.leftTime = serviceTime; this.serviceTime = serviceTime; this.arriveTime = arriveTime; beginTime =0; this.priority=priority; finishTime=0; } @Override public String toString() { return \"JCB{\" + \"id=\" + id + \", serviceTime=\" + serviceTime + \", arriveTime=\" + arriveTime + \", priority=\" + priority + '}'; }} 二、定义所需数据结构1234567891011121314151617181920212223242526272829303132333435363738394041424344454647/** * 时间片轮转算法 * * @author MaoLin Wang * @date 2019/11/3020:03 */public class SchedulingAlgorithm { /** * 就绪队列 */ LinkedList&lt;JCB&gt; readyQueue = null; /** * 结束调度队列 */ LinkedList&lt;JCB&gt; finishQueue = null; /** * 时间段 */ private int cpuTime; /** * 时间片大小 */ private int timeSize; /** * 作业数 */ private int jobNum; private String dispatchName;//调度算法名 /** * 作业周转时间 */ private int[] turnoverTime; /** * 作业带权周转时间· */ private float[] turnoverTimeWithWeight; /** * 平均带权周转时间 */ private float ave;} 三、初始化这里将最高响应比的初始化拉了出来，因为要设置响应比 12345678910111213141516171819202122232425262728293031323334353637383940414243444546/** * 初始化 */ public void init(int jobNum, int timeSize, String dispatchName) { System.out.println(\"开始\" + dispatchName + \"调度\"); readyQueue = new LinkedList&lt;&gt;(); finishQueue = new LinkedList&lt;&gt;(); this.turnoverTime = new int[jobNum]; this.turnoverTimeWithWeight = new float[jobNum]; this.cpuTime = 0; JCB jcb; for (int i = 1; i &lt;= jobNum; i++) { jcb = new JCB(i, (int) (Math.random() * 10 + 1), i - 1, 0); readyQueue.offer(jcb); } this.timeSize = timeSize; this.jobNum = jobNum; this.dispatchName = dispatchName; printInitQueue(); } /** * 初始化高响应比优先队列 * * @param jobNum * @param timeSize * @param dispatchName */ public void HRNInit(int jobNum, int timeSize, String dispatchName) { System.out.println(\"开始\" + dispatchName + \"调度\"); readyQueue = new LinkedList&lt;&gt;(); finishQueue = new LinkedList&lt;&gt;(); this.turnoverTime = new int[jobNum]; this.turnoverTimeWithWeight = new float[jobNum]; this.cpuTime = 0; JCB jcb; for (int i = 1; i &lt;= jobNum; i++) { float v = (float) (Math.random() * 5 + 1); jcb = new JCB(i, (int) (Math.random() * 10 + 1), i - 1, (float) (Math.random() * 5 + 1)); readyQueue.offer(jcb); } this.timeSize = timeSize; this.jobNum = jobNum; this.dispatchName = dispatchName; printInitQueue(); } 作业id默认为序号i，所需服务时间随机生成，到达时间默认从0开始，响应比其他调度算法为0，高响应比算法为随机生成。 四、高响应比优先算法实现逻辑很简单，使用递归实现，参数初始为0，每次取出对头作业，因为这里所有的作业在初始化时数据都初始化好了，所以需判断作业到达时间是否小于cpu时间片，因为只有小于时间片，说明其实际是到达的。 如果小于，则设置其开始时间为cpu当前时间，结束时间为开始时间+服务时间，剩余时间设为0，同时增加cpu时间，将该作业加入已完成队列中，否则，递归调用该算法，参数为index+1，一轮结束后，对作业按响应比排序，继续递归，知道就绪队列为空。 12345678910111213141516171819202122232425262728293031323334 /** * 最高响应比优先算法 */public void HRNAlgorithm(int index) { if (readyQueue.size() == 0) { System.out.println(\"就绪队列为空，调度完毕!\"); return; } JCB head = readyQueue.get(index); if (head.arriveTime &lt;= cpuTime) { readyQueue.poll(); System.out.println(\"-----------------------------------------------------\"); System.out.println(\"时间片: \" + cpuTime + \"开始调度作业:\" + head.id + \", 剩余服务时间: \" + head.leftTime); head.beginTime = cpuTime; head.finishTime = head.beginTime + head.serviceTime; head.leftTime = 0; cpuTime += head.serviceTime; finishQueue.offer(head); System.out.println(\"时间片: \" + cpuTime + \"结束调度作业:\" + head.id + \", 剩余服务时间: \" + head.leftTime); } else { HRNAlgorithm(index++); } sortByPriority(); HRNAlgorithm(0);}/** * 根据响应比排序 */private void sortByPriority() { readyQueue.sort((o1, o2) -&gt; o1.priority &gt; o2.priority ? -1 : 1);} 五、短作业优先调度算法同高响应比优先类似，只是按照要求服务时间排序。 123456789101112131415161718192021222324252627282930313233343536/** * 短作业优先调度算法 */ public void SJFAlgorithm(int index) { if (readyQueue.size() == 0) { System.out.println(\"就绪队列为空，调度完毕！\"); return; } JCB head = readyQueue.get(index); if (head.arriveTime &lt;= cpuTime) { readyQueue.poll(); System.out.println(\"-----------------------------------------------------\"); System.out.println(\"时间片: \" + cpuTime + \"开始调度作业:\" + head.id + \", 剩余服务时间: \" + head.leftTime); head.beginTime = cpuTime; head.finishTime = head.beginTime + head.serviceTime; head.leftTime = 0; cpuTime += head.serviceTime; finishQueue.offer(head); System.out.println(\"时间片: \" + cpuTime + \"结束调度作业:\" + head.id + \", 剩余服务时间: \" + head.leftTime); } else { sortByServiceTime(); SJFAlgorithm(index++); } sortByServiceTime(); SJFAlgorithm(0); } /** * 根据要求服务时间从小到大排序 */ private void sortByServiceTime() { readyQueue.sort((o1, o2) -&gt; o1.serviceTime &lt; o2.serviceTime ? -1 : 1); } 六、先来先服务 最简单的一个算法，直接按顺序取出队头作业执行。 12345678910111213141516171819202122/** * 先来先服务调度算法 */ public void FCFSAlgorithm() { if (readyQueue.size() == 0) { System.out.println(\"就绪队列为空，调度完毕！\"); return; } JCB head = readyQueue.poll(); System.out.println(\"-----------------------------------------------------\"); System.out.println(\"时间片: \" + cpuTime + \"开始调度作业:\" + head.id + \", 剩余服务时间: \" + head.leftTime); head.beginTime = cpuTime; head.leftTime = 0; head.finishTime = head.beginTime + head.serviceTime; cpuTime += head.serviceTime; finishQueue.offer(head); System.out.println(\"时间片: \" + cpuTime + \"结束调度作业:\" + head.id + \", 剩余服务时间: \" + head.leftTime); FCFSAlgorithm(); } 七、时间片轮转算法 这里需要根据作业剩余需要服务的时间跟时间片大小做对比，代码很好理解。 123456789101112131415161718192021222324252627282930313233343536/** * 时间片轮转算法 */ public void RRAlgorithm() { if (readyQueue.size() == 0) { System.out.println(\"就绪队列为空，调度完毕！\"); return; } JCB head = readyQueue.poll(); System.out.println(\"-----------------------------------------------------\"); System.out.println(\"时间片: \" + cpuTime + \"开始调度作业:\" + head.id + \", 剩余服务时间: \" + head.leftTime); head.beginTime = cpuTime; if (head.leftTime &gt; timeSize) { //服务时间大于时间片大小 head.leftTime -= timeSize; //重新加入到就绪队列尾部 readyQueue.offer(head); cpuTime += timeSize; } else if (head.leftTime == timeSize) { //服务时间等于时间片大小 cpuTime += timeSize; head.finishTime = cpuTime; head.leftTime = 0; //加入结束队列 finishQueue.offer(head); } else { //服务时间小于时间片大小 head.finishTime = cpuTime + head.leftTime; head.leftTime = 0; cpuTime += head.leftTime; finishQueue.offer(head); } System.out.println(\"时间片: \" + cpuTime + \"结束调度作业:\" + head.id + \", 剩余服务时间: \" + head.leftTime); RRAlgorithm(); } 八、计算周转时间和带权周转时间12345678910111213141516171819/** * 计算周转时间和带权周转时间 * @param finishQueue */ public void R_Dis(Queue&lt;JCB&gt; finishQueue) { Queue&lt;JCB&gt;temp=finishQueue; JCB tempJcb; float sum = 0; for (int i = 0; i &lt; jobNum; i++) { tempJcb=temp.poll(); turnoverTime[i] = tempJcb.finishTime - tempJcb.arriveTime; turnoverTimeWithWeight[i] =(float) turnoverTime[i] / tempJcb.serviceTime; sum += turnoverTimeWithWeight[i]; temp.offer(tempJcb); } float ave = sum / jobNum; this.ave = ave; } 九、打印结果123456789101112131415161718192021222324252627282930313233343536public void printResult(boolean isHRN) { R_Dis(this.finishQueue); System.out.println(\"=====================\" + this.dispatchName + \"调度结果为=========================\"); if (isHRN) { System.out.println(\"进程名\\t\" + \"到达时间\\t\" + \"要求服务时间\\t\" + \"响应比\\t\" + \"开始时间\\t\" + \"完成时间\\t\" + \"周转时间\\t\" + \"带权周转时间\\t\"+\"平均带权周转时间\\t\"); } else { System.out.println(\"进程名\\t\" + \"到达时间\\t\" + \"要求服务时间\\t\" + \"开始时间\\t\" + \"完成时间\\t\" + \"周转时间\\t\" + \"带权周转时间\\t\"+\"平均带权周转时间\\t\"); } int count = 0; for (JCB jcb : this.finishQueue) { if (isHRN) { System.out.println(\" \" + jcb.id + \"\\t\\t\\t\" + jcb.arriveTime + \"\\t\\t\" + jcb.serviceTime + \"\\t\\t\" + jcb.priority + \"\\t\\t\" + jcb.beginTime + \"\\t\\t\" + jcb.finishTime + \"\\t\\t\" + turnoverTime[count] + \"\\t\\t\" + turnoverTimeWithWeight[count]+\"\\t\\t\"+this.ave); count = count + 1; } else { System.out.println(\" \" + jcb.id + \"\\t\\t\\t\" + jcb.arriveTime + \"\\t\\t\" + jcb.serviceTime + \"\\t\\t\" + jcb.beginTime + \"\\t\\t\" + jcb.finishTime + \"\\t\\t\" + turnoverTime[count] + \"\\t\\t\" + turnoverTimeWithWeight[count]+\"\\t\\t\"+this.ave); count = count + 1; } } } /** * 打印初始化队列 */ private void printInitQueue() { System.out.println(\"当前就绪队列为:\"); for (JCB jcb2 : readyQueue) { System.out.println(jcb2); } } 测试1234567891011121314151617181920212223public class Test { public static void main(String[] args) { SchedulingAlgorithm schedulingAlgorithm = new SchedulingAlgorithm(); schedulingAlgorithm.init(5, 2,\"轮转\"); schedulingAlgorithm.RRAlgorithm(); schedulingAlgorithm.printResult(false); schedulingAlgorithm.init(5,3,\"先来先服务\"); schedulingAlgorithm.FCFSAlgorithm(); schedulingAlgorithm.printResult(false); schedulingAlgorithm.init(5,3,\"短作业优先服务\"); schedulingAlgorithm.SJFAlgorithm(0); schedulingAlgorithm.printResult(false); schedulingAlgorithm.HRNInit(5,3,\"高响应比优先\"); schedulingAlgorithm.HRNAlgorithm(0); schedulingAlgorithm.printResult(true); }} 结果：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141开始轮转调度当前就绪队列为:JCB{id=1, serviceTime=1, arriveTime=0, priority=0.0}JCB{id=2, serviceTime=5, arriveTime=1, priority=0.0}JCB{id=3, serviceTime=4, arriveTime=2, priority=0.0}JCB{id=4, serviceTime=6, arriveTime=3, priority=0.0}JCB{id=5, serviceTime=6, arriveTime=4, priority=0.0}-----------------------------------------------------时间片: 0开始调度作业:1, 剩余服务时间: 1时间片: 0结束调度作业:1, 剩余服务时间: 0-----------------------------------------------------时间片: 0开始调度作业:2, 剩余服务时间: 5时间片: 2结束调度作业:2, 剩余服务时间: 3-----------------------------------------------------时间片: 2开始调度作业:3, 剩余服务时间: 4时间片: 4结束调度作业:3, 剩余服务时间: 2-----------------------------------------------------时间片: 4开始调度作业:4, 剩余服务时间: 6时间片: 6结束调度作业:4, 剩余服务时间: 4-----------------------------------------------------时间片: 6开始调度作业:5, 剩余服务时间: 6时间片: 8结束调度作业:5, 剩余服务时间: 4-----------------------------------------------------时间片: 8开始调度作业:2, 剩余服务时间: 3时间片: 10结束调度作业:2, 剩余服务时间: 1-----------------------------------------------------时间片: 10开始调度作业:3, 剩余服务时间: 2时间片: 12结束调度作业:3, 剩余服务时间: 0-----------------------------------------------------时间片: 12开始调度作业:4, 剩余服务时间: 4时间片: 14结束调度作业:4, 剩余服务时间: 2-----------------------------------------------------时间片: 14开始调度作业:5, 剩余服务时间: 4时间片: 16结束调度作业:5, 剩余服务时间: 2-----------------------------------------------------时间片: 16开始调度作业:2, 剩余服务时间: 1时间片: 16结束调度作业:2, 剩余服务时间: 0-----------------------------------------------------时间片: 16开始调度作业:4, 剩余服务时间: 2时间片: 18结束调度作业:4, 剩余服务时间: 0-----------------------------------------------------时间片: 18开始调度作业:5, 剩余服务时间: 2时间片: 20结束调度作业:5, 剩余服务时间: 0就绪队列为空，调度完毕！=====================轮转调度结果为=========================进程名 到达时间 要求服务时间 开始时间 完成时间 周转时间 带权周转时间 平均带权周转时间 1 0 1 0 1 1 1.0 2.3733335 3 2 4 10 12 10 2.5 2.3733335 2 1 5 16 17 16 3.2 2.3733335 4 3 6 16 18 15 2.5 2.3733335 5 4 6 18 20 16 2.6666667 2.3733335开始先来先服务调度当前就绪队列为:JCB{id=1, serviceTime=3, arriveTime=0, priority=0.0}JCB{id=2, serviceTime=10, arriveTime=1, priority=0.0}JCB{id=3, serviceTime=7, arriveTime=2, priority=0.0}JCB{id=4, serviceTime=1, arriveTime=3, priority=0.0}JCB{id=5, serviceTime=1, arriveTime=4, priority=0.0}-----------------------------------------------------时间片: 0开始调度作业:1, 剩余服务时间: 3时间片: 3结束调度作业:1, 剩余服务时间: 0-----------------------------------------------------时间片: 3开始调度作业:2, 剩余服务时间: 10时间片: 13结束调度作业:2, 剩余服务时间: 0-----------------------------------------------------时间片: 13开始调度作业:3, 剩余服务时间: 7时间片: 20结束调度作业:3, 剩余服务时间: 0-----------------------------------------------------时间片: 20开始调度作业:4, 剩余服务时间: 1时间片: 21结束调度作业:4, 剩余服务时间: 0-----------------------------------------------------时间片: 21开始调度作业:5, 剩余服务时间: 1时间片: 22结束调度作业:5, 剩余服务时间: 0就绪队列为空，调度完毕！=====================先来先服务调度结果为=========================进程名 到达时间 要求服务时间 开始时间 完成时间 周转时间 带权周转时间 平均带权周转时间 1 0 3 0 3 3 1.0 8.154286 2 1 10 3 13 12 1.2 8.154286 3 2 7 13 20 18 2.5714285 8.154286 4 3 1 20 21 18 18.0 8.154286 5 4 1 21 22 18 18.0 8.154286开始短作业优先服务调度当前就绪队列为:JCB{id=1, serviceTime=8, arriveTime=0, priority=0.0}JCB{id=2, serviceTime=10, arriveTime=1, priority=0.0}JCB{id=3, serviceTime=1, arriveTime=2, priority=0.0}JCB{id=4, serviceTime=10, arriveTime=3, priority=0.0}JCB{id=5, serviceTime=1, arriveTime=4, priority=0.0}-----------------------------------------------------时间片: 0开始调度作业:1, 剩余服务时间: 8时间片: 8结束调度作业:1, 剩余服务时间: 0-----------------------------------------------------时间片: 8开始调度作业:3, 剩余服务时间: 1时间片: 9结束调度作业:3, 剩余服务时间: 0-----------------------------------------------------时间片: 9开始调度作业:5, 剩余服务时间: 1时间片: 10结束调度作业:5, 剩余服务时间: 0-----------------------------------------------------时间片: 10开始调度作业:2, 剩余服务时间: 10时间片: 20结束调度作业:2, 剩余服务时间: 0-----------------------------------------------------时间片: 20开始调度作业:4, 剩余服务时间: 10时间片: 30结束调度作业:4, 剩余服务时间: 0就绪队列为空，调度完毕！=====================短作业优先服务调度结果为=========================进程名 到达时间 要求服务时间 开始时间 完成时间 周转时间 带权周转时间 平均带权周转时间 1 0 8 0 8 8 1.0 3.72 3 2 1 8 9 7 7.0 3.72 5 4 1 9 10 6 6.0 3.72 2 1 10 10 20 19 1.9 3.72 4 3 10 20 30 27 2.7 3.72开始高响应比优先调度当前就绪队列为:JCB{id=1, serviceTime=1, arriveTime=0, priority=5.41018}JCB{id=2, serviceTime=6, arriveTime=1, priority=5.1338425}JCB{id=3, serviceTime=6, arriveTime=2, priority=3.1670618}JCB{id=4, serviceTime=6, arriveTime=3, priority=2.0463989}JCB{id=5, serviceTime=1, arriveTime=4, priority=4.711568}-----------------------------------------------------时间片: 0开始调度作业:1, 剩余服务时间: 1时间片: 1结束调度作业:1, 剩余服务时间: 0-----------------------------------------------------时间片: 1开始调度作业:2, 剩余服务时间: 6时间片: 7结束调度作业:2, 剩余服务时间: 0-----------------------------------------------------时间片: 7开始调度作业:5, 剩余服务时间: 1时间片: 8结束调度作业:5, 剩余服务时间: 0-----------------------------------------------------时间片: 8开始调度作业:3, 剩余服务时间: 6时间片: 14结束调度作业:3, 剩余服务时间: 0-----------------------------------------------------时间片: 14开始调度作业:4, 剩余服务时间: 6时间片: 20结束调度作业:4, 剩余服务时间: 0就绪队列为空，调度完毕!=====================高响应比优先调度结果为=========================进程名 到达时间 要求服务时间 响应比 开始时间 完成时间 周转时间 带权周转时间 平均带权周转时间 1 0 1 5.41018 0 1 1 1.0 2.1666665 2 1 6 5.1338425 1 7 6 1.0 2.1666665 5 4 1 4.711568 7 8 4 4.0 2.1666665 3 2 6 3.1670618 8 14 12 2.0 2.1666665 4 3 6 2.0463989 14 20 17 2.8333333 2.1666665","link":"/posts/20200107-OS_dispatch.html"},{"title":"java并发编程之Fork-Join分治编程","text":"一、Fork-Join框架 forkjoin即分而治之，在几大排序算法中，快速排序、归并排序、二分查找均用到了分治的思想，即将一个大问题，逐一分解为一个个小问题，将各个子问题的解最终合并为最终解。这里也是如此，将一个大任务分解成若干个小任务（fork），再将这若干的小任务的执行结果进行合并（join）。 二、工作密取fork-join采用工作密取的方式实现线程的工作负载。forkjoinPool中维护了多个线程执行分下的小任务，当当前线程的任务结束后，会自动获取其他线程的任务继续执行，同时也会根据当前工作线程的空闲情况去获取任务较多的线程的task，以达到线程间的平衡，提供CPU利用率。 三、fork-join的实现forkjoin框架提供了两个子类供我们继承使用。分别是：1.RecursiveAction此类主要用于没有返回值的任务。2.RecursiveTask此类主要用于有返回值的任务 两个类都提供了compute的方法，用于生成、调用子任务，完成分治运算。在compute方法中，需要判断当前任务是否达到设置的阈值，如果小于该值，则直接执行，否则，将该任务分割成两个小任务，再让两个小任务调用invokeAll方法，会再次进入compute方法，重复以上工作。最后使用join方法等到子任务执行结束获取其运行的结果，合并即可。 这里使用invokeAll而不是用invoke主要是因为，如果使用invoke会使任务分离开，两个任务中只工作一个任务，而使用invokeAll可以让两个任务同时工作，提高效率。 fork-join的任务是通过ForkJoinPool池来执行，其提供了两种提交方式，submit和invoke，其中，submit是异步提交，不需要等待任务运行完毕即可运行sumbit之后的代码；相反，invoke是同步执行，必须等待任务完成才会执行invoke之后的代码。 四、使用Foke-Join实现数组求和 4.1创建求和任务类自定义阈值，当任务低于该阈值时直接执行，否则进行分割，任务执行完毕后返回子任务合并的结果。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556public class AddTask extends RecursiveTask&lt;Integer&gt; { /** * 阈值 */ private static final int THRESHOLD=10; private int[] nums; //左边界 private int left; //右边界 private int right; public AddTask(int[] nums, int left, int right) { this.nums = nums; this.left = left; this.right = right; } /** * 生成随机数组 * @return */ public static int[] randomNum(){ Random r = new Random(); int[] nums = new int[100]; for(int i=0;i&lt;100;i++){ nums[i] = r.nextInt(100); } return nums; } @Override protected Integer compute() { if (right-left&lt;THRESHOLD){ //任务在阈值范围内，符合要求，执行执行任务 int sum=0; for (int i = left; i &lt;= right; i++) { try { TimeUnit.MILLISECONDS.sleep(1); } catch (InterruptedException e) { e.printStackTrace(); } sum+=nums[i]; } return sum; }else { //任务太大，需要分割成小任务 int mid=(left+right)/2; AddTask leftTask=new AddTask(nums,left,mid); AddTask rightTask=new AddTask(nums,mid+1,right); invokeAll(leftTask,rightTask); //返回子任务合并的结果 return leftTask.join()+rightTask.join(); } }} 4.2创建Add类调用任务类12345678910111213141516 */public class Add { public static void main(String[] args) { ForkJoinPool forkJoinPool=new ForkJoinPool(); int[] nums = AddTask.randomNum(); System.out.println(\"待求和数组:\"+ Arrays.toString(nums)); //创建求和任务 AddTask addTask=new AddTask(nums,0,nums.length-1); forkJoinPool.invoke(addTask); System.out.println(\"求和中。。\"); System.out.println(\"和为:\"+addTask.join()); }} 结果：待求和数组:[34, 38, 71, 98, 38, 51, 35, 67, 59, 58, 33, 64, 65, 40, 30, 49, 67, 15, 4, 3, 5, 10, 94, 17, 24, 43, 94, 52, 53, 81, 7, 70, 25, 90, 96, 3, 84, 73, 54, 11, 42, 97, 18, 11, 95, 28, 14, 74, 95, 91, 53, 48, 69, 71, 91, 64, 25, 72, 3, 74, 77, 90, 22, 36, 77, 86, 41, 53, 92, 15, 30, 5, 51, 86, 60, 49, 76, 91, 15, 38, 55, 37, 24, 58, 53, 58, 75, 77, 34, 41, 88, 50, 91, 25, 56, 83, 14, 3, 75, 7]求和中。。和为:5134 而如果使用submit提交，将数组大小改为10000，就可看到求和中一句话是在任务执行完毕后才会打印，体现同步性。","link":"/posts/20200123-ForkJoin.html"},{"title":"java并发编程之CountDownLatch,CyclicBarrier和Semaphore","text":"一、CountDownLatch CountDownLatch能够让一个线程在等待其他线程全部完成各自任务后再执行。而CountDownLatch是通过计数器来实现的，计数器的初始值即为任务的总数。 举个例子，如，同学聚会结束回家，每个人都要回各自的家，此时计数器的初始值为参加聚会的总人数，而每个人都是一个线程，每个同学到家后，都需要调用countDown方法，对计数器减一，表示完成回家的任务，当所有同学都到家后，主线程才可以执行通知班长全部到家的任务。再比如，所编写的应用程序，希望等待启动框架的线程启动完毕后再执行。 1.1 构造方法1234public CountDownLatch(int count) { if (count &lt; 0) throw new IllegalArgumentException(\"count &lt; 0\"); this.sync = new Sync(count); } CountDownLatch的构造方法需要一个count参数，代表初始任务的数量，往后每当调用一次（CountDownLatch.countDown()方法，count都减一，当count减到0的时候，调用CountDownLatch.await()方法的线程就可以执行其任务。 除此之外，CountDownLatch还有以下几个方法： 1.await(long timeout,TimeUnit unit) 1234public boolean await(long timeout, TimeUnit unit) throws InterruptedException { return sync.tryAcquireSharedNanos(1, unit.toNanos(timeout)); } 此方法在await()的基础上添加了时间限制，如果调用await的线程在到达该时间后，count仍然没有0，其会继续执行，不再等到count到0。 2. public long getCount() 123public long getCount() { return sync.getCount(); } 即获取该CountDownLatch当前的count值 二、Demo应用12345678910111213141516171819202122232425262728293031323334353637383940414243package com.wml.test1.countdownlatch;import java.util.concurrent.CountDownLatch;/** * @author Wang * @date 2020/1/2317:27 */public class CountDownLatchTest { //1. private static CountDownLatch finishEat=new CountDownLatch(1); //2. private static CountDownLatch friends=new CountDownLatch(10); public static void main(String[] args) throws InterruptedException { //3. for (int i = 0; i &lt;10; i++) { new Thread(()-&gt;{ try { //4. finishEat.await(); System.out.println(Thread.currentThread().getName()+\"正在回家\"); //5. friends.countDown(); System.out.println(Thread.currentThread().getName()+\"到家啦\"); } catch (InterruptedException e) { e.printStackTrace(); } },\"同学\"+(i+1)).start(); } System.out.println(\"聚会结束，同学们准备回家\"); //6. finishEat.countDown(); //7. friends.await(); //8. System.out.println(\"同学全部到家\"); }} 说明：1.代码1创建一个结束聚餐的CountDownLatch，finishEat。初始值为1，代表正在聚餐，当主线程调用countDown()时（代码6），count值从1变为0，代表结束聚餐。这时，其他调用finishEat.await();的线程（各个同学回家的线程）由阻塞状态变为执行。2.代码2创建一个同学回家的CountDownLatch，friends。初始值为10，代表参加聚会的10个同学，即10个同学需要执行回家任务。回家的任务需要在代码4finishEat.await();后执行。3.代码3创建10个回家的线程，每个线程中都执行一次friends.countDown();，让friends的count减一4.代码7friends.await();主线程阻塞等待friends的count变为0时开始执行下面的代码。结果： 1234567891011121314聚会结束，同学们准备回家同学1正在回家同学1到家啦同学2正在回家同学2到家啦同学4正在回家同学4到家啦同学3正在回家同学3到家啦同学5正在回家同学5到家啦同学6正在回家同学6到家啦同学全部到家 三、CyclicBarrierCyclic（循环的）Barrier（屏障），该工具做的事情是，当一个线程到达一个屏障（同步点/临界点）时会被阻塞，等待到最后一个线程到达该点后，被拦截阻塞的线程才可以继续执行。比如：同学聚餐，不会是到一个就吃一个，而是到的人先等待，直到所有人都达到饭桌后，才开始吃饭。这里餐桌就类似barrier，每个同学都是一个线程，每个人到饭桌后都被阻塞，直到最后一个同学到达。而因为CyclicBarrier是可循环的，当一组线程到达后，其仍然有效，可以继续下一组循环。 3.1构造方法1.默认构造方法 123public CyclicBarrier(int parties) { this(parties, null); } 传入的参数表示需要拦截的线程总数，每当一个线程调用CyclicBarrier.await()方法后，会通知CyclicBarrier该线程已到达屏障。与CountDownLatch一样，CyclicBarrier也为await提供了超时时间设置。 123456public int await(long timeout, TimeUnit unit) throws InterruptedException, BrokenBarrierException, TimeoutException { return dowait(true, unit.toNanos(timeout)); } 线程阻塞直到到达超时时间。2.高级构造方法 1public CyclicBarrier(int parties, Runnable barrierAction) 该方法使得线程到达障碍后，优先执行barrierAction的操作。 3.2 CyclicBarrier的方法3.2.1 await1234567public int await() throws InterruptedException, BrokenBarrierException { try { return dowait(false, 0L); } catch (TimeoutException toe) { throw new Error(toe); // cannot happen } } 该方法等待所有的线程都到达指定的临界点。但如果当前线程不是最后到达的线程，则出于线程调度目的将其禁用，并使其处于休眠状态，直到发生以下情况之一： 最后一个线程到达 其他线程中断当前线程 其他线程中断等待线程之一 在屏障等待时其他线程超时 其他线程在此屏障上调用reset方法 在await方法中调用的dowait方法以下是dowait源码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566private int dowait(boolean timed, long nanos) throws InterruptedException, BrokenBarrierException, TimeoutException { final ReentrantLock lock = this.lock; lock.lock(); try { final Generation g = generation; if (g.broken) throw new BrokenBarrierException(); //代码1 if (Thread.interrupted()) { breakBarrier(); throw new InterruptedException(); } //代码2 int index = --count; if (index == 0) { // tripped boolean ranAction = false; try { final Runnable command = barrierCommand; if (command != null) command.run(); ranAction = true; nextGeneration(); return 0; } finally { if (!ranAction) breakBarrier(); } } // 代码3 for (;;) { try { if (!timed) trip.await(); else if (nanos &gt; 0L) nanos = trip.awaitNanos(nanos); } catch (InterruptedException ie) { if (g == generation &amp;&amp; ! g.broken) { breakBarrier(); throw ie; } else { // We're about to finish waiting even if we had not // been interrupted, so this interrupt is deemed to // \"belong\" to subsequent execution. Thread.currentThread().interrupt(); } } if (g.broken) throw new BrokenBarrierException(); if (g != generation) return index; if (timed &amp;&amp; nanos &lt;= 0L) { breakBarrier(); throw new TimeoutException(); } } } finally { lock.unlock(); } } 说明：代码1：如果当前线程被中断，会调用breakBarrier方法并抛出InterruptedException异常。breakBarrier方法如下： 12345private void breakBarrier() { generation.broken = true; count = parties; trip.signalAll(); } 1.breakBarrier首先将该代的broken设置为true，代表其被打破。2.generation是CyclicBarrier的一个静态内部类Generation的对象，该对象代表屏障的当前代，可以实现循环等待。broken为true，则该循环结束。3.同时将count重置为parties； count为计数器，parties是CyclicBarrier的构造参数，代表拦截的线程数4.调用trip的signalAll()方法，将所有阻塞的线程唤醒 trip是成员变量Condition的对象，可见是使用Condition实现阻塞队列的。代码2：计数器count减一并赋值给int变量index，如果此时index值为0，则判断当前barrierCommand是否为空，（barrierCommand也是CyclicBarrier的成员变量，为换代前优先执行的任务，其在CyclicBarrier构造方法中传入，如下： 12345public CyclicBarrier(int parties, Runnable barrierAction) { .......... ........... this.barrierCommand = barrierAction; } ），如果不为空，则执行该操作的run()方法。最后置ranAction为true，个人理解代表继续执行，并执行nextGeneration()进入下一代（下一个循环）。nextGeneration()代码如下： 1234567private void nextGeneration() { // signal completion of last generation trip.signalAll(); // set up next generation count = parties; generation = new Generation(); } 在nextGeneration()中唤醒所有阻塞进程，重置计数器，并重新new了一个Generation。而在finally中，如果barrierCommand执行出错，或其他原因，会执行breakBa在这里插入代码片rrier()方法。代码3：无限循环直到发生tripped，断开，中断或超时。timed代表是否开启超时时间，nanos 为设定的超时时间 3.2.2 getNumberWaiting123456789public int getNumberWaiting() { final ReentrantLock lock = this.lock; lock.lock(); try { return parties - count; } finally { lock.unlock(); }} 返回当前有多少个线程阻塞等待在屏障上 3.3 isBroken1boolean isBroken() 返回查询阻塞等待的线程是否被中断打破 四、CyclicBarrier 例子12345678910111213141516171819202122232425262728293031323334353637package com.wml.test1.cyclicbarrier;import java.util.concurrent.*;/** * @author Wang * @date 2020/1/2317:44 */public class CyclicBarrierTest { //代码1 private static CyclicBarrier barrier=new CyclicBarrier(6,()-&gt;{ System.out.println(\"同学们都到齐了，咱们开饭\"); }); public static void main(String[] args) { ExecutorService pool = new ThreadPoolExecutor(6,100,0L,TimeUnit.MILLISECONDS, new LinkedBlockingDeque&lt;&gt;()); for (int i = 1; i &lt;= 6; i++) { pool.execute(() -&gt; { try { System.out.println(Thread.currentThread().getName() + \"到了\"); //代码2 barrier.await(); System.out.println(Thread.currentThread().getName() + \"开吃\"); } catch (InterruptedException e) { e.printStackTrace(); } catch (BrokenBarrierException e) { e.printStackTrace(); } }); } }} 说明：该例子为同学聚餐，每到一个同学便阻塞自己，当所有同学都到齐后，输出“开饭”，然后唤醒所有同学，执行“吃饭” 代码1：构造一个CyclicBarrier 屏障，拦截线程数为6，在进入下一代前执行System.out.println(&quot;同学们都到齐了，咱们开饭&quot;);这一barrierCommand，即当前代结束（所有线程都到达屏障时或其他原因）后优先执行该操作。代码2：每个线程到达屏障后执行await方法，直到所有线程都到达，await中会执行唤醒所有阻塞线程的方法，最后才会执行后面的代码。结果： 12345678910111213pool-1-thread-1到了pool-1-thread-2到了pool-1-thread-3到了pool-1-thread-4到了pool-1-thread-5到了pool-1-thread-6到了同学们都到齐了，咱们开饭pool-1-thread-6开吃pool-1-thread-2开吃pool-1-thread-3开吃pool-1-thread-5开吃pool-1-thread-4开吃pool-1-thread-1开吃 五、CountDownLatch和CyclicBarrier的异同1.CountDownLatch技术器只能使用一次，CyclicBarrier的可以循环使用。2.CountDownLatch是一个线程等待所有线程完成任务后才会执行自己的任务，是阻塞工作线程。CyclicBarrier是所有线程到达某个屏障（临界点）后互相等待，直到所有线程都到达后再共同进行下面的任务。3.CountDownLatch调用countDown方法可以继续执行后面的，只是调用await方法的线程会阻塞等待直到所有线程都调用countDown；CyclicBarrier是所有的线程调用await进行自阻塞，等到所有线程都调用一次await后一起继续执行后面操作。4.CyclicBarrier可以在所有线程都到达屏障后执行barrierAction操作，完成复杂的逻辑场景。 六、SemaphoreSemaphore即信号量，是用来控制同时访问特定资源的线程数量，或同时执行某个指定操作的数量。比如可以用来实现数据库的连接池等。如数据库的连接数为20个，这时只能有20个线程同时获取数据量连接，再多的线程只能阻塞等待，当一个线程归还连接后，阻塞的线程才能继续获取。 Semaphore的构造方法： 1public Semaphore(int permits) 传入一个整型permits，代表可用的许可证数量。操作时必须先获取许可证，才能继续操作，当操作完成后需释放许可证，其余没有获得许可证的便阻塞等待，直到有线程释放了许可证。线程使用Semaphore的acquire()方法获取许可证，使用release()方法释放许可证，使用tryAcquire()方法尝试获取许可证. 其他方法： 12345intavailablePermits() //返回此信号量中当前可用的许可证数。intgetQueueLength() //返回正在等待获取许可证的线程数。booleanhasQueuedThreads()//是否有线程正在等待获取许可证。void reducePermits（ int reduction） //减少 reduction 个许可证Collection getQueuedThreads() //返回所有等待获取许可证的线程集合 semaphore示例：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566package com.wml.test1.semphore;import java.sql.Connection;import java.util.LinkedList;import java.util.Random;import java.util.concurrent.*;/** * @author Wang * @date 2020/1/2416:31 */public class SemphoreTest { private final static int POOL_SIZE=10; private final Semaphore connections; //连接池 private static LinkedList&lt;Integer&gt;pool; public SemphoreTest() { pool=new LinkedList&lt;&gt;(); //初始化连接池 for (int i = 0; i &lt; POOL_SIZE; i++) { pool.addLast(i); } this.connections = new Semaphore(POOL_SIZE); } //释放连接 public void release(Integer conn){ if(conn!=null) { System.out.println(\"当前有\"+connections.getQueueLength()+\"个线程等待数据库连接!!\" +\"可用连接数：\"+connections.availablePermits()); synchronized (pool) { pool.addLast(conn); } connections.release(); } } //获取连接 public Integer acquire() throws InterruptedException { connections.acquire(); Integer conn; synchronized (pool){ conn=pool.removeFirst(); } return conn; } public static void main(String[] args) { SemphoreTest dbPool=new SemphoreTest(); ExecutorService pool = new ThreadPoolExecutor(50,100,0L, TimeUnit.MILLISECONDS, new LinkedBlockingDeque&lt;&gt;()); //50个线程获取连接 for (int i = 0; i &lt; 50; i++) { pool.execute(()-&gt;{ try { Integer conn=dbPool.acquire(); System.out.println(Thread.currentThread().getName() +\"--------获取数据库连接\"); Thread.sleep(1000); System.out.println(\"归还连接\"); dbPool.release(conn); } catch (InterruptedException e) { } }); } }}","link":"/posts/20200124-cdlcbs.html"},{"title":"java多线程之Callable+Future+FutureTask原理详解和简单使用","text":"一、Runnable和CallableRunnable是一个接口，只声明了一个run()方法，此方法为void类型，所以只能执行无返回值的任务。 123public interface Runnable { public abstract void run();} Callable是java.util.concurrent包下的一个接口，提供了一个call()方法: 12345678910@FunctionalInterfacepublic interface Callable&lt;V&gt; { /** * Computes a result, or throws an exception if unable to do so. * * @return computed result * @throws Exception if unable to compute a result */ V call() throws Exception;} 该方法返回的数据类型就是传进来的泛型类型，主要用于计算产生结果。如果没有计算出结果，则会抛出异常。 二、FutureFuture则是对于具体的Runnable或Callable任务的执行结果进行取消、判断是否完成、获取任务执行结果。Future接口声明了5个方法： 1boolean cancel(boolean mayInterruptIfRunning); 尝试取消此任务的执行。如果取消成功则返回true，取消失败则返回false。 如果任务已完成、已取消或由于其他原因无法取消，则此尝试将失败，返回false。传入的参数如果为true，则直接中断正在执行的任务，返回true；如果为false，则允许正在进行的任务完成。 1boolean isCancelled(); 任务是否被取消成功，如果此任务在正常工作之前被取消，则返回true。 1boolean isDone(); 如果此任务已完成，则返回true。完成可能是由于正常终止、异常或取消 - 在所有这些情况下，此方法将返回 true。 1V get() throws InterruptedException, ExecutionException; 以阻塞的方式获取任务执行结果，知道任务执行完毕返回。另外在以下情况会抛出异常：1.任务被取消：抛出 CancellationException 异常2.计算引发异常：抛出 ExecutionException 异常3.当前线程被中断：抛出 InterruptedException 异常 12V get(long timeout, TimeUnit unit) throws InterruptedException, ExecutionException, TimeoutException; 同上，但规定了超时时间，如果在规定时间内没有计算出结果，会抛出TimeoutException异常。 三、FutureTaskFutureTask类实现了RunnableFuture接口，而RunnableFuture继承了Runnable和Future接口，可知FutureTask可做Runnable和Future一样的事情。 123public class FutureTask&lt;V&gt; implements RunnableFuture&lt;V&gt; public interface RunnableFuture&lt;V&gt; extends Runnable, Future&lt;V&gt; 3.1 首先看FutureTask的成员变量1234567891011121314private volatile int state; private static final int NEW = 0; private static final int COMPLETING = 1; private static final int NORMAL = 2; private static final int EXCEPTIONAL = 3; private static final int CANCELLED = 4; private static final int INTERRUPTING = 5; private static final int INTERRUPTED = 6; private Callable&lt;V&gt; callable; private Object outcome; // non-volatile, protected by state reads/writes private volatile Thread runner; private volatile WaitNode waiters; 1.state：state保存了FutureTask任务的状态值，为volatile类型，保证了原子性，即任何一个线程修改了state的值，都可以保证其他线程看到修改后的值。state共有如下几个取值（对应的值依此为0到6）： NEW：为state的初始值。表示该任务是个新任务。COMPLETING:当前任务已经执行完毕或执行任务过程中出现了异常，但结果尚未保存到outcome（outcome用来保存计算结果或者是异常信息）中，属于中间状态。NORMAL: 任务执行完毕，且结果保存到outcome中。此为最终状态。EXCEPTIONAL: 任务执行过程中出现异常，且异常信息已保存到outcome中。此为最终状态。CANCELLED：任务尚未开始或任务执行时调用了cancel(false)方法。此为最终状态。INTERRUPTING：任务尚未开始或任务执行时调用了cancel(true)方法。此为中间状态。INTERRUPTED: 在调用cancel(true)时，会调用: 123Thread t = runner; if (t != null) t.interrupt(); state会变为INTERRUPTED，此为最终状态。但如果被终端的线程正在sleep()、wait()、或join()，则会抛出InterruptedException()异常，因此cancel(true)（注意：中间状态时间短暂，不代表任务仍在执行，而是任务执行完毕后尚未设置执行结果，因此除了NEW状态，其余状态都代表已经执行结束）可能出现的转变状态为： 1234NEW -&gt; COMPLETING -&gt; NORMALNEW -&gt; COMPLETING -&gt; EXCEPTIONALNEW -&gt; CANCELLEDNEW -&gt; INTERRUPTING -&gt; INTERRUPTED 2.callable：要执行的task任务。3.outcome: 保存执行结果或出现异常时保存异常信息4.runner:执行task的线程，在取消和中断线程时需要知道是哪个线程。5.waiters：为WaitNode 的对象。WaitNode 为一个简单的单向链表结构的队列，当任务执行过程中，有线程想要调用get()获取结果时，则该线程会被阻塞加入WaitNode，直到该任务执行完毕。以下为WaitNode的结构： 12345static final class WaitNode { volatile Thread thread; volatile WaitNode next; WaitNode() { thread = Thread.currentThread(); } } 仅由一个Thread和指向下一个节点的next组成，thread即为当前线程。其本质是一个Treiber栈。 3.2静态代码块中初始化需要CAS操作的属性的偏移量12345678910111213141516171819// Unsafe mechanics private static final sun.misc.Unsafe UNSAFE; private static final long stateOffset; private static final long runnerOffset; private static final long waitersOffset; static { try { UNSAFE = sun.misc.Unsafe.getUnsafe(); Class&lt;?&gt; k = FutureTask.class; stateOffset = UNSAFE.objectFieldOffset (k.getDeclaredField(\"state\")); runnerOffset = UNSAFE.objectFieldOffset (k.getDeclaredField(\"runner\")); waitersOffset = UNSAFE.objectFieldOffset (k.getDeclaredField(\"waiters\")); } catch (Exception e) { throw new Error(e); } } CAS操作调用的是compareAndSwap***方法 3.3 构造方法3.3.1 123456public FutureTask(Callable&lt;V&gt; callable) { if (callable == null) throw new NullPointerException(); this.callable = callable; this.state = NEW; // ensure visibility of callable } 将传入的callable赋值给上面说的成员变量callable，将state初始化为NEW；3.3.2 1234public FutureTask(Runnable runnable, V result) { this.callable = Executors.callable(runnable, result); this.state = NEW; // ensure visibility of callable } 传入Runnable对象，通过Executors.callable()方法将runnable转为callable保存给callable变量，同时会返回传入的result。将runnable转为callable的方法如下： 12345public static &lt;T&gt; Callable&lt;T&gt; callable(Runnable task, T result) { if (task == null) throw new NullPointerException(); return new RunnableAdapter&lt;T&gt;(task, result); } 这里调用RunnableAdapter()适配,代码如下： 12345678910111213static final class RunnableAdapter&lt;T&gt; implements Callable&lt;T&gt; { final Runnable task; final T result; RunnableAdapter(Runnable task, T result) { this.task = task; this.result = result; } public T call() { task.run(); return result; } } } RunnableAdapter实现了Callable接口，在call()中调用task.run()，将传入的result返回。 3.4 方法3.4.1 run()1234567891011121314151617181920212223242526272829303132333435public void run() { //代码1 if (state != NEW || !UNSAFE.compareAndSwapObject(this, runnerOffset, null, Thread.currentThread())) return; try { Callable&lt;V&gt; c = callable; if (c != null &amp;&amp; state == NEW) { //代码2 V result; boolean ran; try { result = c.call(); ran = true; } catch (Throwable ex) { result = null; ran = false; setException(ex); } if (ran) set(result); } } finally { // runner must be non-null until state is settled to // prevent concurrent calls to run() //代码3 runner = null; // state must be re-read after nulling runner to prevent // leaked interrupts int s = state; if (s &gt;= INTERRUPTING) handlePossibleCancellationInterrupt(s); } } 代码1：1.state!=NEW: 如果state不为NEW，即任务已经执行完毕或被取消，直接返回。2. 若state是NEW，则尝试将当前线程保存到runner中，即如果runner为空就将当前线程保存给runner，若runner不为空，则说明已经有线程在执行，直接return,否则进入try-catch。 代码2：1.定义V result保存callable的执行结果，置ran为true，代表执行成功。2.若出现异常，则在catch中捕获，将result置为null，ran置为false代表出现异常，同时通过setException(ex)设置异常。setException(ex)代码如下： 1234567protected void setException(Throwable t) { if (UNSAFE.compareAndSwapInt(this, stateOffset, NEW, COMPLETING)) { outcome = t; UNSAFE.putOrderedInt(this, stateOffset, EXCEPTIONAL); // final state finishCompletion(); } } 此方法中，尝试将state的值从NEW改为COMPLETING,如果成功，则将异常信息保存到outcome中，然后再将状态改为最终态EXCEPTIONAL，最后调用finishCompletion()移除并唤醒WaitNode中所有阻塞等待的线程，调用done()，并让callable无效，源码如下： 12345678910111213141516171819202122private void finishCompletion() { // assert state &gt; COMPLETING; for (WaitNode q; (q = waiters) != null;) { if (UNSAFE.compareAndSwapObject(this, waitersOffset, q, null)) { for (;;) { Thread t = q.thread; if (t != null) { q.thread = null; LockSupport.unpark(t); } WaitNode next = q.next; if (next == null) break; q.next = null; // unlink to help gc q = next; } break; } } done(); callable = null; } 如果ran为true，即正常执行，通过set(result)，set()源码如下： 1234567protected void set(V v) { if (UNSAFE.compareAndSwapInt(this, stateOffset, NEW, COMPLETING)) { outcome = v; UNSAFE.putOrderedInt(this, stateOffset, NORMAL); // final state finishCompletion(); } } 在set()中，尝试将状态从NEW变为COMPLETING中间态(这里再重新理解上面说的state的7个状态会更深刻一点)，并将结果保存给outcome，接着将state由COMPLETING转为NORMAL最终状态，同上调用 finishCompletion()。 代码3：1.在finally中重新将runner置空，表明当前线程运行完毕，在下一个线程进入到run()（代码1）方法时，便可通过CAS重新将线程保存到runner。2.若ran为false，即出现了异常，则调用handlePossibleCancellationInterrupt(state)处理异常， 1234567891011121314151617private void handlePossibleCancellationInterrupt(int s) { // It is possible for our interrupter to stall before getting a // chance to interrupt us. Let's spin-wait patiently. if (s == INTERRUPTING) while (state == INTERRUPTING) Thread.yield(); // wait out pending interrupt // assert state == INTERRUPTED; // We want to clear any interrupt we may have received from // cancel(true). However, it is permissible to use interrupts // as an independent mechanism for a task to communicate with // its caller, and there is no way to clear only the // cancellation interrupt. // // Thread.interrupted(); } 在该方法中，如果状态一直是INTERUPING，则一直进行yield()。 3.4.2 get()线程可调用get()方法获取任务执行的结果，如果当前任务尚未执行完毕，则阻塞调用get()方法的线程，直到任务执行结束。 123456789/** * @throws CancellationException {@inheritDoc} */ public V get() throws InterruptedException, ExecutionException { int s = state; if (s &lt;= COMPLETING) s = awaitDone(false, 0L); return report(s); } get()方法中首先判断当前的状态是否小于等于COMPLETING，即任务是否处于尚未开始或尚未结束或结果尚未保存到outcome的状态，如果是，则调用awaitDone(false, 0L);阻塞等待，否则调用report(s)返回执行结果。 report()12345678private V report(int s) throws ExecutionException { Object x = outcome; if (s == NORMAL) return (V)x; if (s &gt;= CANCELLED) throw new CancellationException(); throw new ExecutionException((Throwable)x); } 获取当前结果outcome，如果当前状态为NORMAL，则直接返回结果，如果当前状态大于等于CANCELLED，则抛出CancellationException()异常，其他状态则抛出ExecutionException()异常。 3.4.3 awaitDone()线程调用此方法阻塞等待任务执行结束。 123456789101112131415161718192021222324252627282930313233343536373839404142434445private int awaitDone(boolean timed, long nanos) throws InterruptedException { //若开启超时，则计算截止时间 final long deadline = timed ? System.nanoTime() + nanos : 0L; //创建一个WaitNode节点 WaitNode q = null; //是否进入阻塞队列 boolean queued = false; for (;;) { //代码1 if (Thread.interrupted()) { removeWaiter(q); throw new InterruptedException(); } int s = state; //代码2 if (s &gt; COMPLETING) { if (q != null) q.thread = null; return s; } //代码3 else if (s == COMPLETING) // cannot time out yet Thread.yield(); //代码4 else if (q == null) q = new WaitNode(); //代码5 else if (!queued) queued = UNSAFE.compareAndSwapObject(this, waitersOffset, q.next = waiters, q); //代码6 else if (timed) { nanos = deadline - System.nanoTime(); if (nanos &lt;= 0L) { removeWaiter(q); return state; } LockSupport.parkNanos(this, nanos); } else LockSupport.park(this); }} 方法的参数为 timed(是否开启超时时间)和nanos(若开启超时时间，则此参数为超时时间)（代码1到代码6在一个无限for循环中，不停的进行循环判断） 代码1：如果当前线程被中断，则将阻塞队列waitNode中的该节点给移除，并抛出InterruptedException()异常。代码2：判断当前阻塞线程的状态是否大于COMPLETING，如果大于，则该任务已经执行完毕，如果当前节点非空，则删除该节点的thread，并返回状态。代码3： 如果当前状态为COMPLETING，则说明任务执行完毕，但是执行结果尚未赋值给outcome，此时执行yield让出CPU。代码4：如果当前阻塞等待节点q为空，则新建一个节点。代码5：如果尚未入队列，则将上一个节点的next指向waiters，然后尝试让新的节点q替换waiters，如果尝试成功则queued为true，否则为false。代码6：如果开启了超时限制，则重新计算等待时间，如果 nanos&lt;=0L，即超时了，则移除等待队列中的该节点，并返回当前state；如果没有超时，则继续阻塞重新计算后的时间。如果没有开启超时限制，则直接阻塞等待直到被唤醒。 3.4.4 cancel()1234567891011121314151617181920212223public boolean cancel(boolean mayInterruptIfRunning) { //代码1 if (!(state == NEW &amp;&amp; UNSAFE.compareAndSwapInt(this, stateOffset, NEW, mayInterruptIfRunning ? INTERRUPTING : CANCELLED))) return false; try { //代码2 if (mayInterruptIfRunning) { try { Thread t = runner; if (t != null) t.interrupt(); } finally { // final state UNSAFE.putOrderedInt(this, stateOffset, INTERRUPTED); } } } finally { //代码3 finishCompletion(); } return true; } 代码1：1.如果state不等于NEW，则任务已经执行完毕或出现异常或被取消，直接返回false；2.如果任务尚未开始，则通过CAS尝试将状态从NEW改为mayInterruptIfRunning，若mayInterruptIfRunning为true，代表需要中断任务执行线程，则改为INTERRUPTING中间状态，否则改为CANCELLED最终状态，如果尝试更新成功，则返回true，否则返回false。代码2：如果进行了中断，则获取当前的线程runner，中断之。最后将状态由INTERRUPTING改为INTERRUPTED代码3：执行finishCompltion()(任务出现异常或正常执行完毕或成功取消任务都会调用该方法，上文已提到)，返回true 3.4.5 isCancelled()123public boolean isCancelled() { return state &gt;= CANCELLED; } 判断任务是否被取消。只要状态大于等于CANCELLED都返回true。 3.4.6 isDone()123public boolean isDone() { return state != NEW; } 只要不是NEW，都返回true，代表任务已完成。 四.Callable+Future示例12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455package com.wml.test2.future;import java.util.concurrent.*;/** * @author MaoLin Wang * @date 2020/1/2723:18 */public class FutureDemo { public static class Task implements Callable&lt;Integer&gt;{ private int sum; @Override public Integer call() throws Exception { System.out.println(\"Callable线程开始执行任务\"); Thread.sleep(1500); for (int i = 0; i &lt; 50; i++) { if (Thread.currentThread().isInterrupted()){ System.out.println(\"Callable线程计算任务中断\"); return null; } if (i%2==0){ sum=sum+i; System.out.println(\"sum=\"+sum); } } System.out.println(\"Callable线程执行完毕 计算结果为\"+sum); return sum; } } public static void main(String[] args) { Task task=new Task(); ExecutorService pool = new ThreadPoolExecutor(6,100,0L,TimeUnit.MILLISECONDS, new LinkedBlockingDeque&lt;&gt;()); Future&lt;Integer&gt;future=pool.submit(task); pool.shutdown(); try { Thread.sleep(3000L); System.out.println(\"主线程执行其他任务中.....\"); if (future.get()!=null){ System.out.println(\"主线程获取Callable执行结果:\"+future.get()); }else { System.out.println(\"尚未获取到结果\"); } } catch (InterruptedException e) { e.printStackTrace(); } catch (ExecutionException e) { e.printStackTrace(); } }} 结果： 1234567891011121314151617181920212223242526272829Callable线程开始执行任务sum=0sum=2sum=6sum=12sum=20sum=30sum=42sum=56sum=72sum=90sum=110sum=132sum=156sum=182sum=210sum=240sum=272sum=306sum=342sum=380sum=420sum=462sum=506sum=552sum=600Callable线程执行完毕 计算结果为600主线程执行其他任务中.....主线程获取Callable执行结果:600 五、Callable+FutureTask示例Task类同上 12345678910111213141516171819202122public static void main(String[] args) { ExecutorService pool = new ThreadPoolExecutor(6,100,0L, TimeUnit.MILLISECONDS, new LinkedBlockingDeque&lt;&gt;()); Task task=new Task(); //创建FutureTask任务 FutureTask futureTask=new FutureTask(task); pool.submit(futureTask); pool.shutdown(); try { Thread.sleep(3000L); System.out.println(\"主线程执行其他任务中.....\"); if (futureTask.get()!=null){ System.out.println(\"主线程获取Callable执行结果:\"+futureTask.get()); }else { System.out.println(\"尚未获取到结果\"); } } catch (InterruptedException e) { e.printStackTrace(); } catch (ExecutionException e) { e.printStackTrace(); } } 结果： 1234567891011Callable子线程开始计算！sum=0sum=1sum=3sum=6sum=10sum=15sum=21Cancel................. sum=28Callable子线程计算任务中断！","link":"/posts/20200127-runcalfutask.html"},{"title":"java多线程之CAS操作及相关原子操作类详解","text":"一、原子操作是什么原子操作即不可被中断（分割）的一个或一系列操作，如对于A,B两个操作，如果一个线程操作A，若另一个线程执行B操作时，要么将B执行到结束，要么完全不让B执行，此时对于A和B来说，就是原子的。 二、悲观锁和乐观锁如synchronized就是悲观锁，解决多线程并发问题，以保证事务的完整性。其是基于阻塞的锁机制，如果有一个线程拥有锁后，访问该资源的其他线程就需要阻塞等待，直到获得锁的线程释放锁。CAS操作即是乐观锁，每个线程都可以访问，只有在提交数据的时候检查是否违反了数据的完整性，即每次都尝试去完成某个操作，如果冲突和造成操作失败，就循环重试，直到操作成功为止。 使用synchronized会引出很多问题，如：获得锁的线程一直不释放锁；大量线程竞争资源，可能会造成死锁；被阻塞的线程可能优先级很高却一直无法获取锁。 因此实现原子操作可使用CAS指令。 三、CASCAS 即Compare and Swap，比较并交换。每个CAS操作过程都包括三个运算符：内存地址V、期望值A、新的值B如果操作的时候地址V上的值等于期望的值A，则将地址V上的值更新为B，否则不做任何操作，但要返回原值。循环CAS就是不断的进行CAS操作直到操作成功。可防止内存中共享变量出现脏读脏写的问题。CAS是通过硬件CPU和内存，利用CPU的多处理能力实现硬件层面的阻塞，再加上volatile变量的特性来实现基于原子操作的线程安全。 （1）get变量值(旧值)—–&gt;（2）计算后得到新值——&gt;（3）比较内存中变量值和旧值—–&gt;（4）如果（3）相等，则让新值替换旧值，否则继续（1） 四、CAS实现原子操作的三大问题4.1ABA问题由于CAS在操作值的时候需要检查旧值是否发生变化，如果未变化则更新值，但如果一个值原来是A，变成了B，然后又变为了A，这样虽然值已经发生了变化，但使用CAS进行检查时会发现它的旧值“未变化”。而要解决该问题，就是使用版本号。即给变量添加版本号，每次更新变量都去更新它的版本号，如刚刚A-&gt;B-&gt;A，便变成了 1A-&gt;2B-&gt;3A。就像在家里倒了一杯水，你还没来得及喝，但是被家人喝掉， 然后又给你接满了一杯水，这样如果在不知道的情况下，你会认为这仍然是之前那杯水。又或者你的资金被别人挪用了，然后又还给了你，虽然钱没有变，但造成的问题时那个人已经犯罪了。 4.2循环时间长，开销大如果CAS一直处于自旋不成功状态，CPU的开销会大大增加。 4.3只能保证一个共享变量的原子操作当对一个共享变量执行操作时，可使用循环 CAS 的方式来保证原子操作，但是对多个共享变量操作时，循环 CAS 就无法保证操作的原子性，当然可以用锁。也可以把多个共享变量合并成一个共享变量来操作。如，有两个共享变量 i＝a，j=b，合并一下 ij=ab，然后用 CAS 来操作 ij，然后通过AtomicReference 类来保证引用对象之间的原子性，便实现了多个变量放在一个对象里来进行 CAS 操作。 五、JDK中相关原子操作类的使用5.1概览更新基本类型类：AtomicBoolean，AtomicInteger，AtomicLong更新数组类：AtomicIntegerArray，AtomicLongArray，AtomicReferenceArray更新引用类型：AtomicReference，AtomicMarkableReference，AtomicStampedReference原子更新字段类： AtomicReferenceFieldUpdater，AtomicIntegerFieldUpdater，AtomicLongFieldUpdater 基本数据类型的原子操作类以AtomicInteger为例，其余差不多。 5.2 AtomicInteger常用方法如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112public class AtomicInteger extends Number implements java.io.Serializable { private static final long serialVersionUID = 6214790243416807050L; //获取指针类Unsafe private static final Unsafe unsafe = Unsafe.getUnsafe(); //内存偏移量 private static final long valueOffset; static { try { //通过objectFieldOffset()方法，获取对象属性的偏移量 valueOffset = unsafe.objectFieldOffset (AtomicInteger.class.getDeclaredField(\"value\")); } catch (Exception ex) { throw new Error(ex); } } //当前的变量值 private volatile int value; public AtomicInteger(int initialValue) { //初始化变量值 value = initialValue; } //value初始化为0 public AtomicInteger() { } //返回当前值 public final int get() { return value; } //设置当前值 public final void set(int newValue) { value = newValue; } //懒设置，使用Unsafe.putOrderedObject方法实现，实现非堵塞的写入，最终会将value置为newValue。 //该方法可能出现其他线程在未来很小的一段时间内无法获取到新值，但可获取到旧值 public final void lazySet(int newValue) { unsafe.putOrderedInt(this, valueOffset, newValue); } //以原子方式设置为给定值并返回旧值。 public final int getAndSet(int newValue) { return unsafe.getAndSetInt(this, valueOffset, newValue); } //以下是getAndSetInt源码，通过while循环重试更新值，直到成功，也是通过CAS实现(JDK8版本) /*public final int getAndSetInt(Object var1, long var2, int var4) { int var5; do { var5 = this.getIntVolatile(var1, var2); } while(!this.compareAndSwapInt(var1, var2, var5, var4)); return var5; }*/ //原子更新value，如果当前值等于expect，则设置为update public final boolean compareAndSet(int expect, int update) { return unsafe.compareAndSwapInt(this, valueOffset, expect, update); } //以原子方式将当前值增加一 //返回旧值，底层同getAndSetInt一样使用CAS操作 public final int getAndIncrement() { return unsafe.getAndAddInt(this, valueOffset, 1); } //以原子方式将当前值减一 //返回旧值，CAS操作 public final int getAndDecrement() { return unsafe.getAndAddInt(this, valueOffset, -1); } //以原子方式将给定值delta添加到当前值 //返回旧值，CAS操作 public final int getAndAdd(int delta) { return unsafe.getAndAddInt(this, valueOffset, delta); } //以原子方式将当前值加1，返回新值 public final int incrementAndGet() { return unsafe.getAndAddInt(this, valueOffset, 1) + 1; } //当前值减1，返回新值 public final int decrementAndGet() { return unsafe.getAndAddInt(this, valueOffset, -1) - 1; } //以原子方式将当前值增加delta，返回新值 public final int addAndGet(int delta) { return unsafe.getAndAddInt(this, valueOffset, delta) + delta; } //使用给定函数的结果以原子方式更新当前值，返回更新后的值。给的函数是无副作用的，因为当尝试更新由于线程之间的争用而失败时，它可能会重新应用 public final int updateAndGet(IntUnaryOperator updateFunction) { int prev, next; do { prev = get(); next = updateFunction.applyAsInt(prev); } while (!compareAndSet(prev, next)); return next; } //同上，使用给定函数的结果以原子方式更新当前值，返回更新前的值。应用该函数时，将当前值作为其第一个参数，并将给定的update作为第二个参数。 public final int getAndAccumulate(int x, IntBinaryOperator accumulatorFunction) { int prev, next; do { prev = get(); next = accumulatorFunction.applyAsInt(prev, x); } while (!compareAndSet(prev, next)); return prev; } //同getAndAccumulate，但返回更新后的值 public final int accumulateAndGet(int x, IntBinaryOperator accumulatorFunction) { int prev, next; do { prev = get(); next = accumulatorFunction.applyAsInt(prev, x); } while (!compareAndSet(prev, next)); return next; }} 使用演示： 123456789101112131415161718192021222324252627public class UseAtomicInt { static AtomicInteger atomicInteger = new AtomicInteger(10); public static void main(String[] args) { //返回旧值10 System.out.println(atomicInteger.getAndIncrement()); //返回新值12 System.out.println(atomicInteger.incrementAndGet()); atomicInteger.compareAndSet(12,1); //加24 返回25 System.out.println(atomicInteger.addAndGet(24)); //自定义函数 IntBinarOperImpl intBinarOper=new IntBinarOperImpl(); //传入自定义函数，传入更新值 atomicInteger.accumulateAndGet(1, intBinarOper); //返回26 System.out.println(atomicInteger.get()); }}//自定义函数，实现IntBinaryOperator接口public class IntBinarOperImpl implements IntBinaryOperator { @Override public int applyAsInt(int left, int right) { //简单定义原来的数加上要更新的数 return left+right; }} 5.3 AtomicIntegerArray是提供原子的方式更新数组里的整型，还包括高级原子操作。常用方法如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384public class AtomicIntegerArray implements java.io.Serializable { private static final long serialVersionUID = 2862133569453604235L; //同上 private static final Unsafe unsafe = Unsafe.getUnsafe(); //获取数组第一个元素的偏移地址 private static final int base = unsafe.arrayBaseOffset(int[].class); //存储移位个数 private static final int shift; //保存的数组 private final int[] array; static { //获取该类型的数组中元素的大小(字节)。 int scale = unsafe.arrayIndexScale(int[].class); //scale如果不是2的次幂则抛出异常 if ((scale &amp; (scale - 1)) != 0) throw new Error(\"data type scale not a power of two\"); //计算得到需要移位的个数，即scale的次幂数 shift = 31 - Integer.numberOfLeadingZeros(scale); } //返回第i个元素的地址 private static long byteOffset(int i) { //shift为偏移位数，base为第一个元素的地址，i移shift个位后+基位置得到第i个元素位置 return ((long) i &lt;&lt; shift) + base; } //先检测i是否越界，再调用byteOffset(i)返回 private long checkedByteOffset(int i) { if (i &lt; 0 || i &gt;= array.length) throw new IndexOutOfBoundsException(\"index \" + i); return byteOffset(i); } //构造初始化给定长度数组 public AtomicIntegerArray(int length) { array = new int[length]; } //创建一个新AtomicIntegerArray，其长度与传入数组相同，并从给定数组中复制所有元素。所以当 AtomicIntegerArray 对内部的数组元素进行修改时，不会影响传入的数组。 public AtomicIntegerArray(int[] array) { this.array = array.clone(); } //返回当前位置的元素 public final int get(int i) { //调用checkedByteOffset获取当前位置的元素地址 return getRaw(checkedByteOffset(i)); } //getIntVolatile方法获取数组中offset偏移地址对应的整型field的值,支持volatile load语义。返回该值。 private int getRaw(long offset) { return unsafe.getIntVolatile(array, offset); } //更新第i个位置的值，也需先计算当前位置的元素的offset public final void set(int i, int newValue) { unsafe.putIntVolatile(array, checkedByteOffset(i), newValue); } //同AtomicInteger的lazySet,这里更新第i个位置的元素 public final void lazySet(int i, int newValue) { unsafe.putOrderedInt(array, checkedByteOffset(i), newValue); } public final int getAndSet(int i, int newValue) { return unsafe.getAndSetInt(array, checkedByteOffset(i), newValue); } //如果当前值等于预期值，则以原子方式将数组位置 i 的元素设置成 update 值。 public final boolean compareAndSet(int i, int expect, int update) { return compareAndSetRaw(checkedByteOffset(i), expect, update); } private boolean compareAndSetRaw(long offset, int expect, int update) { return unsafe.compareAndSwapInt(array, offset, expect, update); } //原子的方式让第i个元素加1 public final int getAndIncrement(int i) { return getAndAdd(i, 1); } //原子的方式让第i个元素减1 public final int getAndDecrement(int i) { return getAndAdd(i, -1); } //原子的方式让第i个元素加delta public final int getAndAdd(int i, int delta) { return unsafe.getAndAddInt(array, checkedByteOffset(i), delta); } //还有其他一些方法都和Integer原子类基本一样 简单使用： 123456789101112131415161718192021public class AtomicArray { static int[] value = new int[] { 1, 2,3 }; static AtomicIntegerArray atomicIntegerArray = new AtomicIntegerArray(value); public static void main(String[] args) { //返回第一个位置的元素 2 System.out.println(atomicIntegerArray.get(1)); //更新第1个位置的元素 atomicIntegerArray.set(1,4); //返回4 System.out.println(atomicIntegerArray.get(1)); //设置第0个位置为3，返回更新前的值 1 System.out.println( atomicIntegerArray.getAndSet(0, 3)); //返回更新后的3 System.out.println(atomicIntegerArray.get(0)); //返回1，原数组不会变化 System.out.println(value[0]); atomicIntegerArray.compareAndSet(0,3,4); System.out.println(atomicIntegerArray.get(0)); }} 5.4 更新引用类型原子更新基本类型的 AtomicInteger，只能更新一个变量，如果要原子更新多个变量，就需要使用这个原子更新引用类型提供的类。Atomic 包提供了以下 3类。AtomicReference，AtomicStampedReference，AtomicMarkableReference 5.5 AtomicReference方法同前面几个类基本一样，但支持泛型，可传入对象,支持对对象的原子操作。 5.6 AtomicStampedReference和AtomicMarkableReferenceAtomicStampedReference 使用版本戳的记录每次改变后的版本号，这样的话就不会存在 ABA问题了。AtomicMarkableReference跟 AtomicStampedReference 基本相同，AtomicStampedReference 在Pair类 中使用 int类型的stamp 作为计数器，每次操作都更新版本，关注的的是动过几次。AtomicMarkableReference 在 Pair类 使用的是 boolean 类型的mark，关注的的是有没有被动过。 AtomicStampedReference源码如下： 首先定义了一个Pair内部类： 1234567891011private static class Pair&lt;T&gt; { final T reference; final int stamp; private Pair(T reference, int stamp) { this.reference = reference; this.stamp = stamp; } static &lt;T&gt; Pair&lt;T&gt; of(T reference, int stamp) { return new Pair&lt;T&gt;(reference, stamp); } } 该类将元素的值(reference)和版本号(stamp)都维护在自己身上。 成员变量 12345678910111213141516171819//声明Pair类型变量private volatile Pair&lt;V&gt; pair;//获取Unsafeprivate static final sun.misc.Unsafe UNSAFE = sun.misc.Unsafe.getUnsafe();//使用unsafe获取偏移量保存到pairOffsetprivate static final long pairOffset = objectFieldOffset(UNSAFE, \"pair\", AtomicStampedReference.class); static long objectFieldOffset(sun.misc.Unsafe UNSAFE, String field, Class&lt;?&gt; klazz) { try { return UNSAFE.objectFieldOffset(klazz.getDeclaredField(field)); } catch (NoSuchFieldException e) { // Convert Exception to corresponding Error NoSuchFieldError error = new NoSuchFieldError(field); error.initCause(e); throw error; //后面两个放在源码的最后，不太好找 构造方法 123public AtomicStampedReference(V initialRef, int initialStamp) { pair = Pair.of(initialRef, initialStamp); } 传入初始值和初值版本戳保存到pair。 方法 4.1. getReference()和getStamp()：返回元素值和返回版本戳 123456public V getReference() { return pair.reference; } public int getStamp() { return pair.stamp; } 4.2 get() 123456//返回当前元素的值，并将当前元素的版本号保存到传入的数组中的第一个位置public V get(int[] stampHolder) { Pair&lt;V&gt; pair = this.pair; stampHolder[0] = pair.stamp; return pair.reference; } 4.3 casPair() 12345//cmp:期望的pair,val：新的pair//CAS更新当前的pairprivate boolean casPair(Pair&lt;V&gt; cmp, Pair&lt;V&gt; val) { return UNSAFE.compareAndSwapObject(this, pairOffset, cmp, val); } 4.4 compareAndSet() 该方法首先判断期望的值和版本戳是否和当前的值和版本戳相同，如果不相同则直接返回false，如果相同则继续比较新的值和版本戳是否和当前值相同，如果相同则直接返回true，否则对当前的pair进行CAS操作。 12345678910111213141516171819/** * 原子的修改元素的值和版本戳 * @param 期望值 * @param 新值 * @param 期望版本戳 * @param 新版本戳 */ public boolean compareAndSet(V expectedReference, V newReference, int expectedStamp, int newStamp) { Pair&lt;V&gt; current = pair; return expectedReference == current.reference &amp;&amp; expectedStamp == current.stamp &amp;&amp; ((newReference == current.reference &amp;&amp; newStamp == current.stamp) || casPair(current, Pair.of(newReference, newStamp))); } 4.5 weakCompareAndSet() 其代码同compareAndSet无差别，但在JDK9中，两个方法都添加了@HotSpotIntrinsicCandidate注解，使用该注解的方法在JVM中都有一套基于CPU指令的高效的实现，且会在运行时会替代JDK的源码实现，从而获得更高的效率。即HotSpot可能会手动实现这个方法。参考：https://blog.csdn.net/lzcaqde/article/details/80868854的解读。 12345678// 同compareAndSet，但可能不能保证原子性public boolean weakCompareAndSet(V expectedReference, V newReference, int expectedStamp, int newStamp) { return compareAndSet(expectedReference, newReference, expectedStamp, newStamp); } 4.6 set() 12345678910/** * 源码解释无条件更新当前元素的值和版本戳 * @param newReference 新值 * @param newStamp 新版本戳 */public void set(V newReference, int newStamp) { Pair&lt;V&gt; current = pair; if (newReference != current.reference || newStamp != current.stamp) this.pair = Pair.of(newReference, newStamp); } 4.7 attemptStamp() 如果引用对象为期望值，则重新设置新的版本戳。 1234567public boolean attemptStamp(V expectedReference, int newStamp) { Pair&lt;V&gt; current = pair; return expectedReference == current.reference &amp;&amp; (newStamp == current.stamp || casPair(current, Pair.of(expectedReference, newStamp))); } 示例： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647public class UseAtomicStampedReference { /** * 设置初始值和初始版本戳 */ static AtomicStampedReference&lt;String&gt; asr = new AtomicStampedReference(\"wml\",0); public static void main(String[] args) throws InterruptedException { //拿到当前的版本号(旧) final int oldStamp = asr.getStamp(); final String oldReference = asr.getReference(); System.out.println(\"旧值：\"+oldReference+\"，旧版本戳：\"+oldStamp); Thread rightStampThread = new Thread(() -&gt; { System.out.println(Thread.currentThread().getName()+\":当前变量值：\" +oldReference + \"，当前版本戳：\" + oldStamp ); //更新引用对象值和版本戳 asr.compareAndSet(oldReference, \"wml222\", oldStamp, oldStamp + 1); int[] stampHolder=new int[2]; stampHolder[0]=0; //调用get，返回当前值，并将版本保存到stampHolder[0]中 asr.get(stampHolder); //打印当前版本 System.out.println(\"使用get()获取版本：\"+stampHolder[0]); }); Thread errorStampThread = new Thread(() -&gt; { String reference = asr.getReference(); System.out.println(Thread.currentThread().getName()+\":当前变量值：\" +reference + \"，当前版本戳：\" + asr.getStamp()); //更新引用对象值和版本戳 asr.compareAndSet(reference, \"wml333\", oldStamp, oldStamp + 1); }); rightStampThread.start(); rightStampThread.join(); errorStampThread.start(); errorStampThread.join(); System.out.println(\"Main线程:当前变量值：\" +asr.getReference() + \"，当前版本戳：\" + asr.getStamp()); asr.set(\"set新值\",3); System.out.println(\"使用set更新:当前变量值：\" +asr.getReference() + \"，当前版本戳：\" + asr.getStamp()); }} 线程errorStampThread没有使用更新后的版本戳作为期望版本，因此该线程CAS失败。 5.7 原子更新字段类atomic包提供了AtomicIntegerFieldUpdater，AtomicLongFieldUpdater，AtomicReferenceFieldUpdater三个类实现原子的更新某个类的某个字段。以AtomicReferenceFieldUpdater为例：更新字段类需要两步：1.由于原子更新字段类都是抽象类，每次必须使用静态方法 newUpdater()创建一个更新器，并且传入要更新的类，字段类型和字段名。2.更新类的字段（属性）必须使用 public volatile修饰符。其他注意点：1.变量不可使用static、final关键字。2.变量的描述符类型必须与调用者一致。否则调用者不能调用变量也就不能通过反射操作保证原子性。 每个更新字段类都是一个抽象类，内部有一个AtomicXXXXFieldUpdaterImpl实现类，相关代码如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485 private static final class AtomicReferenceFieldUpdaterImpl&lt;T,V&gt; extends AtomicReferenceFieldUpdater&lt;T,V&gt; { // 获取Unsafe private static final sun.misc.Unsafe U = sun.misc.Unsafe.getUnsafe(); // 当前变量的内存偏移量 private final long offset; // 如果要操作的类的字段被protected修饰，则cclass为调用者类的class对象，否则cclass为tclass。 private final Class&lt;?&gt; cclass; // 要操作的类的class对象 private final Class&lt;T&gt; tclass; // 要操作的类字段的class对象 private final Class&lt;V&gt; vclass; /** * @param tclass 即上面的tclass * @param vclass 要操作的类字段的class对象 * @param fieldName 被操作的字段名 * @param caller 调用者类的class对象 */ AtomicReferenceFieldUpdaterImpl(final Class&lt;T&gt; tclass, final Class&lt;V&gt; vclass, final String fieldName, final Class&lt;?&gt; caller) { //原子更新的字段 final Field field; //原子更新字段的class对象 final Class&lt;?&gt; fieldClass; //原子更新字段的修饰符 final int modifiers; try { //利用反射机制获取tclass的field field = AccessController.doPrivileged( new PrivilegedExceptionAction&lt;Field&gt;() { public Field run() throws NoSuchFieldException { return tclass.getDeclaredField(fieldName); } }); //获取该字段的修饰符 modifiers = field.getModifiers(); //检查该字段的访问权限，无法访问则抛出对应异常信息 sun.reflect.misc.ReflectUtil.ensureMemberAccess( caller, tclass, null, modifiers); //获取对应class的类加载器 ClassLoader cl = tclass.getClassLoader(); ClassLoader ccl = caller.getClassLoader(); if ((ccl != null) &amp;&amp; (ccl != cl) &amp;&amp; ((cl == null) || !isAncestor(cl, ccl))) { sun.reflect.misc.ReflectUtil.checkPackageAccess(tclass); } fieldClass = field.getType(); } catch (PrivilegedActionException pae) { throw new RuntimeException(pae.getException()); } catch (Exception ex) { throw new RuntimeException(ex); } if (vclass != fieldClass) throw new ClassCastException(); if (vclass.isPrimitive()) throw new IllegalArgumentException(\"Must be reference type\"); if (!Modifier.isVolatile(modifiers)) throw new IllegalArgumentException(\"Must be volatile type\"); //首先判断字段修饰符是否为protected // 再判断tclass和caller是否相同或者是另一个类的子类 this.cclass = (Modifier.isProtected(modifiers) &amp;&amp; tclass.isAssignableFrom(caller) &amp;&amp; !isSamePackage(tclass, caller)) ? caller : tclass; this.tclass = tclass; this.vclass = vclass; this.offset = U.objectFieldOffset(field); } //如果可以在第一个类加载器的委托链中找到第二个类加载器，则返回true private static boolean isAncestor(ClassLoader first, ClassLoader second) { ClassLoader acl = first; do { acl = acl.getParent(); if (second == acl) { return true; } } while (acl != null); return false; } 原子更新类的方法同atomic包下的其他类基本相同，但是该类在进行CAS前，需要先进行类型检查，如下： 123456789101112131415//检查目标参数是否是类的实例。失败时，抛出原因。 private final void accessCheck(T obj) { if (!cclass.isInstance(obj)) throwAccessCheckException(obj);}//检查目标参数是否是对应字段的类型，如果不是则抛出异常private final void valueCheck(V v) { if (v != null &amp;&amp; !(vclass.isInstance(v))) throwCCE(); } public final boolean compareAndSet(T obj, V expect, V update) { accessCheck(obj); valueCheck(update); return U.compareAndSwapObject(obj, offset, expect, update);} 使用示例： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849public class AtomicReferenceFieldUpdaterDemo { /** * 定义AtomicReferenceFieldUpdater，传入要操作的类User，以及原子操作的字段age的class对象Integer.class和字段名age，这里字段必须为引用类型，如果是int类型的则需使用 */ static AtomicReferenceFieldUpdater arf = AtomicReferenceFieldUpdater.newUpdater(User.class, Integer.class, \"age\"); /** * 定义AtomicIntegerFieldUpdater，传入要操作的类User，以及原子操作的字段名grade */ static AtomicIntegerFieldUpdater aif=AtomicIntegerFieldUpdater.newUpdater(User.class,\"grade\"); public static void main(String[] args) throws InterruptedException { User user = new User(); user.age=19; user.grade=0; //CAS修改为20 arf.compareAndSet(user, 19, 20); //输出20 System.out.println(arf.get(user)); //修改为21，返回修改前的 20 System.out.println(arf.getAndSet(user,21)); //修改后为21 System.out.println(user.age); ThreadPoolExecutor poolExecutor = new ThreadPoolExecutor(500, 1000, 0L, TimeUnit.MILLISECONDS, new LinkedBlockingDeque()); //开500个线程增加grade字段 for (int i = 0; i &lt; 500; i++) { poolExecutor.execute(()-&gt;{ aif.incrementAndGet(user); }); } poolExecutor.shutdown(); Thread.sleep(2000L); System.out.println(\"增加后的grade为:\"+aif.get(user)); aif.compareAndSet(user,500,1000); System.out.println(\"修改后的grade为\"+aif.get(user)); }}class User { protected volatile Integer age; protected volatile int grade;} 结果： 12345202021增加后的grade为:500修改后的grade为1000 参考：https://zhuanlan.zhihu.com/p/65240318","link":"/posts/20200130-java%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%B9%8BCAS%E6%93%8D%E4%BD%9C%E5%8F%8A%E7%9B%B8%E5%85%B3%E5%8E%9F%E5%AD%90%E6%93%8D%E4%BD%9C%E7%B1%BB%E8%AF%A6%E8%A7%A3.html"}],"tags":[{"name":"elasticsearch","slug":"elasticsearch","link":"/tags/elasticsearch/"},{"name":"docker","slug":"docker","link":"/tags/docker/"},{"name":"centos7","slug":"centos7","link":"/tags/centos7/"},{"name":"firewall","slug":"firewall","link":"/tags/firewall/"},{"name":"linux","slug":"linux","link":"/tags/linux/"},{"name":"gulp,压缩静态资源","slug":"gulp-压缩静态资源","link":"/tags/gulp-%E5%8E%8B%E7%BC%A9%E9%9D%99%E6%80%81%E8%B5%84%E6%BA%90/"},{"name":"jib","slug":"jib","link":"/tags/jib/"},{"name":"文件上传","slug":"文件上传","link":"/tags/%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0/"},{"name":"fdfs","slug":"fdfs","link":"/tags/fdfs/"},{"name":"排序","slug":"排序","link":"/tags/%E6%8E%92%E5%BA%8F/"},{"name":"数据结构","slug":"数据结构","link":"/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"二叉树","slug":"二叉树","link":"/tags/%E4%BA%8C%E5%8F%89%E6%A0%91/"},{"name":"调度算法","slug":"调度算法","link":"/tags/%E8%B0%83%E5%BA%A6%E7%AE%97%E6%B3%95/"},{"name":"分治","slug":"分治","link":"/tags/%E5%88%86%E6%B2%BB/"},{"name":"并发编程","slug":"并发编程","link":"/tags/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"},{"name":"fork/join","slug":"fork-join","link":"/tags/fork-join/"},{"name":"CountDownLatch","slug":"CountDownLatch","link":"/tags/CountDownLatch/"},{"name":"CyclicBarrier","slug":"CyclicBarrier","link":"/tags/CyclicBarrier/"},{"name":"Semaphore","slug":"Semaphore","link":"/tags/Semaphore/"},{"name":"Runnable","slug":"Runnable","link":"/tags/Runnable/"},{"name":"Callable","slug":"Callable","link":"/tags/Callable/"},{"name":"Future","slug":"Future","link":"/tags/Future/"},{"name":"FutureTask","slug":"FutureTask","link":"/tags/FutureTask/"},{"name":"多线程","slug":"多线程","link":"/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"},{"name":"CAS","slug":"CAS","link":"/tags/CAS/"},{"name":"原子操作类","slug":"原子操作类","link":"/tags/%E5%8E%9F%E5%AD%90%E6%93%8D%E4%BD%9C%E7%B1%BB/"},{"name":"AtomicXXX","slug":"AtomicXXX","link":"/tags/AtomicXXX/"}],"categories":[{"name":"docker","slug":"docker","link":"/categories/docker/"},{"name":"linux","slug":"linux","link":"/categories/linux/"},{"name":"工具","slug":"工具","link":"/categories/%E5%B7%A5%E5%85%B7/"},{"name":"springboot","slug":"springboot","link":"/categories/springboot/"},{"name":"数据结构","slug":"数据结构","link":"/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"排序","slug":"数据结构/排序","link":"/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%8E%92%E5%BA%8F/"},{"name":"二叉树","slug":"数据结构/二叉树","link":"/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E4%BA%8C%E5%8F%89%E6%A0%91/"},{"name":"操作系统","slug":"操作系统","link":"/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"},{"name":"并发编程","slug":"并发编程","link":"/categories/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"},{"name":"并发工具类","slug":"并发编程/并发工具类","link":"/categories/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/%E5%B9%B6%E5%8F%91%E5%B7%A5%E5%85%B7%E7%B1%BB/"}]}