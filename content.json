{"pages":[{"title":"文章分类","text":"","link":"/categories/index.html"},{"title":"","text":"图片搜集于互联网，侵权请留言，马上处理😊。","link":"/gallery/index.html"},{"title":"相册","text":"","link":"/photo/index.html"},{"title":"标签","text":"","link":"/tags/index.html"}],"posts":[{"title":"docker安装ES","text":"123456789101112131415161718192021222324docker pull elasticsearch:6.4.0 //再低就是5.x了1.vim /etc/security/limits.d/90-nproc.conf 添加：soft nproc 40962. vim /etc/sysctl.conf 添加vm.max_map_count=655360 执行sysctl -p刷新配置//根据自己的内存大小适当调整，太大会启动失败3.docker run -e ES_JAVA_OPTS=\"-Xms512m -Xmx512m\" -d -p 9200:9200 -p 9300:9300 --name=myES 容器id4.docker exec -it 容器名 /bin/bash 进入容器命令行5.vim config/elasticsearch.yml 地址改为0.0.0.0可能会vim不可用 执行 yum update yum install -y vim6.安装ik分词器先上传到宿主机，再使用以下命令copy到容器中docker cp 宿主机ik分词器地址 容器名:/usr/share/elasticsearch/plugins/ik","link":"/posts/20200106-docker_es.html"},{"title":"centos7查看防火墙以及开放和关闭端口","text":"查看某个端口是否开放 1firewall-cmd --query-port=22122/tcp yes/no 开放/未开放 开放指定端口1firewall-cmd --add-port=22122/tcp --permanent firewall-cmd –zone=public –add-port=80/tcp –permanent-zone #作用域-permanent 没有该参数重启后失效 重新加载端口： 1firewall-cmd --reload 3.关闭某个端口 1firewall-cmd --permanent --remove-port=22122/tcp 重新加载 4. 查看防火墙状态 123firewall-cmd --state或者:systemctl status firewalld 打开/关闭防火墙 启动：systemctl start firewalld关闭： systemctl stop firewalld开机启用 ： systemctl enable firewalld禁止firewall开机启动 ：systemctl disable firewalld.service启动服务：systemctl start firewalld.service关闭服务：systemctl stop firewalld.service重启服务：systemctl restart firewalld.service 查看端口占用情况 1netstat -anp 查看防火墙已开放的端口 1firewall-cmd --list-ports","link":"/posts/20200107-centos7_firewall.html"},{"title":"hexo压缩静态资源","text":"1.安装gulp1.1首先全局安装gulp1npm install gulp -g 1.2 再局部安装相关插件1npm install gulp-imagemin gulp gulp-minify-css gulp-minify-html gulp-uglify -- 1234567# 解决【Gulp打包问题】 GulpUglifyError: unable to minify JavaScript# 解决 gulp-uglify 压缩JavaScript 不兼容 es5 语法的问题npm install babel-core@6.26.3 --savenpm install gulp-babel@7.0.1 --savenpm install babel-preset-es2015@6.24.1 --save# gulp-babel 取消严格模式方法(\"use strict\")npm install babel-plugin-transform-remove-strict-mode --save 2.在网站根目录创建gulpfile.js文件，用来配置压缩1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859var gulp = require('gulp');//Plugins模块获取var minifycss = require('gulp-minify-css');var uglify = require('gulp-uglify');var minifyhtml = require('gulp-minify-html');var imagemin = require('gulp-imagemin')var babel = require('gulp-babel');// 压缩 public 目录 css文件gulp.task('minify-css', function () { return gulp.src('./public/**/*.css') .pipe(minifycss()) .pipe(gulp.dest('./public'));});// 压缩 public 目录 html文件gulp.task('minify-html', function () { return gulp.src('./public/**/*.html') .pipe(minifyhtml()) .pipe(gulp.dest('./public'))});// 压缩js文件gulp.task('minify-js', function (done) { return gulp.src(['./public/**/*.js', '!./public/**/*.min.js','!./public/js/src/snow.js']) .pipe(babel({ //将ES6代码转译为可执行的JS代码 presets: [['es2015',{strict:false}]] // es5检查机制 })) .pipe(uglify()) .pipe(gulp.dest('./public')); done();});// 压缩public/posts 目录 图片文件gulp.task('minify-img', function () { return gulp.src(['./public/images/**/*.*','./source/gallery/**']) .pipe(imagemin( [ imagemin.gifsicle({ 'optimizationLevel': 3 }), imagemin.jpegtran({ 'progressive': true }), imagemin.optipng({ 'optimizationLevel': 7 }), imagemin.svgo() ], { 'verbose': true })) .pipe(gulp.dest('./public'))});// 分别执行css、heml、js和图片的压缩任务gulp.task('build', gulp.series('minify-css', 'minify-html', 'minify-js', 'minify-img')); 3.在网站根目录创建.babelrc1234{ 'presets': ['es2015'], \"plugins\": [\"transform-remove-strict-mode\"]} 4.执行压缩1hexo clean&amp;&amp;hexo g &amp;&amp;gulp build 不兼容ES5的解决参考:https://segmentfault.com/a/1190000019842178?utm_source=tag-newest","link":"/posts/20200111-hexo-gulp.html"},{"title":"jib打包项目到阿里镜像","text":"​ Jib 将处理将应用打包到容器镜像过程中的所有步骤，它直接与 Maven 和 Gradle Java 开发环境集成，不需要你编写 Dockerfile 或安装 Docker（但想要运行还是要本地安装docker） ，只需将其作为插件添加到你的构建中，就可以立即将 Java 应用容器化。 图片来源于https://www.oschina.net/news/97892/google-opensource-jib 一、在pom文件中引入jib插件1234567891011121314151617181920212223242526272829303132333435363738394041424344&lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt; &lt;/plugin&gt; &lt;plugin&gt; &lt;groupId&gt;com.google.cloud.tools&lt;/groupId&gt; &lt;artifactId&gt;jib-maven-plugin&lt;/artifactId&gt; &lt;version&gt;1.7.0&lt;/version&gt; &lt;configuration&gt; &lt;!--拉取的镜像的配置，默认为gcr.io/distroless/java--&gt; &lt;from&gt; &lt;image&gt;基础镜像地址&lt;/image&gt; &lt;auth&gt; &lt;username&gt;阿里云用户名&lt;/username&gt; &lt;password&gt;阿里云密码&lt;/password&gt; &lt;/auth&gt; &lt;/from&gt; &lt;to&gt; &lt;image&gt;基础镜像地址&lt;/image&gt; &lt;auth&gt; &lt;username&gt;阿里云用户名&lt;/username&gt; &lt;password&gt;阿里云密码&lt;/password&gt; &lt;/auth&gt; &lt;tags&gt; &lt;tag&gt;版本号&lt;/tag&gt; &lt;/tags&gt; &lt;/to&gt; &lt;allowInsecureRegistries&gt;true&lt;/allowInsecureRegistries&gt; &lt;/configuration&gt; &lt;executions&gt; &lt;execution&gt; &lt;phase&gt;package&lt;/phase&gt; &lt;goals&gt; &lt;goal&gt;build&lt;/goal&gt; &lt;/goals&gt; &lt;/execution&gt; &lt;/executions&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/build&gt; 版本号这里一开始指定的自定义版本，但是使用jib:build时报错，说找不到latest版本，不知道是不是默认拉取latest，但是网上其他博主好像并没有这个情况，这里就只好将tag设为latest了 二、github创建仓库添加Dockerfile文件 三、阿里云创建镜像仓库3.1 创建仓库点击下一步，根据提示选择Dockerfile所在仓库 进入新创建的仓库，点击添加规则这里版本起名latest，原因上面解释了，有知道的伙伴还请告知 感谢~ 点击构建，等待一会，下方日志中会显示构建的镜像和状态 最后返回基本信息，复制公网地址，放在from和to的image中，一定要填写username和password最后执行 jib:build即可成功 成功! 最后在docker中拉取就可以了 1docker run -d --name testjib-p 8081:8081 刚刚复制的公网地址:latest(对应的镜像版本号)","link":"/posts/20200106-jib_ali.html"},{"title":"mavon-editor+springboot+fdfs上传文件","text":"一、安装mavon直接npm install下就可以了，然后在main.js引入：12import mavonEditor from 'mavon-editor'Vue.use(mavonEditor) 二、页面使用1234567891011&lt;mavon-editor v-show=\"!articleModal\" id=\"editor\" v-model=\"value\" fontSize=\"16px\" ref=\"md\" @imgAdd=\"$imgAdd\" @imgDel=\"$imgDel\" @change=\"handleChange\" @fullScreen=\"handleFullScreen\" /&gt; 这里只需要关注@imgAdd，为添加图片的事件 三、上传文件这里使用的是批量上传，所以每触发一次@imgAdd就向文件集合添加一次 1234567/** * 添加文件到文件集合中 */ $imgAdd(pos, $file) { // 缓存图片信息 this.img_file[pos] = $file; }, data中定义如下： 1img_file: {}, //文件集合 上传文件方法： 123456789101112131415161718192021222324/** * 上传文件 */ uploadimg($e) { var formdata = new FormData(); for (var _img in this.img_file) { formdata.append(\"files\", this.img_file[_img]); } uploadApi.uploadFileList(formdata).then(res =&gt; { console.log(res); const resData = res.data.data; /** * 例如：返回数据为 res = [[pos, url], [pos, url]...] * pos 为原图片标志（0） * url 为上传后图片的url地址 */ // 第二步.将返回的url替换到文本原位置![...](0) -&gt; ![...](url) for (var i = 0; i &lt; resData.length; i++) { this.$refs.md.$img2Url(i + 1, resData[i]); } }); } 然后在需要上传的时候调用一下这个方法就可以啦 四、后台进行上传4.1Controller123456789101112131415/** * 文章多文件上传 * @param files * @return 返回图片地址 */ @PostMapping(value = \"/files\",produces = MediaType.APPLICATION_JSON_UTF8_VALUE) public Result uploadMultiFiles(@RequestParam(\"files\") MultipartFile[] files){ try { List&lt;String&gt; resultList = uploadService.uploadMultiFiles(files); return new Result(true,StatusCode.OK,\"上传成功\",resultList); }catch (Exception e){ return new Result(false,StatusCode.ERROR,\"啊哦~图片上传出现了点小错误，请稍后再上传\"); } } 4.2、Service123456789101112131415161718192021222324252627282930313233343536/** * 批量上传 * @param files */ public List&lt;String&gt; uploadMultiFiles(MultipartFile[] files) { List&lt;String&gt; resultList=new ArrayList&lt;&gt;(); for (MultipartFile file : files) { try { //校验文件内容 BufferedImage image = ImageIO.read(file.getInputStream()); if (image == null) { throw new MyException(ExceptionEnum.INVALID_FILE_TYPE); } //获取拓展名 String extension = StringUtils.substringAfterLast(file.getOriginalFilename(), \".\"); //上传到FastDFS StorePath storePath = storageClient.uploadFile(file.getInputStream(), file.getSize(), extension, null); //不加http://前端无法显示 resultList.add(\"http://\"+uploadProperties.getBaseUrl() + storePath.getFullPath()); //返回路径 } catch (IOException e) { //上传失败 LOGGER.error(\"[文件上传]文件\"+file.getOriginalFilename()+\"上传失败!\", e); throw new MyException(ExceptionEnum.UPLOAD_FILE_ERROR); } } return resultList; } Fdfs的相关配置在这篇文章写啦(不好意思比较懒)：https://blog.csdn.net/weixin_43696529/article/details/102727220","link":"/posts/20200106-mavon_boot_fdfs.html"},{"title":"冒泡排序---------java实现","text":"一、冒泡排序 平均时间复杂度: O(n²)最差时： O(n²)是否稳定： 稳定空间开销：O（1）适合n较小时 原始数组：3 ， 9， -1， 8, 2 第一趟排序：（1） 3， 9， -1， 8，2（2） 3， -1， 9，8， 2（3） 3， -1， 8， 9， 2（4）3， -1， 8， 2， 9 9确定 第二趟排序：（1）-1，3， 8， 2， 9（2）-1, 3， 8， 2， 9（3）-1，3，2， 8， 9 8 , 9确定第三趟排序：（1）-1，3 ，2 ，8 ， 9（2）-1， 2， 3 ，8 ，9 3， 8， 9确定第四趟排序：（1）-1， 2， 3， 8， 9 (2， 3， 8， 9确定) 实现： 123456789101112131415161718int[] array = {3, 9, -1, 8, 2}; int temp=0; for (int i=0; i&lt; array.length-1;i++){ System.out.println(\"开始第\"+(i+1)+\"趟排序\"); for (int j=0;j&lt;array.length-1-i;j++){ if (array[j]&gt;array[j+1]){ temp=array[j]; array[j]=array[j+1]; array[j+1]=temp; } System.out.println(Arrays.toString(array)); } System.out.println(\"第\"+(i+1)+\"趟排序结果：\"); System.out.println(Arrays.toString(array)); System.out.println(\"------------------\"); } 结果：1234567891011121314151617181920212223242526开始第1趟排序[3, 9, -1, 8, 2][3, -1, 9, 8, 2][3, -1, 8, 9, 2][3, -1, 8, 2, 9]第1趟排序结果：[3, -1, 8, 2, 9]------------------开始第2趟排序[-1, 3, 8, 2, 9][-1, 3, 8, 2, 9][-1, 3, 2, 8, 9]第2趟排序结果：[-1, 3, 2, 8, 9]------------------开始第3趟排序[-1, 3, 2, 8, 9][-1, 2, 3, 8, 9]第3趟排序结果：[-1, 2, 3, 8, 9]------------------开始第4趟排序[-1, 2, 3, 8, 9]第4趟排序结果：[-1, 2, 3, 8, 9]------------------ 总结：1.共进行数组大小-1次循环2.每次排序的次数逐渐减少 优化：若一趟排序中没有一次交换，则停止循环增加标志变量flag=false，发生交换时，置flag为true，一次循环后判断flag，若为true，则重置flag为false继续循环，否则break； 1234567891011121314151617181920212223242526272829int[] array = {3, 9, -1, 8, 2}; boolean flag=false; int temp=0; for (int i=0; i&lt; array.length-1;i++){ System.out.println(\"开始第\"+(i+1)+\"趟排序\"); for (int j=0;j&lt;array.length-1-i;j++){ if (array[j]&gt;array[j+1]){ temp=array[j]; array[j]=array[j+1]; array[j+1]=temp; flag=true; } System.out.println(Arrays.toString(array)); } System.out.println(\"第\"+(i+1)+\"趟排序结果：\"); System.out.println(Arrays.toString(array)); System.out.println(\"------------------\"); if (!flag){ //未发生一次交换，flag为false break; }else { //发生了交换，flag被置为true flag=false; //重置flag，继续循环 } } 这里因为数据原因仍然执行了4次可以换一组数据:{3,9,-1,8,10}结果： 123456789101112131415161718192021开始第1趟排序[3, 9, -1, 8, 10][3, -1, 9, 8, 10][3, -1, 8, 9, 10][3, -1, 8, 9, 10]第1趟排序结果：[3, -1, 8, 9, 10]------------------开始第2趟排序[-1, 3, 8, 9, 10][-1, 3, 8, 9, 10][-1, 3, 8, 9, 10]第2趟排序结果：[-1, 3, 8, 9, 10]------------------开始第3趟排序[-1, 3, 8, 9, 10][-1, 3, 8, 9, 10]第3趟排序结果：[-1, 3, 8, 9, 10]------------------ 可以看到只执行了三次排序 测试十万条数据执行时间:12345678910111213//创建50000个随机数组 int[] array =new int[100000]; for (int i=0;i&lt;100000;i++){ array[i]=(int)(Math.random()*100000); } long begintime=System.currentTimeMillis(); System.out.println(\"开始时间\"+begintime); bubbleSort(array); long endtime=System.currentTimeMillis(); System.out.println(\"结束时间\"+endtime); System.out.println(\"用时：\"+(endtime-begintime)+\"ms\"); 结果： 123开始时间1572061280770结束时间1572061302883用时：22113ms 当然每次执行时间不一样，但当数据大的时候总体效率还是很低的","link":"/posts/20200107-bubbleSort.html"},{"title":"基数排序-------------java实现","text":"一、基本思想1.基数排序(Radix Sort)属于分配式排序（distribution sort），又称”桶子法”(Bucket Sort或Bin Sort)，它是通过键值的各个位的值，将要排序的元素分配至某些“桶”中，达到排序的作用。2.基数排序属于稳定的排序，基数排序法的是效率高的稳定性排序法 3.基数排序(Radix Sort)是桶排序的扩展4.将所有待比较数值统一为同样的数位长度，数位较短的数前面补零。然后，从最低位开始，依次进行一次排序。这样从最低位排序一直到最高位排序完成以后, 数列就变成一个有序序列。 平均时间复杂度： O(n+k) 最优情况： O(n+k) 最坏情况： O(n²) 空间复杂度: O(n+k) 稳定性： 稳定 二、举例说明现有一组数据：{43,3,535,738,14,21,0} 第一轮排序： 第1轮排序后：0,21,43,4,14,535,738 第二轮排序：第二轮排序结果：0,4，14,21,535,738,43 第三轮排序：第三轮排序结果：0,4，14,21,43,535,738 三、代码实现1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768package com.wml.sort;import java.util.Arrays;/** * @author MaoLin Wang * @date 2019/10/3012:53 */public class RadixSort { public static void main(String[] args) { int[] arr={53,3,542,748,14,21,0}; radixSort(arr); } public static void radixSort(int[] arr){ //求最大数的位数 int max = arr[0]; for (int i = 1;i &lt; arr.length; i++){ if (arr[i] &gt;max){ max = arr[i]; } } //得到最大数的位数 int maxLength = (max+\"\").length(); //为防止数据溢出，应将列数设为数组长度 int [][] bucket=new int[10][arr.length]; //记录每个桶中实际存放了多少数据 int[] bucketElementCounts=new int[10]; /** * n代表位数，初始化为1，代表个位 */ for (int i=0 ,n = 1;i&lt; maxLength;i++,n *=10){ for (int j=0;j&lt;arr.length;j++){ //取出个位的值 int value= arr[j] /n %10; //放入个位值为value的桶的第bucketElementCounts[value]个位置，刚开始bucketElementCounts[value]为0，每放入一个数据就+1 bucket[value][bucketElementCounts[value]]=arr[j]; bucketElementCounts[value]++; } int index = 0;//原始数组下边，初始为0 // System.out.println(Arrays.toString(bucketElementCounts)); //遍历每个桶，将桶中数据放回原来数组 for (int k=0;k&lt;bucketElementCounts.length;k++){ //第k个桶 不等于0，即该桶有数据 if (bucketElementCounts[k] !=0){ //遍历该桶数据，放入原数组 for (int m=0;m&lt;bucketElementCounts[k];m++){ //取出元素放到arr arr[index++] = bucket[k][m]; } } //第i+1轮处理后，需要将每个bucketElementCounts[k] = 0 bucketElementCounts[k]=0; } System.out.println(\"第\"+(i+1)+\"轮结果\"+ Arrays.toString(arr)); } }} 结果：第1轮结果[0, 21, 542, 53, 3, 14, 748]第2轮结果[0, 3, 14, 21, 542, 748, 53]第3轮结果[0, 3, 14, 21, 53, 542, 748] 测试80w条数据耗时12345678910111213int[] arr =new int[800000]; for (int i=0;i&lt;800000;i++){ arr[i]=(int)(Math.random()*800000); } long begintime=System.currentTimeMillis(); System.out.println(\"开始时间\"+begintime); radixSort(arr); long endtime=System.currentTimeMillis(); System.out.println(\"结束时间\"+endtime); System.out.println(\"用时：\"+(endtime-begintime)+\"ms\"); 结果：开始时间1572416316975结束时间1572416317084用时：109ms 很明显比之前的归并、快速排序都快的多，但是其缺点也是很明显的，对于任何位数上的基数进行“装桶”操作时，都需要n+k个临时空间(k为桶数)，非常耗费空间","link":"/posts/20200107-jishuSort.html"},{"title":"希尔排序-----------java实现","text":"首先看一下之前使用简单插入排序存在的问题： 当存在一个数组，其最后一个数据为最小值，如：arr={5,6,16,34,33,2} 这样的话需要循环到最后一次，也就是第6次的时候，才可以将2排到前边，效率非常低 但是希尔排序可以很好的解决这个问题，其是简单插入排序改进后的一个效率较高的排序方式，也叫缩小增量排序 复杂度： 平均时间： O（nlogn） 最差: O(n²) 最优: O(n^1/3) 空间复杂度：O(1) 稳定性： 不稳定 一、基本思想希尔排序按某个增量分组，对每个分组使用直接插入排序实现，随着增量逐渐减小，每组数据逐渐增加，当增量减少至1时，仅剩下完整的一组，排序结束。 二、排序分析) 图片引用自https://blog.csdn.net/qq_28081081/article/details/80598960 三、代码实现1234567891011121314151617181920212223242526272829303132/** * 希尔排序 * @author MaoLin Wang * @date 2019/10/2817:43 */public class ShellSort { public static void main(String[] args) { int[] arr={214,32,11,2,3,2,66,33,54,12}; shellSort(arr); } public static void shellSort(int[]arr){ int temp=0; int count=0; for (int group =arr.length/2;group&gt;0;group/=2){ for (int i=group;i&lt;arr.length;i++){ for (int j=i-group;j&gt;=0;j-=group){ if (arr[j]&gt;arr[j+group]){ temp=arr[j]; arr[j]=arr[j+group]; arr[j+group]=temp; } } } System.out.println(\"第\"+(++count)+\"次排序结果：\"); System.out.println(Arrays.toString(arr)); } }} 结果： 123456第1次排序结果：[2, 32, 11, 2, 3, 214, 66, 33, 54, 12]第2次排序结果：[2, 2, 3, 12, 11, 32, 54, 33, 66, 214]第3次排序结果：[2, 2, 3, 11, 12, 32, 33, 54, 66, 214] 测试100000条数据耗时： 123456789101112int[] arr =new int[100000];for (int i=0;i&lt;100000;i++){ arr[i]=(int)(Math.random()*100000);}long begintime=System.currentTimeMillis();System.out.println(\"开始时间\"+begintime);shellSort(arr);long endtime=System.currentTimeMillis();System.out.println(\"结束时间\"+endtime);System.out.println(\"用时：\"+(endtime-begintime)+\"ms\"); 结果： 123开始时间1572260920132结束时间1572260930389用时：10257ms 发现用了10000多ms，不但没有提高效率，反而低了非常多，这是为什么呢？ 仔细看我们的代码进行交换的条件，发现只要满足arr[j]&gt;arr[j+group]就要进行交换，无疑增加了系统开销 接下来对代码进行优化： 123456789101112131415161718192021222324252627282930313233public static void shellSort2(int arr[]) { for (int group = arr.length / 2; group &gt; 0; group /= 2) { for (int i = group; i &lt; arr.length; i++) { int j = i; int temp = arr[j]; if (arr[j] &lt; arr[j - group]) { while ((j - group) &gt;= 0 &amp;&amp; temp &lt; arr[j - group]) { /** * 开始移动，将比arr[j]大的arr[j-group]、arr[j-group-group]......按顺序移动到后一个增量的位置 * 如 3, 2, 11, 21, 66, 32, 214, 4 * 在group减少到2，比较32和4的时候 * 1. 4&lt;32 且满足while条件， 所以将32移动到4,temp=4，j=5，指向32的位置 * 此时的数据为:3, 2, 11, 21, 66, 32, 214, 32 * 2.继续while循环 * j-group=3&gt;0 temp=4&lt;arr[3]=21，满足while条件 * 执行arr[j]=arr[j-group] -&gt; 将21的位置移动到32,temp仍然为一开始的4,j=3，指向21的位置 * 此时数据为：3, 2, 11, 21, 66, 21, 214, 32 * 3.继续循环while * j-group=1&gt;0 temp=4&gt;arr[1]=2 不满足while条件，退出循环 * 4.此时j=3，将temp=4赋值给arr[j] * 此时数据为：3, 2, 11, 4, 66, 21, 214, 32 */ arr[j] = arr[j - group]; j -= group; } //结束while循环后，将temp插入到arr[j] arr[j] = temp; } } } } 同样测试10000条数据排序的耗时： 123开始时间1572264172662结束时间1572264172692用时：30ms 耗时从1w多ms减小到30ms，多次测试上下波动也不会超过20ms","link":"/posts/20200107-shellSort.html"},{"title":"归并排序-------------java实现","text":"归并排序采用分治策略实现 平均时间复杂度 : O（nlogn） 最差时间复杂度: O(nlogn) 稳定性： 稳定 空间复杂度：O(n) 归并排序时以空间换时间的排序方法，空间消耗很大，一般内部排序使用快速排序较多 假设有这样一组数据：[10,4,8,7,1,3,2,9] 一、分) 如上将8个数组分成8个单独的数据 二、合1.将 10和 4合并 ) 2.将8和7合并 ) 3. 将4,10和7,8合并 )、 4.同样将右半部分也按此合并得到如下两组数据 ) 5.最后将两组数据合并在一起 ) 三、代码实现12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879package com.wml.sort;import java.util.Arrays;/** * @author * @date 2019/10/2919:17 */public class MergeSort { public static void main(String[] args) { int arr[] = {10,4,8,7,1,3,2}; int[] temp=new int[arr.length]; mergeSort(arr,0,arr.length-1,temp); System.out.println(Arrays.toString(arr)); } public static void mergeSort(int[] arr,int left,int right,int[] temp){ if (left &lt; right){ int mid= (left + right ) / 2; //向左递归分解 mergeSort(arr,left,mid,temp); //向右递归分解 mergeSort(arr,mid+1,right,temp); //合并 merge(arr,left,right,mid,temp); } } /** * * @param arr 待排序数组 * @param left 左边有序序列的初始索引 * @param right 右边索引 * @param mid * @param temp 临时数组 */ public static void merge(int[] arr,int left, int right,int mid,int[] temp){ int l = left; //初始化i，左边有序序列的初始索引 int r = mid+1; //右边有序序列的初始索引 int current = 0; // 指向临时数组的当前索引 //1.先把左边两边的有序数据按规则填充到临时数组，直到任意一方处理完毕 while ( l&lt;= mid &amp;&amp; r &lt;= right){ if (arr[l] &lt;= arr[r]){ //当前左边的元素小于等于右边的，将左边的数据拷贝到临时数组 temp[current] = arr[l]; current +=1; //current后移 l +=1; //左边指针右移 }else { //右边的元素移到临时数组 temp[current] = arr[r]; current += 1; r +=1; } } //2.将有剩余的一边全部移动到临时数组 while ( l &lt;= mid){//左边有剩余 temp[current] = arr[l]; current+=1; l+=1; } while ( r &lt;= right){//右边有剩余 temp[current] = arr[r]; current+=1; r+=1; } //3.将临时数组拷贝到原始数组 current = 0; int tempLeft=left; while (tempLeft &lt;= right){ arr[tempLeft] = temp[current]; current+=1; tempLeft +=1; } }} 结果： [1, 2, 3, 4, 7, 8, 10]","link":"/posts/20200107-guibingSort.html"},{"title":"快速排序-------------java实现","text":"一、基本思想选择一个基准数，通过一趟排序将待排序数据分成两个独立的部分，其中一部分的所有数都比基准数小，另一部分都比基准数大，然后再使用此方法递归对两部分数据进行快排，最终实现整个数据的有序。 二、详解排序过程现有待排序数据： 1{-21, 312, 44, 11, -23, 2, 10}; 蓝色为左哨兵，记为left，黄色为右哨兵记为right，红色为基数 基数=(左哨兵坐标+右坐标)/2 第一轮排序： ​ ↓ ↓ ​ -21， 312， 44， 11， -23， 2， 10 ​ 左哨兵找到第一个比基数11大的数停止，即在312停止，此时left=1 ​ 右哨兵找到第一个比基数小的数停止，即在10停止，此时right=6 ​ 此时两个哨兵尚未相遇，交换 312 和 10 交换后： ​ ↓ ↓ ​ -21， 10， 44， 11， -23， 2， 312 左哨兵继续移动，到比11大的44时停止，此时left=2 右哨兵继续移动，到比11小的2处停止，此时right=5 两个哨兵仍然未相遇 ，不需要break；交换 44 和 2 交换后： ​ ↓ ↓ ​ -21， 10， 2， 11， -23， 44， 312 左哨兵继续移动，到基数11停止，因为左边已经没有比11小的数了，此时left=3 右哨兵继续移动，到比 11小的 -23处停止，此时right = 4 交换11 和-23 交换后： ​ ↓ ↓ ​ -21， 10， 2， -23， 11， 44， 312 此时再继续移动，两个哨兵相遇，一轮结束 当哨兵相遇时，让right–，left++，分别指向-23 和44 此时左半部分为：-21, 10, 2, -23 left为-21，right为-23 右半部分为： 44， 312 left为44，right为312 两边继续按上述步骤递归排序 三、代码实现：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667/** * 快速排序 * @author * @date 2019/10/2917:06 */public class QuickSort { public static void main(String[] args) { int[] arr={-21,312,44,11,-23,2,10}; quickSort(arr,0,arr.length-1); System.out.println(Arrays.toString(arr)); } public static void quickSort(int[] arr, int left, int right) { int l = left; int r = right; //基准数 int pivot = arr[(left + right) / 2]; int temp=0;//临时变量 //让比基数小的放在左边，比基数大的放在右边 while (l &lt; r){ //在基数左边找到大于等于基数的值才退出 while (arr[l] &lt; pivot){ l += 1; } //在基数右边找到小于等于基数的值才退出 while (arr[r] &gt; pivot){ r -=1; } //左右两个哨兵相遇，即说明基数左边的数已经全部小于基数，右边的数已经全部大于基数 if( l &gt;= r){ break; } //否则进行交换 temp = arr[l]; arr[l] = arr[r]; arr[r] = temp; //如果交换完后，发现arr[l] == 基数，r向左移 if (arr[l] == pivot){ r -= 1; } //如果交换完后，发现arr[r] == 基数，l向右移 if (arr[r] == pivot){ l += 1; } } if (l == r){ l +=1; r -=1; } //向左递归 if (left&lt;r){ quickSort(arr,left,r); } //向右递归 if (right &gt; l){ quickSort(arr,l,right); } }} 结果： [-23, -21, 2, 10, 11, 44, 312] 四、测试10W条数据耗时123456789101112int[] arr =new int[100000];for (int i=0;i&lt;100000;i++){ arr[i]=(int)(Math.random()*100000);}long begintime=System.currentTimeMillis();System.out.println(\"开始时间\"+begintime);quickSort(arr,0,arr.length-1);long endtime=System.currentTimeMillis();System.out.println(\"结束时间\"+endtime);System.out.println(\"用时：\"+(endtime-begintime)+\"ms\"); 结果： 123开始时间1572344644967结束时间1572344645031用时：64ms 此时与希尔排序看不出很大的差距，将数据增加到80W条测试结果： 希尔： 开始时间1572344777821结束时间1572344778134用时：313ms 快速： 开始时间1572344758536结束时间1572344758711用时：175ms 经过多次测试，偶尔会有希尔排序比快速快的情况，但是多数情况下还是快速比希尔快","link":"/posts/20200107-quickSort.html"},{"title":"插入排序-----------java实现","text":"一、复杂度12345平均时间复杂度： O(n²)最差时： O(n²)是否稳定： 稳定空间开销： O(1)在大部分数据已经排好序时性能较好 二、基本思想将n个待排序元素看成一个有序表和一个无序表，开始有序表只有一个元素，每次排序从无需表中取第一个元素，将它的值依此和有序表元素的数据比较，插入到有序表的适当位置，形成新的有序表 详解： 初始数据：18, 5, 54, 2, 33, 12 第一次排序：5， 18， 54， 2， 33，12 第二次排序：2，5， 18， 54， 33，12 第三次排序：2，5，12 18， 54， 33 第四次排序：2，5，12 18，33， 54 第五次排序：2，5，12 18，33，54 三、代码实现12345678910111213141516171819202122232425262728293031323334353637/** * 插入排序 * @author ** * @date 2019/10/2816:55 */public class InsertSort { public static void main(String[] args) { int[] arr= {213,43,22,11,324,11,4}; insertSort(arr); } public static void insertSort(int[] arr){ for (int i=1;i&lt;arr.length;i++){ //待插入数据 int insertVal=arr[i]; //待插入位置下标 int insertIndex=i-1; /** * 如果待插入下标小于零，说明待插入数据最小，应放在第一个位置 * 如果待插入值大于arr[inserIndex]，则停止循环，说明待插入值在有序表中是最大的，应插入到当前insertIndex后一个位置 */ while (insertIndex&gt;=0 &amp;&amp; insertVal&lt;arr[insertIndex]){ arr[insertIndex+1]=arr[insertIndex]; insertIndex--; } arr[insertIndex+1]=insertVal; System.out.println(\"第\"+i+\"次排序结果：\"); System.out.println(Arrays.toString(arr)); } }} 结果： 123456789101112第1次排序结果：[43, 213, 22, 11, 324, 11, 4]第2次排序结果：[22, 43, 213, 11, 324, 11, 4]第3次排序结果：[11, 22, 43, 213, 324, 11, 4]第4次排序结果：[11, 22, 43, 213, 324, 11, 4]第5次排序结果：[11, 11, 22, 43, 213, 324, 4]第6次排序结果：[4, 11, 11, 22, 43, 213, 324] 四、测试100000条数据耗时123456789101112131415161718192021222324252627282930313233343536373839404142434445464748package com.wml.sort;import java.util.Arrays;/** * @author *** * @date 2019/10/2816:55 */public class InsertSort { public static void main(String[] args) { int[] array =new int[100000]; for (int i=0;i&lt;100000;i++){ array[i]=(int)(Math.random()*100000); } long begintime=System.currentTimeMillis(); System.out.println(\"开始时间\"+begintime); insertSort(array); long endtime=System.currentTimeMillis(); System.out.println(\"结束时间\"+endtime); System.out.println(\"用时：\"+(endtime-begintime)+\"ms\"); } public static void insertSort(int[] arr){ for (int i=1;i&lt;arr.length;i++){ //待插入数据 int insertVal=arr[i]; //待插入位置下标 int insertIndex=i-1; /** * 如果待插入下标小于零，说明待插入数据最小，应放在第一个位置 * 如果待插入值大于arr[inserIndex]，则停止循环，说明待插入值在有序表中是最大的，应插入到当前insertIndex后一个位置 */ while (insertIndex&gt;=0 &amp;&amp; insertVal&lt;arr[insertIndex]){ arr[insertIndex+1]=arr[insertIndex]; insertIndex--; } arr[insertIndex+1]=insertVal; } }} 结果： 123开始时间1572254640158结束时间1572254641586用时：1428ms 相比上一篇的选择排序的5811ms总体又快了许多","link":"/posts/20200107-insertSort.html"},{"title":"选择排序  ------java实现","text":"一、选择排序的思想第一次从arr[0]~arr[n-1]中选取最小值与arr[0]交换，第二次从arr[1]到arr[n-1]中选取最小值与arr[1]交换，第三次从arr[2]到arr[n-1]中选取最小值与arr[2]交换，以此类推，总共循环n-1次，得到一个从小到大的有序序列。 二、思路详解待排序元素： [34] 54 123 55 11 22 第一次排序： [11,34] 54 123 55 22第二次排序 : [11,22,34] 54 123 55第三次排序： [11,22,34,54] 123 55第四次排序： [11,22,34,54,55] 123 说明(这里按从小到大)： 1.选择排序共进行数组大小-1次排序2.每次排序中，先设当前的数是最小值，然后依次和后面的数进行比较，如果发现有比这个数小的，就让最小的数为这个数，得到最小值下标，遍历一个循环后，得到最小值和下标3.如果该小标与一开始的不一样，说明存在比开始设定的最小的数还小的数，将二者交换，进行下一次循环 三、代码实现12345678910111213141516171819202122232425public static void selectSort(int[] arr){ for (int i=0;i&lt;arr.length-1;i++){ int minIndex=i; int min=arr[i]; for (int j=i+1;j&lt;arr.length;j++){ if (min&gt;arr[j]){ min=arr[j]; minIndex=j; } } //将最小值放在arr[0]。即交换 if (minIndex!=i){ arr[minIndex]=arr[i]; arr[i]=min; } System.out.println(\"第\"+(i+1)+\"轮后结果\"); System.out.println(Arrays.toString(arr)); } } public static void main(String[] args) { int[] array={101,222,119,1}; SelectSort.selectSort(array); } 结果： 123456第1轮后结果[1, 222, 119, 101]第2轮后结果[1, 101, 119, 222]第3轮后结果[1, 101, 119, 222] 测试100000条数据执行时间： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748package com.wml.sort;import java.util.Arrays;/** * 选择排序 * @author MaoLin Wang * @date 2019/10/2811:24 */public class SelectSort { public static void main(String[] args) { //int[] array={101,222,119,1}; int[] array =new int[100000]; for (int i=0;i&lt;100000;i++){ array[i]=(int)(Math.random()*100000); } long begintime=System.currentTimeMillis(); System.out.println(\"开始时间\"+begintime); SelectSort.selectSort(array); long endtime=System.currentTimeMillis(); System.out.println(\"结束时间\"+endtime); System.out.println(\"用时：\"+(endtime-begintime)+\"ms\"); } public static void selectSort(int[] arr){ for (int i=0;i&lt;arr.length-1;i++){ int minIndex=i; int min=arr[i]; for (int j=i+1;j&lt;arr.length;j++){ if (min&gt;arr[j]){ min=arr[j]; minIndex=j; } } //将最小值放在arr[0]。即交换 if (minIndex!=i){ arr[minIndex]=arr[i]; arr[i]=min; } //System.out.println(\"第\"+(i+1)+\"轮后结果\"); //System.out.println(Arrays.toString(arr)); } }} 结果：用时： 123开始时间1572251978745结束时间1572251984556用时：5811ms 相比上一篇冒泡排序的22113ms快了许多 平均时间： O(n²)最差： O（n²）是否稳定： 不稳定空间复杂度： O（1）备注： n小时较好","link":"/posts/20200107-selectSort.html"},{"title":"Linux命令整理-------------文件管理相关(一)","text":"cat说明：用来显示文本内容(小文件)，对于大文件推荐使用more命令 格式： cat +选项+指定文件 ​ 选项： 123&gt; -n 或 --number：显示行号；&gt; -b 或 --number-nonblank：编号时忽略空白行&gt; -A：显示不可打印字符，行尾显示“$”； 如： 1234567echo xxx&gt;test 若test不存在，则自动创建test并写入xxx，否则直接写入cat 123.txt 屏幕显示123.txt内容cat 文本1 文本2 ... 显示多个文本内容cat 文本1 文本2 &gt; 文本3 将文本1和2的内容合并到文本3中cat 文本1 &gt; 文本2 将文本1内容拷贝到文本2cat /dev/null &gt; 文本1 清空文本1的内容cat &gt;test1.txt &lt;&lt;stop 向test1.txt写入内容，输入stop结束 注意：每次合并时，文本3的内容会被重新覆盖 more全屏幕显示文本文件内容 选项：12345-数字：每屏显示指定行-c：不进行滚屏操作。每次刷新这个屏幕；-s：将多个空行压缩成一行显示；-u：禁止下划线；+数字：从指定数字的行开始显示。 查看时可用命令： Space键：显示文本的下一屏内容。 Enter键：每次刷新一行 H键：显示相关的帮助信息 B键：查看上一屏 q键：退出 ​​ cd1.cd : 进入目录 2.cd ~: 进入用户目录 3.cd - : 进入历史上一级目录，即进此目录之前的那个目录 4.cd .. ：返回上级目录 cd ../../ 有几个.../就返回上几级目录 ls 显示目标列表 选项 -a 显示所有文件（在linux中以.开头的文件为隐藏文件） -l 显示文本的详情包括(权限、拥有者、文件大小、最后修改时间等) -r 将文件反序显示(默认按照英文字母顺序) -t 按照创建时间列出 -A 同 -a ，但不列出 &quot;.&quot; (目前目录) 及 &quot;..&quot; (父目录) -F 在文件名称后加一个符号： *：代表可执行档 /： 代表目录 -R 有文件的目录，也会将其子文件列出 ​ -R举例： -F举例：test2是一个目录。所以在后边显示了一个/ pwd 显示当前工作目录（绝对路径） head 显示指定文件前N行 选项： -n：指定显示前n行 -v：显示文件名的头信息； -q：不显示文件名的头信息。 tail 显示指定文件的末尾N行，默认10行 选项： -c,–bytes=：显示文件尾部的N（N为整数）个字节内 -f&lt;name/descriptor&gt;：动态显示文件尾部内容，如某个动态更新的日志，可以使用-f查看最新的内容 -n：输出文件的尾部N（N位数字）行内容。 –pid=&lt;进程号&gt;：与“-f”选项连用，当指定的进程号的进程终止时退出该命令-q,–quiet,–silent：当有多个文件参数时，不输出各个文件名； -s&lt;秒数&gt;,–sleep-interal=&lt;秒数&gt;：与“-f”连用，指定文件变化时间隔(s) -v,–verbose：当有多个文件参数时，总是输出各个文件名； –help：帮助信息 –version：指令版本 举例： 12345tail test 不指定行数默认显示文件test的最后10行tail -n +10 test 从第10行到最后tail -c 10 test 显示该文件的最后10个字符tail -25 nginx.log 显示最后的 25 行tail -f nginx.log 动态刷新该文件最后的内容 chmod修改文件或目录的权限 权限范围：u: –&gt; User ，当前文件/目录的拥有者g: –&gt; Group ， 所属组o: –&gt; Other ， 除User和所属群组之外的所有用户a: –&gt; All ， 所有用户r: –&gt; 读权限，数字 4w:–&gt; 写权限，数字 2x: 执行/切换权限，数字 1- 无权限，数字 0 语法： chmod [options][参数] 选项： 1234567891011121314151617+ 添加某些权限- 取消某些权限= 指定文件权限r 读权限w 写权限x 可执行权限- 无权限X 给可执行文件设置可执行权限t 只有目录或文件的所有者才可以删除目录下的文件-c ,--changes 效果类似“-v”参数，但仅回报更改的部分，如果文件权限已经改变，显示其操作信息；-f , --quiet, --silent 操作过程中不显示任何错误信息；-R, --recursive 以递归更改其本身及子目录-v, --verbose 显示详情信息--reference=&lt;参考文件或目录&gt; 指定参考文件，非自定义权限--help 显示帮助信息--version 显示版本信息 权限结构： 1-rwxr--r-- 1 user staff 651 Nov 11 11:02 .ignore 第一个 -: 代表是普通文件，若是 d，则代表目录 第一组rwx：即上边的rw-,表示u属组 第二组rwx: 即上边中间的r–，表示g属组 第三组rwx: 即上边最后的r–， 表示其他人的权限 r:读 4 w：写 2 x：执行 1 举例: 1234567chmod u+w,g+r test1 为test1设置当前用户可写，组可读的权限chmod u=rwx,g=rw,o=r test1 当前用户可读写执行，组可读写，其他用户只能读chmod 764 test1 当前用户读写执行，组读写，其他只可读chmod a+r test1 所有用户都只可读test1chmod ugo-r test1 所有用户减掉可读权限 chmod -R 755 /usr/local/test/ 递归修改test目录下的子文件的权限为 755,7即4+2+1，5即4+1chown john:student test1 把test1给John，添加到student组 chown 改变文件或目录的拥有者或所属群组 可以给某个用户授权，使该用户变成指定文件的所有者或者改变文件所属的组。 语法： chown [options][参数] 选项： 12345-c，--changes：显示修改的部分；-f ：不显示错误信息；-h：只对符号连接的文件作修改，而不更改其他任何相关文件；-R：递归处理指定目录下的所有文件及子目录-v：显示指令执行过程信息 123chown -R wml:mygroup /usr/local/test1 将/usr/local/test下面的所有文件以及子目录的文件拥有者改为wml,群组为mygroup - ## cmp 比较两个二进制文件是否有差异，若无差异则不显示任何信息，若有差异则显示第一个不同的地方的字符和列数 **语法：** cmp [options][参数] **选项：** 12-l：对于每处不同，显示十进制的字节数和八进制的不同字节。；-s，--quit，--silent：不显示错误信息； **举例:** 123.txt ： 我是123 222 222.txt: 我是222 222 1cmp 123.txt 222.txt --结果--&gt;123.txt 222.txt differ: byte 1, line 1 - ## diff 比较两个文件的不同，该命令是采取逐行比较的方式， **选项：** 12345678910111213-&lt;行数&gt;：指定显示多少行的文本-a，--text：将文件当做文本文件处理-b：忽略空格字符造成的不同；-B，--ignore-blank-lines：忽略空白行；-c：显示两个文件的全部内容，并标出不同之处-H，--speed-large-files：加速大文件检索-i，--ignore-case：忽略大小写不同-l或——paginate：分页-q或--brief：仅显示有无差异，不显示详细的信息 有不同的结果:Files 123.txt and 222.txt differ-r，--recursive：比较子目录中的文件-T：每行对齐输出-y：并列打印 举例： ![在这里插入图片描述](https://img-blog.csdnimg.cn/20191028231857879.png) - ## file 检测目标文件类型 **选项：** 1234-b：不显示文件名称L-L：直接显示符号连接所指向的文件类别；-v：显示版本信息；-z：尝试去解读压缩文件的内容。 **举例：** 123[admin@ test]$ file 123.txt 222.txt123.txt: UTF-8 Unicode text222.txt: UTF-8 Unicode text find查询指定目录下的文件选项： 123456789101112131415161718192021-depth：从指定目录的最深层的子目录开始查找-maxdepth&lt;目录深度&gt;：最大目录深度-mindepth&lt;目录深度&gt;：最小目录层级；-empty：查找大小为0 的文件或空目录-exec&lt;要执行的指令&gt;：若find指令返回True，就执行目标指令(如找到空的就执行rm删除目标文件)-fstype&lt;文件系统类型&gt;：只寻找该文件系统类型下的文件或目录；-ls：将文件或目录名称列出到标准输出(权限信息，所属用户、组，时间信息等)-name&lt;inputname&gt;，-iname：查询名称符合inputname的文件，-iname忽略大小写-anewer test : 比文件 file 更晚被读取过的文件-path&lt;testPath&gt;，-ipath&lt;testPath&gt;：路径符合testPath的文件,-ipath 忽略大小写-perm&lt;权限值&gt;：查找符合指定的权限数值的文件-print：将文件或目录名称列出到标准输出。格式为每列一个名称，每个名称前皆有“./”字符串；-printf&lt;输出格式&gt;：自定义格式输出-size&lt;文件大小&gt;：查找符合指定大小的文件-type&lt;文件类型&gt;：指定的文件类型的文件-user&lt;拥有者名称&gt;：指定用户拥有的文件 举例： 1.find. 列出当前目录的所有文件及其子文件 123456789 find . 结果：../333.txt./222.txt./test2./test2/123.txt./123.txt./empty.txt 2.find /usr/test -name “*.txt”：查找test目录下后缀名为txt的文件 1234567find /usr/test -name \"*.txt\"结果：/usr/test/333.txt/usr/test/222.txt/usr/test/test2/123.txt/usr/test/123.txt/usr/test/empty.txt 3.find /usr/test ! -name “*.txt”：查找test目录下后缀名不是txt的文件 4.根据文件类型查找 -type: 1find . -type 参数 类型参数： f ：普通文件 l ：符号连接 d ：目录 c ：字符设备 b ：块设备 s ：套接字 p ：Fifo 5.查找小于3k的文件 1find . -size -3k 结果： ./333.txt ./222.txt ./test2/123.txt ./123.txt ./empty.txt 6.查找大小为0的文件 12[root@ test] find -empty./empty.txt 7.查找指定权限的文件 首先给123.txt赋予77权限： 1chmod 777 123.txt 查看下结果： 12345-rwxrwxrwx 1 777 root 21 Oct 28 23:08 123.txt-rw-r--r-- 1 root root 15 Oct 28 22:57 222.txt-rw-r--r-- 1 root root 23 Oct 27 22:46 333.txt-rw-r--r-- 1 root root 0 Oct 29 15:20 empty.txtdrwxr-xr-x 2 root root 4096 Oct 27 19:52 test2 只有123.txt的权限为777, 执行查找： 1find -perm 777 结果： 1./123.txt ​ 持续更新………","link":"/posts/20200106-linux_file_1.html"},{"title":"（复习）二叉树的三种遍历方式、查找和删除----------Java实现","text":"一、概念：二叉树二叉树的每个节点最多只能由两个子节点 性质： 二叉树的第 i 层最多有 2 ^ (i-1) 个节点 深度为 k （ k≥0 ）的二叉树最少有 k 个节点(一层一个)，最多有 （2^k ）-1 个节点 （空树k=0，只有一个根节点k=1） 对于任意一个非空二叉树，若其 叶子节点数为 n，度为2的非叶子节点数为 m，则 ==n=m+1==，（度 即节点所拥有的子树的个数） 如果节点总数为 2^n-1 且所有叶子节点都在最后一层，则该树为==满二叉树== 如果该二叉树的所有叶子节点都在最后一层或者倒数第二层，而且最后一层的叶子节点在左边连续，倒数第二层的叶子节点在右边连续，则称为==完全二叉树==。如下： 二、三种遍历方式2.1前序遍历根节点 —&gt; 左孩子 —&gt; 右孩子以上图为例，前序遍历结果为：11，21,14,81,91,15,31，61,71 2.2 中序遍历左孩子 –&gt; 根节点 —&gt; 右孩子 上图为例，结果为：81,14,91,21,15,11,61,31,71 2.3 后序遍历左孩子 –&gt; 右孩子 —&gt; 根节点 上图为例，结果为：81,91,14,15,21,61,71,31,11 三、代码实现遍历3.1首先创建TreeNode类作为数节点这里方便使用直接都设为了public 12345678910111213141516171819class TreeNode { public int no;//节点编号 public TreeNode lchild;//左孩子 public TreeNode rchild;//右孩子 public TreeNode() { } public TreeNode(int no) { this.no = no; } @Override public String toString() { return \"TreeNode{\" + \"no=\" + no + '}'; }} 3.2 创建二叉树类12345678//定义二叉树class BinaryTree { private TreeNode root; public void setRoot(TreeNode root) { this.root = root; }} 3.3 前序遍历方法： 1.首先输出根节点 2.左孩子非空时，递归遍历左孩子 3.右孩子非空时，递归遍历右孩子 1234567891011121314/** * 前序遍历： 根节点-&gt;左节点-&gt;右节点 */ public void preOrder() { System.out.println(this);//先输出父节点 //向左递归 if (this.lchild != null) { this.lchild.preOrder(); } //向右递归 if (this.rchild != null) { this.rchild.preOrder(); } } 3.4 中序遍历方法： 1.左孩子非空时，递归遍历左孩子 2.首先输出根节点 3.右孩子非空时，递归遍历右孩子 123456789101112131415/** * 中序遍历： 左节点-&gt;根节点-&gt;右节点 */ public void midOrder() { //向左递归 if (this.lchild != null) { this.lchild.midOrder(); } System.out.println(this);//输出根节点 //向右递归 if (this.rchild != null) { this.rchild.midOrder(); } } 3.5 后序遍历方法： 1.左孩子非空时，递归遍历左孩子 2.右孩子非空时，递归遍历右孩子 3.首先输出根节点 12345678910111213141516/** * 后序遍历： 左节点-&gt;右节点-&gt;根节点 */ public void postOrder() { //向左递归 if (this.lchild != null) { this.lchild.postOrder(); } //向右递归 if (this.rchild != null) { this.rchild.postOrder(); } System.out.println(this);//输出根节点 } 其实就是把输出根节点的位置按先中后的顺序换来换去 3.6 在二叉树中调用一下方法应先判断根节点是否为空，不为空时才遍历 123456789101112131415161718192021222324//前序遍历 public void preOrder(){ if (this.root!=null){ this.root.preOrder(); }else { System.out.println(\"二叉树为空\"); } } //中序遍历 public void midOrder(){ if (this.root!=null){ this.root.midOrder(); }else { System.out.println(\"二叉树为空\"); } } //后续遍历 public void postOrder(){ if (this.root!=null){ this.root.postOrder(); }else { System.out.println(\"二叉树为空\"); } } 测试按照一开始的那个图创建二叉树： 12345678910111213141516171819202122232425262728293031BinaryTree binaryTree=new BinaryTree(); //创建根节点 TreeNode root = new TreeNode(11); TreeNode treeNode2 = new TreeNode(21); TreeNode treeNode3 = new TreeNode(31); TreeNode treeNode4 = new TreeNode(14); TreeNode treeNode5 = new TreeNode(15); TreeNode treeNode6 = new TreeNode(61); TreeNode treeNode7 = new TreeNode(71); TreeNode treeNode8 = new TreeNode(81); TreeNode treeNode9 = new TreeNode(91); root.lchild =treeNode2; root.rchild =treeNode3; treeNode3.rchild =treeNode7; treeNode3.lchild =treeNode6; treeNode2.lchild =treeNode4; treeNode2.rchild =treeNode5; treeNode4.lchild =treeNode8; treeNode4.rchild =treeNode9; binaryTree.setRoot(root); System.out.println(\"中序-------\"); binaryTree.midOrder(); System.out.println(\"前序--------\"); binaryTree.preOrder(); System.out.println(\"后续--------\"); binaryTree.postOrder(); 结果： 123456789101112131415161718192021222324252627282930中序-------TreeNode{no=81}TreeNode{no=14}TreeNode{no=91}TreeNode{no=21}TreeNode{no=15}TreeNode{no=11}TreeNode{no=61}TreeNode{no=31}TreeNode{no=71}前序--------TreeNode{no=11}TreeNode{no=21}TreeNode{no=14}TreeNode{no=81}TreeNode{no=91}TreeNode{no=15}TreeNode{no=31}TreeNode{no=61}TreeNode{no=71}后续--------TreeNode{no=81}TreeNode{no=91}TreeNode{no=14}TreeNode{no=15}TreeNode{no=21}TreeNode{no=61}TreeNode{no=71}TreeNode{no=31}TreeNode{no=11} 四、三种遍历查询某个节点返回节点编号4.1 前序遍历方法：1.判断当前节点是否满足，满足的话返回该节点，不满足进行 22.判断当前节点的左孩子是否为空，不为空的话递归前序遍历左孩子3.判断当前节点的右孩子是否为空，不为空的话递归前序遍历右孩子实现： 1234567891011121314151617181920212223242526272829303132/** * 前序遍历查找 * @param no * @return */ public TreeNode preOrderFind(int no){ if (this.no==no){ return this; } TreeNode treeNode=null; /** * 判断当前当前节点的左孩子是否为空，不为空 -&gt; 递归前序遍历查找， * 若找到，就返回 */ if (this.lchild !=null){ treeNode=this.lchild.preOrderFind(no); } if (treeNode!=null){ return treeNode; } /** * 判断右孩子是否为空，不为空-&gt;递归前序遍历，无论找没找到都返回treeNode */ if (this.rchild !=null){ treeNode=this.rchild.preOrderFind(no); } return treeNode; } 4.2 中序遍历方法：将当前节点放在左孩子和右孩子中间就好了，其他同上实现： 1234567891011121314151617181920212223242526272829303132/** * 中序遍历查找 * @param no * @return */ public TreeNode midOrderFind(int no){ TreeNode treeNode=null; /** * 判断当前当前节点的左孩子是否为空，不为空 -&gt; 递归前序遍历查找， * 若找到，就返回 */ if (this.lchild !=null){ treeNode=this.lchild.midOrderFind(no); } if (treeNode!=null){ return treeNode; } if (this.no==no){ return this; } /** * 判断右孩子是否为空，不为空-&gt;递归前序遍历，无论找没找到都返回treeNode */ if (this.rchild !=null){ treeNode=this.rchild.midOrderFind(no); } return treeNode; } 4.3 后序遍历方法：将当前节点的比较放在最后就好了，其他同上实现： 1234567891011121314151617181920212223242526272829303132333435363738/** * 后序遍历查找 * @param no * @return */ public TreeNode postOrderFind(int no){ TreeNode treeNode=null; /** * 判断当前当前节点的左孩子是否为空，不为空 -&gt; 递归前序遍历查找， * 若找到，就返回 */ if (this.lchild !=null){ treeNode=this.lchild.postOrderFind(no); } if (treeNode!=null){ return treeNode; } /** * 判断右孩子是否为空，不为空-&gt;递归前序遍历，无论找没找到都返回treeNode */ if (this.rchild !=null){ treeNode=this.rchild.postOrderFind(no); } if (treeNode!=null){ return treeNode; } //左右孩子都没找到，找根节点 if (this.no==no){ return this; } return treeNode; } 4.4 二叉树调用查找方法12345678910111213141516171819202122232425262728293031323334353637/** * 前序遍历查找 * @param no * @return */ public TreeNode preOrderFind(int no){ if (root!=null){ return root.preOrderFind(no); }else { return null; } } /** * 中序遍历查找 * @param no * @return */ public TreeNode midOrderFind(int no){ if (root!=null){ return root.midOrderFind(no); }else { return null; } } /** * 后序遍历查找 * @param no * @return */ public TreeNode postOrderFind(int no){ if (root!=null){ return root.postOrderFind(no); }else { return null; } } 测试：查找6112345678910111213141516171819202122232425//前序遍历查找 System.out.println(\"前序遍历查找==============\"); TreeNode treeNode = binaryTree.preOrderFind(61); if (treeNode!=null){ System.out.println(\"找到了：编号为\"+treeNode.no); }else { System.out.println(\"没找到\"); } //中序遍历查找 System.out.println(\"中序遍历查找====================\") TreeNode midOrderFind = binaryTree.midOrderFind(61); if (midOrderFind!=null){ System.out.println(\"找到了：编号为：\"+midOrderFind.no); }else { System.out.println(\"没找到\"); } //后序遍历查找 System.out.println(\"后序遍历查找=============\"); TreeNode postOrderFind = binaryTree.postOrderFind(61); if (postOrderFind!=null){ System.out.println(\"找到了：编号为\"+postOrderFind.no); }else { System.out.println(\"没找到\"); } 结果： 123456前序遍历查找==============找到了：编号为61中序遍历查找====================找到了：编号为：61后序遍历查找=============找到了：编号为61 五、删除节点当节点为叶子节点时直接删除当节点为非叶子节点时连同其子树一起删除；(不删除子树的方法后续补充)方法：每次的比较对象为当前节点的左右孩子，当左孩子非空且编号与目标节点相同，让左孩子为null当右孩子非空且编号与目标节点相同，让右孩子为null当左右孩子非空时，递归遍历 12345678910111213141516171819/** * 递归删除 */ public void deleteNode(int no){ if (this.lchild !=null &amp;&amp; this.lchild.no==no){ this.lchild =null; return; } if (this.rchild !=null &amp;&amp;this.rchild.no==no){ this.rchild =null; return; } if (this.lchild !=null){ this.lchild.deleteNode(no); } if (this.rchild !=null){ this.rchild.deleteNode(no); } }","link":"/posts/20200107-binarytree.html"},{"title":"模拟先来先服务、短作业优先、时间片轮转以及最高响应比优先调度算法的JAVA实现","text":"这里记录一下操作系统的实验，几个调度算法的原理很好理解，网上也有很多解释，这里不再解释，直接上代码。 一、JCB类1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950public class JCB { public int id; /** * 剩余服务时间 */ public int leftTime; /** * 要求服务时间 */ public int serviceTime; /** * 到达时间 */ public int arriveTime; /** * 开始时间 */ public int beginTime; /** * 结束时间 */ public int finishTime; /** * 优先权 */ public float priority; public JCB(int id, int serviceTime, int arriveTime,float priority) { this.id = id; this.leftTime = serviceTime; this.serviceTime = serviceTime; this.arriveTime = arriveTime; beginTime =0; this.priority=priority; finishTime=0; } @Override public String toString() { return \"JCB{\" + \"id=\" + id + \", serviceTime=\" + serviceTime + \", arriveTime=\" + arriveTime + \", priority=\" + priority + '}'; }} 二、定义所需数据结构1234567891011121314151617181920212223242526272829303132333435363738394041424344454647/** * 时间片轮转算法 * * @author MaoLin Wang * @date 2019/11/3020:03 */public class SchedulingAlgorithm { /** * 就绪队列 */ LinkedList&lt;JCB&gt; readyQueue = null; /** * 结束调度队列 */ LinkedList&lt;JCB&gt; finishQueue = null; /** * 时间段 */ private int cpuTime; /** * 时间片大小 */ private int timeSize; /** * 作业数 */ private int jobNum; private String dispatchName;//调度算法名 /** * 作业周转时间 */ private int[] turnoverTime; /** * 作业带权周转时间· */ private float[] turnoverTimeWithWeight; /** * 平均带权周转时间 */ private float ave;} 三、初始化这里将最高响应比的初始化拉了出来，因为要设置响应比 12345678910111213141516171819202122232425262728293031323334353637383940414243444546/** * 初始化 */ public void init(int jobNum, int timeSize, String dispatchName) { System.out.println(\"开始\" + dispatchName + \"调度\"); readyQueue = new LinkedList&lt;&gt;(); finishQueue = new LinkedList&lt;&gt;(); this.turnoverTime = new int[jobNum]; this.turnoverTimeWithWeight = new float[jobNum]; this.cpuTime = 0; JCB jcb; for (int i = 1; i &lt;= jobNum; i++) { jcb = new JCB(i, (int) (Math.random() * 10 + 1), i - 1, 0); readyQueue.offer(jcb); } this.timeSize = timeSize; this.jobNum = jobNum; this.dispatchName = dispatchName; printInitQueue(); } /** * 初始化高响应比优先队列 * * @param jobNum * @param timeSize * @param dispatchName */ public void HRNInit(int jobNum, int timeSize, String dispatchName) { System.out.println(\"开始\" + dispatchName + \"调度\"); readyQueue = new LinkedList&lt;&gt;(); finishQueue = new LinkedList&lt;&gt;(); this.turnoverTime = new int[jobNum]; this.turnoverTimeWithWeight = new float[jobNum]; this.cpuTime = 0; JCB jcb; for (int i = 1; i &lt;= jobNum; i++) { float v = (float) (Math.random() * 5 + 1); jcb = new JCB(i, (int) (Math.random() * 10 + 1), i - 1, (float) (Math.random() * 5 + 1)); readyQueue.offer(jcb); } this.timeSize = timeSize; this.jobNum = jobNum; this.dispatchName = dispatchName; printInitQueue(); } 作业id默认为序号i，所需服务时间随机生成，到达时间默认从0开始，响应比其他调度算法为0，高响应比算法为随机生成。 四、高响应比优先算法实现逻辑很简单，使用递归实现，参数初始为0，每次取出对头作业，因为这里所有的作业在初始化时数据都初始化好了，所以需判断作业到达时间是否小于cpu时间片，因为只有小于时间片，说明其实际是到达的。 如果小于，则设置其开始时间为cpu当前时间，结束时间为开始时间+服务时间，剩余时间设为0，同时增加cpu时间，将该作业加入已完成队列中，否则，递归调用该算法，参数为index+1，一轮结束后，对作业按响应比排序，继续递归，知道就绪队列为空。 12345678910111213141516171819202122232425262728293031323334 /** * 最高响应比优先算法 */public void HRNAlgorithm(int index) { if (readyQueue.size() == 0) { System.out.println(\"就绪队列为空，调度完毕!\"); return; } JCB head = readyQueue.get(index); if (head.arriveTime &lt;= cpuTime) { readyQueue.poll(); System.out.println(\"-----------------------------------------------------\"); System.out.println(\"时间片: \" + cpuTime + \"开始调度作业:\" + head.id + \", 剩余服务时间: \" + head.leftTime); head.beginTime = cpuTime; head.finishTime = head.beginTime + head.serviceTime; head.leftTime = 0; cpuTime += head.serviceTime; finishQueue.offer(head); System.out.println(\"时间片: \" + cpuTime + \"结束调度作业:\" + head.id + \", 剩余服务时间: \" + head.leftTime); } else { HRNAlgorithm(index++); } sortByPriority(); HRNAlgorithm(0);}/** * 根据响应比排序 */private void sortByPriority() { readyQueue.sort((o1, o2) -&gt; o1.priority &gt; o2.priority ? -1 : 1);} 五、短作业优先调度算法同高响应比优先类似，只是按照要求服务时间排序。 123456789101112131415161718192021222324252627282930313233343536/** * 短作业优先调度算法 */ public void SJFAlgorithm(int index) { if (readyQueue.size() == 0) { System.out.println(\"就绪队列为空，调度完毕！\"); return; } JCB head = readyQueue.get(index); if (head.arriveTime &lt;= cpuTime) { readyQueue.poll(); System.out.println(\"-----------------------------------------------------\"); System.out.println(\"时间片: \" + cpuTime + \"开始调度作业:\" + head.id + \", 剩余服务时间: \" + head.leftTime); head.beginTime = cpuTime; head.finishTime = head.beginTime + head.serviceTime; head.leftTime = 0; cpuTime += head.serviceTime; finishQueue.offer(head); System.out.println(\"时间片: \" + cpuTime + \"结束调度作业:\" + head.id + \", 剩余服务时间: \" + head.leftTime); } else { sortByServiceTime(); SJFAlgorithm(index++); } sortByServiceTime(); SJFAlgorithm(0); } /** * 根据要求服务时间从小到大排序 */ private void sortByServiceTime() { readyQueue.sort((o1, o2) -&gt; o1.serviceTime &lt; o2.serviceTime ? -1 : 1); } 六、先来先服务 最简单的一个算法，直接按顺序取出队头作业执行。 12345678910111213141516171819202122/** * 先来先服务调度算法 */ public void FCFSAlgorithm() { if (readyQueue.size() == 0) { System.out.println(\"就绪队列为空，调度完毕！\"); return; } JCB head = readyQueue.poll(); System.out.println(\"-----------------------------------------------------\"); System.out.println(\"时间片: \" + cpuTime + \"开始调度作业:\" + head.id + \", 剩余服务时间: \" + head.leftTime); head.beginTime = cpuTime; head.leftTime = 0; head.finishTime = head.beginTime + head.serviceTime; cpuTime += head.serviceTime; finishQueue.offer(head); System.out.println(\"时间片: \" + cpuTime + \"结束调度作业:\" + head.id + \", 剩余服务时间: \" + head.leftTime); FCFSAlgorithm(); } 七、时间片轮转算法 这里需要根据作业剩余需要服务的时间跟时间片大小做对比，代码很好理解。 123456789101112131415161718192021222324252627282930313233343536/** * 时间片轮转算法 */ public void RRAlgorithm() { if (readyQueue.size() == 0) { System.out.println(\"就绪队列为空，调度完毕！\"); return; } JCB head = readyQueue.poll(); System.out.println(\"-----------------------------------------------------\"); System.out.println(\"时间片: \" + cpuTime + \"开始调度作业:\" + head.id + \", 剩余服务时间: \" + head.leftTime); head.beginTime = cpuTime; if (head.leftTime &gt; timeSize) { //服务时间大于时间片大小 head.leftTime -= timeSize; //重新加入到就绪队列尾部 readyQueue.offer(head); cpuTime += timeSize; } else if (head.leftTime == timeSize) { //服务时间等于时间片大小 cpuTime += timeSize; head.finishTime = cpuTime; head.leftTime = 0; //加入结束队列 finishQueue.offer(head); } else { //服务时间小于时间片大小 head.finishTime = cpuTime + head.leftTime; head.leftTime = 0; cpuTime += head.leftTime; finishQueue.offer(head); } System.out.println(\"时间片: \" + cpuTime + \"结束调度作业:\" + head.id + \", 剩余服务时间: \" + head.leftTime); RRAlgorithm(); } 八、计算周转时间和带权周转时间12345678910111213141516171819/** * 计算周转时间和带权周转时间 * @param finishQueue */ public void R_Dis(Queue&lt;JCB&gt; finishQueue) { Queue&lt;JCB&gt;temp=finishQueue; JCB tempJcb; float sum = 0; for (int i = 0; i &lt; jobNum; i++) { tempJcb=temp.poll(); turnoverTime[i] = tempJcb.finishTime - tempJcb.arriveTime; turnoverTimeWithWeight[i] =(float) turnoverTime[i] / tempJcb.serviceTime; sum += turnoverTimeWithWeight[i]; temp.offer(tempJcb); } float ave = sum / jobNum; this.ave = ave; } 九、打印结果123456789101112131415161718192021222324252627282930313233343536public void printResult(boolean isHRN) { R_Dis(this.finishQueue); System.out.println(\"=====================\" + this.dispatchName + \"调度结果为=========================\"); if (isHRN) { System.out.println(\"进程名\\t\" + \"到达时间\\t\" + \"要求服务时间\\t\" + \"响应比\\t\" + \"开始时间\\t\" + \"完成时间\\t\" + \"周转时间\\t\" + \"带权周转时间\\t\"+\"平均带权周转时间\\t\"); } else { System.out.println(\"进程名\\t\" + \"到达时间\\t\" + \"要求服务时间\\t\" + \"开始时间\\t\" + \"完成时间\\t\" + \"周转时间\\t\" + \"带权周转时间\\t\"+\"平均带权周转时间\\t\"); } int count = 0; for (JCB jcb : this.finishQueue) { if (isHRN) { System.out.println(\" \" + jcb.id + \"\\t\\t\\t\" + jcb.arriveTime + \"\\t\\t\" + jcb.serviceTime + \"\\t\\t\" + jcb.priority + \"\\t\\t\" + jcb.beginTime + \"\\t\\t\" + jcb.finishTime + \"\\t\\t\" + turnoverTime[count] + \"\\t\\t\" + turnoverTimeWithWeight[count]+\"\\t\\t\"+this.ave); count = count + 1; } else { System.out.println(\" \" + jcb.id + \"\\t\\t\\t\" + jcb.arriveTime + \"\\t\\t\" + jcb.serviceTime + \"\\t\\t\" + jcb.beginTime + \"\\t\\t\" + jcb.finishTime + \"\\t\\t\" + turnoverTime[count] + \"\\t\\t\" + turnoverTimeWithWeight[count]+\"\\t\\t\"+this.ave); count = count + 1; } } } /** * 打印初始化队列 */ private void printInitQueue() { System.out.println(\"当前就绪队列为:\"); for (JCB jcb2 : readyQueue) { System.out.println(jcb2); } } 测试1234567891011121314151617181920212223public class Test { public static void main(String[] args) { SchedulingAlgorithm schedulingAlgorithm = new SchedulingAlgorithm(); schedulingAlgorithm.init(5, 2,\"轮转\"); schedulingAlgorithm.RRAlgorithm(); schedulingAlgorithm.printResult(false); schedulingAlgorithm.init(5,3,\"先来先服务\"); schedulingAlgorithm.FCFSAlgorithm(); schedulingAlgorithm.printResult(false); schedulingAlgorithm.init(5,3,\"短作业优先服务\"); schedulingAlgorithm.SJFAlgorithm(0); schedulingAlgorithm.printResult(false); schedulingAlgorithm.HRNInit(5,3,\"高响应比优先\"); schedulingAlgorithm.HRNAlgorithm(0); schedulingAlgorithm.printResult(true); }} 结果：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141开始轮转调度当前就绪队列为:JCB{id=1, serviceTime=1, arriveTime=0, priority=0.0}JCB{id=2, serviceTime=5, arriveTime=1, priority=0.0}JCB{id=3, serviceTime=4, arriveTime=2, priority=0.0}JCB{id=4, serviceTime=6, arriveTime=3, priority=0.0}JCB{id=5, serviceTime=6, arriveTime=4, priority=0.0}-----------------------------------------------------时间片: 0开始调度作业:1, 剩余服务时间: 1时间片: 0结束调度作业:1, 剩余服务时间: 0-----------------------------------------------------时间片: 0开始调度作业:2, 剩余服务时间: 5时间片: 2结束调度作业:2, 剩余服务时间: 3-----------------------------------------------------时间片: 2开始调度作业:3, 剩余服务时间: 4时间片: 4结束调度作业:3, 剩余服务时间: 2-----------------------------------------------------时间片: 4开始调度作业:4, 剩余服务时间: 6时间片: 6结束调度作业:4, 剩余服务时间: 4-----------------------------------------------------时间片: 6开始调度作业:5, 剩余服务时间: 6时间片: 8结束调度作业:5, 剩余服务时间: 4-----------------------------------------------------时间片: 8开始调度作业:2, 剩余服务时间: 3时间片: 10结束调度作业:2, 剩余服务时间: 1-----------------------------------------------------时间片: 10开始调度作业:3, 剩余服务时间: 2时间片: 12结束调度作业:3, 剩余服务时间: 0-----------------------------------------------------时间片: 12开始调度作业:4, 剩余服务时间: 4时间片: 14结束调度作业:4, 剩余服务时间: 2-----------------------------------------------------时间片: 14开始调度作业:5, 剩余服务时间: 4时间片: 16结束调度作业:5, 剩余服务时间: 2-----------------------------------------------------时间片: 16开始调度作业:2, 剩余服务时间: 1时间片: 16结束调度作业:2, 剩余服务时间: 0-----------------------------------------------------时间片: 16开始调度作业:4, 剩余服务时间: 2时间片: 18结束调度作业:4, 剩余服务时间: 0-----------------------------------------------------时间片: 18开始调度作业:5, 剩余服务时间: 2时间片: 20结束调度作业:5, 剩余服务时间: 0就绪队列为空，调度完毕！=====================轮转调度结果为=========================进程名 到达时间 要求服务时间 开始时间 完成时间 周转时间 带权周转时间 平均带权周转时间 1 0 1 0 1 1 1.0 2.3733335 3 2 4 10 12 10 2.5 2.3733335 2 1 5 16 17 16 3.2 2.3733335 4 3 6 16 18 15 2.5 2.3733335 5 4 6 18 20 16 2.6666667 2.3733335开始先来先服务调度当前就绪队列为:JCB{id=1, serviceTime=3, arriveTime=0, priority=0.0}JCB{id=2, serviceTime=10, arriveTime=1, priority=0.0}JCB{id=3, serviceTime=7, arriveTime=2, priority=0.0}JCB{id=4, serviceTime=1, arriveTime=3, priority=0.0}JCB{id=5, serviceTime=1, arriveTime=4, priority=0.0}-----------------------------------------------------时间片: 0开始调度作业:1, 剩余服务时间: 3时间片: 3结束调度作业:1, 剩余服务时间: 0-----------------------------------------------------时间片: 3开始调度作业:2, 剩余服务时间: 10时间片: 13结束调度作业:2, 剩余服务时间: 0-----------------------------------------------------时间片: 13开始调度作业:3, 剩余服务时间: 7时间片: 20结束调度作业:3, 剩余服务时间: 0-----------------------------------------------------时间片: 20开始调度作业:4, 剩余服务时间: 1时间片: 21结束调度作业:4, 剩余服务时间: 0-----------------------------------------------------时间片: 21开始调度作业:5, 剩余服务时间: 1时间片: 22结束调度作业:5, 剩余服务时间: 0就绪队列为空，调度完毕！=====================先来先服务调度结果为=========================进程名 到达时间 要求服务时间 开始时间 完成时间 周转时间 带权周转时间 平均带权周转时间 1 0 3 0 3 3 1.0 8.154286 2 1 10 3 13 12 1.2 8.154286 3 2 7 13 20 18 2.5714285 8.154286 4 3 1 20 21 18 18.0 8.154286 5 4 1 21 22 18 18.0 8.154286开始短作业优先服务调度当前就绪队列为:JCB{id=1, serviceTime=8, arriveTime=0, priority=0.0}JCB{id=2, serviceTime=10, arriveTime=1, priority=0.0}JCB{id=3, serviceTime=1, arriveTime=2, priority=0.0}JCB{id=4, serviceTime=10, arriveTime=3, priority=0.0}JCB{id=5, serviceTime=1, arriveTime=4, priority=0.0}-----------------------------------------------------时间片: 0开始调度作业:1, 剩余服务时间: 8时间片: 8结束调度作业:1, 剩余服务时间: 0-----------------------------------------------------时间片: 8开始调度作业:3, 剩余服务时间: 1时间片: 9结束调度作业:3, 剩余服务时间: 0-----------------------------------------------------时间片: 9开始调度作业:5, 剩余服务时间: 1时间片: 10结束调度作业:5, 剩余服务时间: 0-----------------------------------------------------时间片: 10开始调度作业:2, 剩余服务时间: 10时间片: 20结束调度作业:2, 剩余服务时间: 0-----------------------------------------------------时间片: 20开始调度作业:4, 剩余服务时间: 10时间片: 30结束调度作业:4, 剩余服务时间: 0就绪队列为空，调度完毕！=====================短作业优先服务调度结果为=========================进程名 到达时间 要求服务时间 开始时间 完成时间 周转时间 带权周转时间 平均带权周转时间 1 0 8 0 8 8 1.0 3.72 3 2 1 8 9 7 7.0 3.72 5 4 1 9 10 6 6.0 3.72 2 1 10 10 20 19 1.9 3.72 4 3 10 20 30 27 2.7 3.72开始高响应比优先调度当前就绪队列为:JCB{id=1, serviceTime=1, arriveTime=0, priority=5.41018}JCB{id=2, serviceTime=6, arriveTime=1, priority=5.1338425}JCB{id=3, serviceTime=6, arriveTime=2, priority=3.1670618}JCB{id=4, serviceTime=6, arriveTime=3, priority=2.0463989}JCB{id=5, serviceTime=1, arriveTime=4, priority=4.711568}-----------------------------------------------------时间片: 0开始调度作业:1, 剩余服务时间: 1时间片: 1结束调度作业:1, 剩余服务时间: 0-----------------------------------------------------时间片: 1开始调度作业:2, 剩余服务时间: 6时间片: 7结束调度作业:2, 剩余服务时间: 0-----------------------------------------------------时间片: 7开始调度作业:5, 剩余服务时间: 1时间片: 8结束调度作业:5, 剩余服务时间: 0-----------------------------------------------------时间片: 8开始调度作业:3, 剩余服务时间: 6时间片: 14结束调度作业:3, 剩余服务时间: 0-----------------------------------------------------时间片: 14开始调度作业:4, 剩余服务时间: 6时间片: 20结束调度作业:4, 剩余服务时间: 0就绪队列为空，调度完毕!=====================高响应比优先调度结果为=========================进程名 到达时间 要求服务时间 响应比 开始时间 完成时间 周转时间 带权周转时间 平均带权周转时间 1 0 1 5.41018 0 1 1 1.0 2.1666665 2 1 6 5.1338425 1 7 6 1.0 2.1666665 5 4 1 4.711568 7 8 4 4.0 2.1666665 3 2 6 3.1670618 8 14 12 2.0 2.1666665 4 3 6 2.0463989 14 20 17 2.8333333 2.1666665","link":"/posts/20200107-OS_dispatch.html"},{"title":"java并发编程之Fork-Join分治编程","text":"一、Fork-Join框架 forkjoin即分而治之，在几大排序算法中，快速排序、归并排序、二分查找均用到了分治的思想，即将一个大问题，逐一分解为一个个小问题，将各个子问题的解最终合并为最终解。这里也是如此，将一个大任务分解成若干个小任务（fork），再将这若干的小任务的执行结果进行合并（join）。 二、工作密取fork-join采用工作密取的方式实现线程的工作负载。forkjoinPool中维护了多个线程执行分下的小任务，当当前线程的任务结束后，会自动获取其他线程的任务继续执行，同时也会根据当前工作线程的空闲情况去获取任务较多的线程的task，以达到线程间的平衡，提供CPU利用率。 三、fork-join的实现forkjoin框架提供了两个子类供我们继承使用。分别是：1.RecursiveAction此类主要用于没有返回值的任务。2.RecursiveTask此类主要用于有返回值的任务 两个类都提供了compute的方法，用于生成、调用子任务，完成分治运算。在compute方法中，需要判断当前任务是否达到设置的阈值，如果小于该值，则直接执行，否则，将该任务分割成两个小任务，再让两个小任务调用invokeAll方法，会再次进入compute方法，重复以上工作。最后使用join方法等到子任务执行结束获取其运行的结果，合并即可。 这里使用invokeAll而不是用invoke主要是因为，如果使用invoke会使任务分离开，两个任务中只工作一个任务，而使用invokeAll可以让两个任务同时工作，提高效率。 fork-join的任务是通过ForkJoinPool池来执行，其提供了两种提交方式，submit和invoke，其中，submit是异步提交，不需要等待任务运行完毕即可运行sumbit之后的代码；相反，invoke是同步执行，必须等待任务完成才会执行invoke之后的代码。 四、使用Foke-Join实现数组求和 4.1创建求和任务类自定义阈值，当任务低于该阈值时直接执行，否则进行分割，任务执行完毕后返回子任务合并的结果。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556public class AddTask extends RecursiveTask&lt;Integer&gt; { /** * 阈值 */ private static final int THRESHOLD=10; private int[] nums; //左边界 private int left; //右边界 private int right; public AddTask(int[] nums, int left, int right) { this.nums = nums; this.left = left; this.right = right; } /** * 生成随机数组 * @return */ public static int[] randomNum(){ Random r = new Random(); int[] nums = new int[100]; for(int i=0;i&lt;100;i++){ nums[i] = r.nextInt(100); } return nums; } @Override protected Integer compute() { if (right-left&lt;THRESHOLD){ //任务在阈值范围内，符合要求，执行执行任务 int sum=0; for (int i = left; i &lt;= right; i++) { try { TimeUnit.MILLISECONDS.sleep(1); } catch (InterruptedException e) { e.printStackTrace(); } sum+=nums[i]; } return sum; }else { //任务太大，需要分割成小任务 int mid=(left+right)/2; AddTask leftTask=new AddTask(nums,left,mid); AddTask rightTask=new AddTask(nums,mid+1,right); invokeAll(leftTask,rightTask); //返回子任务合并的结果 return leftTask.join()+rightTask.join(); } }} 4.2创建Add类调用任务类12345678910111213141516 */public class Add { public static void main(String[] args) { ForkJoinPool forkJoinPool=new ForkJoinPool(); int[] nums = AddTask.randomNum(); System.out.println(\"待求和数组:\"+ Arrays.toString(nums)); //创建求和任务 AddTask addTask=new AddTask(nums,0,nums.length-1); forkJoinPool.invoke(addTask); System.out.println(\"求和中。。\"); System.out.println(\"和为:\"+addTask.join()); }} 结果：待求和数组:[34, 38, 71, 98, 38, 51, 35, 67, 59, 58, 33, 64, 65, 40, 30, 49, 67, 15, 4, 3, 5, 10, 94, 17, 24, 43, 94, 52, 53, 81, 7, 70, 25, 90, 96, 3, 84, 73, 54, 11, 42, 97, 18, 11, 95, 28, 14, 74, 95, 91, 53, 48, 69, 71, 91, 64, 25, 72, 3, 74, 77, 90, 22, 36, 77, 86, 41, 53, 92, 15, 30, 5, 51, 86, 60, 49, 76, 91, 15, 38, 55, 37, 24, 58, 53, 58, 75, 77, 34, 41, 88, 50, 91, 25, 56, 83, 14, 3, 75, 7]求和中。。和为:5134 而如果使用submit提交，将数组大小改为10000，就可看到求和中一句话是在任务执行完毕后才会打印，体现同步性。","link":"/posts/20200123-ForkJoin.html"},{"title":"java并发编程之CountDownLatch,CyclicBarrier和Semaphore","text":"一、CountDownLatch CountDownLatch能够让一个线程在等待其他线程全部完成各自任务后再执行。而CountDownLatch是通过计数器来实现的，计数器的初始值即为任务的总数。 举个例子，如，同学聚会结束回家，每个人都要回各自的家，此时计数器的初始值为参加聚会的总人数，而每个人都是一个线程，每个同学到家后，都需要调用countDown方法，对计数器减一，表示完成回家的任务，当所有同学都到家后，主线程才可以执行通知班长全部到家的任务。再比如，所编写的应用程序，希望等待启动框架的线程启动完毕后再执行。 1.1 构造方法1234public CountDownLatch(int count) { if (count &lt; 0) throw new IllegalArgumentException(\"count &lt; 0\"); this.sync = new Sync(count); } CountDownLatch的构造方法需要一个count参数，代表初始任务的数量，往后每当调用一次（CountDownLatch.countDown()方法，count都减一，当count减到0的时候，调用CountDownLatch.await()方法的线程就可以执行其任务。 除此之外，CountDownLatch还有以下几个方法： 1.await(long timeout,TimeUnit unit) 1234public boolean await(long timeout, TimeUnit unit) throws InterruptedException { return sync.tryAcquireSharedNanos(1, unit.toNanos(timeout)); } 此方法在await()的基础上添加了时间限制，如果调用await的线程在到达该时间后，count仍然没有0，其会继续执行，不再等到count到0。 2. public long getCount() 123public long getCount() { return sync.getCount(); } 即获取该CountDownLatch当前的count值 二、Demo应用12345678910111213141516171819202122232425262728293031323334353637383940414243package com.wml.test1.countdownlatch;import java.util.concurrent.CountDownLatch;/** * @author Wang * @date 2020/1/2317:27 */public class CountDownLatchTest { //1. private static CountDownLatch finishEat=new CountDownLatch(1); //2. private static CountDownLatch friends=new CountDownLatch(10); public static void main(String[] args) throws InterruptedException { //3. for (int i = 0; i &lt;10; i++) { new Thread(()-&gt;{ try { //4. finishEat.await(); System.out.println(Thread.currentThread().getName()+\"正在回家\"); //5. friends.countDown(); System.out.println(Thread.currentThread().getName()+\"到家啦\"); } catch (InterruptedException e) { e.printStackTrace(); } },\"同学\"+(i+1)).start(); } System.out.println(\"聚会结束，同学们准备回家\"); //6. finishEat.countDown(); //7. friends.await(); //8. System.out.println(\"同学全部到家\"); }} 说明：1.代码1创建一个结束聚餐的CountDownLatch，finishEat。初始值为1，代表正在聚餐，当主线程调用countDown()时（代码6），count值从1变为0，代表结束聚餐。这时，其他调用finishEat.await();的线程（各个同学回家的线程）由阻塞状态变为执行。2.代码2创建一个同学回家的CountDownLatch，friends。初始值为10，代表参加聚会的10个同学，即10个同学需要执行回家任务。回家的任务需要在代码4finishEat.await();后执行。3.代码3创建10个回家的线程，每个线程中都执行一次friends.countDown();，让friends的count减一4.代码7friends.await();主线程阻塞等待friends的count变为0时开始执行下面的代码。结果： 1234567891011121314聚会结束，同学们准备回家同学1正在回家同学1到家啦同学2正在回家同学2到家啦同学4正在回家同学4到家啦同学3正在回家同学3到家啦同学5正在回家同学5到家啦同学6正在回家同学6到家啦同学全部到家 三、CyclicBarrierCyclic（循环的）Barrier（屏障），该工具做的事情是，当一个线程到达一个屏障（同步点/临界点）时会被阻塞，等待到最后一个线程到达该点后，被拦截阻塞的线程才可以继续执行。比如：同学聚餐，不会是到一个就吃一个，而是到的人先等待，直到所有人都达到饭桌后，才开始吃饭。这里餐桌就类似barrier，每个同学都是一个线程，每个人到饭桌后都被阻塞，直到最后一个同学到达。而因为CyclicBarrier是可循环的，当一组线程到达后，其仍然有效，可以继续下一组循环。 3.1构造方法1.默认构造方法 123public CyclicBarrier(int parties) { this(parties, null); } 传入的参数表示需要拦截的线程总数，每当一个线程调用CyclicBarrier.await()方法后，会通知CyclicBarrier该线程已到达屏障。与CountDownLatch一样，CyclicBarrier也为await提供了超时时间设置。 123456public int await(long timeout, TimeUnit unit) throws InterruptedException, BrokenBarrierException, TimeoutException { return dowait(true, unit.toNanos(timeout)); } 线程阻塞直到到达超时时间。2.高级构造方法 1public CyclicBarrier(int parties, Runnable barrierAction) 该方法使得线程到达障碍后，优先执行barrierAction的操作。 3.2 CyclicBarrier的方法3.2.1 await1234567public int await() throws InterruptedException, BrokenBarrierException { try { return dowait(false, 0L); } catch (TimeoutException toe) { throw new Error(toe); // cannot happen } } 该方法等待所有的线程都到达指定的临界点。但如果当前线程不是最后到达的线程，则出于线程调度目的将其禁用，并使其处于休眠状态，直到发生以下情况之一： 最后一个线程到达 其他线程中断当前线程 其他线程中断等待线程之一 在屏障等待时其他线程超时 其他线程在此屏障上调用reset方法 在await方法中调用的dowait方法以下是dowait源码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566private int dowait(boolean timed, long nanos) throws InterruptedException, BrokenBarrierException, TimeoutException { final ReentrantLock lock = this.lock; lock.lock(); try { final Generation g = generation; if (g.broken) throw new BrokenBarrierException(); //代码1 if (Thread.interrupted()) { breakBarrier(); throw new InterruptedException(); } //代码2 int index = --count; if (index == 0) { // tripped boolean ranAction = false; try { final Runnable command = barrierCommand; if (command != null) command.run(); ranAction = true; nextGeneration(); return 0; } finally { if (!ranAction) breakBarrier(); } } // 代码3 for (;;) { try { if (!timed) trip.await(); else if (nanos &gt; 0L) nanos = trip.awaitNanos(nanos); } catch (InterruptedException ie) { if (g == generation &amp;&amp; ! g.broken) { breakBarrier(); throw ie; } else { // We're about to finish waiting even if we had not // been interrupted, so this interrupt is deemed to // \"belong\" to subsequent execution. Thread.currentThread().interrupt(); } } if (g.broken) throw new BrokenBarrierException(); if (g != generation) return index; if (timed &amp;&amp; nanos &lt;= 0L) { breakBarrier(); throw new TimeoutException(); } } } finally { lock.unlock(); } } 说明：代码1：如果当前线程被中断，会调用breakBarrier方法并抛出InterruptedException异常。breakBarrier方法如下： 12345private void breakBarrier() { generation.broken = true; count = parties; trip.signalAll(); } 1.breakBarrier首先将该代的broken设置为true，代表其被打破。2.generation是CyclicBarrier的一个静态内部类Generation的对象，该对象代表屏障的当前代，可以实现循环等待。broken为true，则该循环结束。3.同时将count重置为parties； count为计数器，parties是CyclicBarrier的构造参数，代表拦截的线程数4.调用trip的signalAll()方法，将所有阻塞的线程唤醒 trip是成员变量Condition的对象，可见是使用Condition实现阻塞队列的。代码2：计数器count减一并赋值给int变量index，如果此时index值为0，则判断当前barrierCommand是否为空，（barrierCommand也是CyclicBarrier的成员变量，为换代前优先执行的任务，其在CyclicBarrier构造方法中传入，如下： 12345public CyclicBarrier(int parties, Runnable barrierAction) { .......... ........... this.barrierCommand = barrierAction; } ），如果不为空，则执行该操作的run()方法。最后置ranAction为true，个人理解代表继续执行，并执行nextGeneration()进入下一代（下一个循环）。nextGeneration()代码如下： 1234567private void nextGeneration() { // signal completion of last generation trip.signalAll(); // set up next generation count = parties; generation = new Generation(); } 在nextGeneration()中唤醒所有阻塞进程，重置计数器，并重新new了一个Generation。而在finally中，如果barrierCommand执行出错，或其他原因，会执行breakBa在这里插入代码片rrier()方法。代码3：无限循环直到发生tripped，断开，中断或超时。timed代表是否开启超时时间，nanos 为设定的超时时间 3.2.2 getNumberWaiting123456789public int getNumberWaiting() { final ReentrantLock lock = this.lock; lock.lock(); try { return parties - count; } finally { lock.unlock(); }} 返回当前有多少个线程阻塞等待在屏障上 3.3 isBroken1boolean isBroken() 返回查询阻塞等待的线程是否被中断打破 四、CyclicBarrier 例子12345678910111213141516171819202122232425262728293031323334353637package com.wml.test1.cyclicbarrier;import java.util.concurrent.*;/** * @author Wang * @date 2020/1/2317:44 */public class CyclicBarrierTest { //代码1 private static CyclicBarrier barrier=new CyclicBarrier(6,()-&gt;{ System.out.println(\"同学们都到齐了，咱们开饭\"); }); public static void main(String[] args) { ExecutorService pool = new ThreadPoolExecutor(6,100,0L,TimeUnit.MILLISECONDS, new LinkedBlockingDeque&lt;&gt;()); for (int i = 1; i &lt;= 6; i++) { pool.execute(() -&gt; { try { System.out.println(Thread.currentThread().getName() + \"到了\"); //代码2 barrier.await(); System.out.println(Thread.currentThread().getName() + \"开吃\"); } catch (InterruptedException e) { e.printStackTrace(); } catch (BrokenBarrierException e) { e.printStackTrace(); } }); } }} 说明：该例子为同学聚餐，每到一个同学便阻塞自己，当所有同学都到齐后，输出“开饭”，然后唤醒所有同学，执行“吃饭” 代码1：构造一个CyclicBarrier 屏障，拦截线程数为6，在进入下一代前执行System.out.println(&quot;同学们都到齐了，咱们开饭&quot;);这一barrierCommand，即当前代结束（所有线程都到达屏障时或其他原因）后优先执行该操作。代码2：每个线程到达屏障后执行await方法，直到所有线程都到达，await中会执行唤醒所有阻塞线程的方法，最后才会执行后面的代码。结果： 12345678910111213pool-1-thread-1到了pool-1-thread-2到了pool-1-thread-3到了pool-1-thread-4到了pool-1-thread-5到了pool-1-thread-6到了同学们都到齐了，咱们开饭pool-1-thread-6开吃pool-1-thread-2开吃pool-1-thread-3开吃pool-1-thread-5开吃pool-1-thread-4开吃pool-1-thread-1开吃 五、CountDownLatch和CyclicBarrier的异同1.CountDownLatch技术器只能使用一次，CyclicBarrier的可以循环使用。2.CountDownLatch是一个线程等待所有线程完成任务后才会执行自己的任务，是阻塞工作线程。CyclicBarrier是所有线程到达某个屏障（临界点）后互相等待，直到所有线程都到达后再共同进行下面的任务。3.CountDownLatch调用countDown方法可以继续执行后面的，只是调用await方法的线程会阻塞等待直到所有线程都调用countDown；CyclicBarrier是所有的线程调用await进行自阻塞，等到所有线程都调用一次await后一起继续执行后面操作。4.CyclicBarrier可以在所有线程都到达屏障后执行barrierAction操作，完成复杂的逻辑场景。 六、SemaphoreSemaphore即信号量，是用来控制同时访问特定资源的线程数量，或同时执行某个指定操作的数量。比如可以用来实现数据库的连接池等。如数据库的连接数为20个，这时只能有20个线程同时获取数据量连接，再多的线程只能阻塞等待，当一个线程归还连接后，阻塞的线程才能继续获取。 Semaphore的构造方法： 1public Semaphore(int permits) 传入一个整型permits，代表可用的许可证数量。操作时必须先获取许可证，才能继续操作，当操作完成后需释放许可证，其余没有获得许可证的便阻塞等待，直到有线程释放了许可证。线程使用Semaphore的acquire()方法获取许可证，使用release()方法释放许可证，使用tryAcquire()方法尝试获取许可证. 其他方法： 12345intavailablePermits() //返回此信号量中当前可用的许可证数。intgetQueueLength() //返回正在等待获取许可证的线程数。booleanhasQueuedThreads()//是否有线程正在等待获取许可证。void reducePermits（ int reduction） //减少 reduction 个许可证Collection getQueuedThreads() //返回所有等待获取许可证的线程集合 semaphore示例：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566package com.wml.test1.semphore;import java.sql.Connection;import java.util.LinkedList;import java.util.Random;import java.util.concurrent.*;/** * @author Wang * @date 2020/1/2416:31 */public class SemphoreTest { private final static int POOL_SIZE=10; private final Semaphore connections; //连接池 private static LinkedList&lt;Integer&gt;pool; public SemphoreTest() { pool=new LinkedList&lt;&gt;(); //初始化连接池 for (int i = 0; i &lt; POOL_SIZE; i++) { pool.addLast(i); } this.connections = new Semaphore(POOL_SIZE); } //释放连接 public void release(Integer conn){ if(conn!=null) { System.out.println(\"当前有\"+connections.getQueueLength()+\"个线程等待数据库连接!!\" +\"可用连接数：\"+connections.availablePermits()); synchronized (pool) { pool.addLast(conn); } connections.release(); } } //获取连接 public Integer acquire() throws InterruptedException { connections.acquire(); Integer conn; synchronized (pool){ conn=pool.removeFirst(); } return conn; } public static void main(String[] args) { SemphoreTest dbPool=new SemphoreTest(); ExecutorService pool = new ThreadPoolExecutor(50,100,0L, TimeUnit.MILLISECONDS, new LinkedBlockingDeque&lt;&gt;()); //50个线程获取连接 for (int i = 0; i &lt; 50; i++) { pool.execute(()-&gt;{ try { Integer conn=dbPool.acquire(); System.out.println(Thread.currentThread().getName() +\"--------获取数据库连接\"); Thread.sleep(1000); System.out.println(\"归还连接\"); dbPool.release(conn); } catch (InterruptedException e) { } }); } }}","link":"/posts/20200124-cdlcbs.html"},{"title":"java多线程之Callable+Future+FutureTask原理详解和简单使用","text":"一、Runnable和CallableRunnable是一个接口，只声明了一个run()方法，此方法为void类型，所以只能执行无返回值的任务。 123public interface Runnable { public abstract void run();} Callable是java.util.concurrent包下的一个接口，提供了一个call()方法: 12345678910@FunctionalInterfacepublic interface Callable&lt;V&gt; { /** * Computes a result, or throws an exception if unable to do so. * * @return computed result * @throws Exception if unable to compute a result */ V call() throws Exception;} 该方法返回的数据类型就是传进来的泛型类型，主要用于计算产生结果。如果没有计算出结果，则会抛出异常。 二、FutureFuture则是对于具体的Runnable或Callable任务的执行结果进行取消、判断是否完成、获取任务执行结果。Future接口声明了5个方法： 1boolean cancel(boolean mayInterruptIfRunning); 尝试取消此任务的执行。如果取消成功则返回true，取消失败则返回false。 如果任务已完成、已取消或由于其他原因无法取消，则此尝试将失败，返回false。传入的参数如果为true，则直接中断正在执行的任务，返回true；如果为false，则允许正在进行的任务完成。 1boolean isCancelled(); 任务是否被取消成功，如果此任务在正常工作之前被取消，则返回true。 1boolean isDone(); 如果此任务已完成，则返回true。完成可能是由于正常终止、异常或取消 - 在所有这些情况下，此方法将返回 true。 1V get() throws InterruptedException, ExecutionException; 以阻塞的方式获取任务执行结果，知道任务执行完毕返回。另外在以下情况会抛出异常：1.任务被取消：抛出 CancellationException 异常2.计算引发异常：抛出 ExecutionException 异常3.当前线程被中断：抛出 InterruptedException 异常 12V get(long timeout, TimeUnit unit) throws InterruptedException, ExecutionException, TimeoutException; 同上，但规定了超时时间，如果在规定时间内没有计算出结果，会抛出TimeoutException异常。 三、FutureTaskFutureTask类实现了RunnableFuture接口，而RunnableFuture继承了Runnable和Future接口，可知FutureTask可做Runnable和Future一样的事情。 123public class FutureTask&lt;V&gt; implements RunnableFuture&lt;V&gt; public interface RunnableFuture&lt;V&gt; extends Runnable, Future&lt;V&gt; 3.1 首先看FutureTask的成员变量1234567891011121314private volatile int state; private static final int NEW = 0; private static final int COMPLETING = 1; private static final int NORMAL = 2; private static final int EXCEPTIONAL = 3; private static final int CANCELLED = 4; private static final int INTERRUPTING = 5; private static final int INTERRUPTED = 6; private Callable&lt;V&gt; callable; private Object outcome; // non-volatile, protected by state reads/writes private volatile Thread runner; private volatile WaitNode waiters; 1.state：state保存了FutureTask任务的状态值，为volatile类型，保证了原子性，即任何一个线程修改了state的值，都可以保证其他线程看到修改后的值。state共有如下几个取值（对应的值依此为0到6）： NEW：为state的初始值。表示该任务是个新任务。COMPLETING:当前任务已经执行完毕或执行任务过程中出现了异常，但结果尚未保存到outcome（outcome用来保存计算结果或者是异常信息）中，属于中间状态。NORMAL: 任务执行完毕，且结果保存到outcome中。此为最终状态。EXCEPTIONAL: 任务执行过程中出现异常，且异常信息已保存到outcome中。此为最终状态。CANCELLED：任务尚未开始或任务执行时调用了cancel(false)方法。此为最终状态。INTERRUPTING：任务尚未开始或任务执行时调用了cancel(true)方法。此为中间状态。INTERRUPTED: 在调用cancel(true)时，会调用: 123Thread t = runner; if (t != null) t.interrupt(); state会变为INTERRUPTED，此为最终状态。但如果被终端的线程正在sleep()、wait()、或join()，则会抛出InterruptedException()异常，因此cancel(true)（注意：中间状态时间短暂，不代表任务仍在执行，而是任务执行完毕后尚未设置执行结果，因此除了NEW状态，其余状态都代表已经执行结束）可能出现的转变状态为： 1234NEW -&gt; COMPLETING -&gt; NORMALNEW -&gt; COMPLETING -&gt; EXCEPTIONALNEW -&gt; CANCELLEDNEW -&gt; INTERRUPTING -&gt; INTERRUPTED 2.callable：要执行的task任务。3.outcome: 保存执行结果或出现异常时保存异常信息4.runner:执行task的线程，在取消和中断线程时需要知道是哪个线程。5.waiters：为WaitNode 的对象。WaitNode 为一个简单的单向链表结构的队列，当任务执行过程中，有线程想要调用get()获取结果时，则该线程会被阻塞加入WaitNode，直到该任务执行完毕。以下为WaitNode的结构： 12345static final class WaitNode { volatile Thread thread; volatile WaitNode next; WaitNode() { thread = Thread.currentThread(); } } 仅由一个Thread和指向下一个节点的next组成，thread即为当前线程。其本质是一个Treiber栈。 3.2静态代码块中初始化需要CAS操作的属性的偏移量12345678910111213141516171819// Unsafe mechanics private static final sun.misc.Unsafe UNSAFE; private static final long stateOffset; private static final long runnerOffset; private static final long waitersOffset; static { try { UNSAFE = sun.misc.Unsafe.getUnsafe(); Class&lt;?&gt; k = FutureTask.class; stateOffset = UNSAFE.objectFieldOffset (k.getDeclaredField(\"state\")); runnerOffset = UNSAFE.objectFieldOffset (k.getDeclaredField(\"runner\")); waitersOffset = UNSAFE.objectFieldOffset (k.getDeclaredField(\"waiters\")); } catch (Exception e) { throw new Error(e); } } CAS操作调用的是compareAndSwap***方法 3.3 构造方法3.3.1 123456public FutureTask(Callable&lt;V&gt; callable) { if (callable == null) throw new NullPointerException(); this.callable = callable; this.state = NEW; // ensure visibility of callable } 将传入的callable赋值给上面说的成员变量callable，将state初始化为NEW；3.3.2 1234public FutureTask(Runnable runnable, V result) { this.callable = Executors.callable(runnable, result); this.state = NEW; // ensure visibility of callable } 传入Runnable对象，通过Executors.callable()方法将runnable转为callable保存给callable变量，同时会返回传入的result。将runnable转为callable的方法如下： 12345public static &lt;T&gt; Callable&lt;T&gt; callable(Runnable task, T result) { if (task == null) throw new NullPointerException(); return new RunnableAdapter&lt;T&gt;(task, result); } 这里调用RunnableAdapter()适配,代码如下： 12345678910111213static final class RunnableAdapter&lt;T&gt; implements Callable&lt;T&gt; { final Runnable task; final T result; RunnableAdapter(Runnable task, T result) { this.task = task; this.result = result; } public T call() { task.run(); return result; } } } RunnableAdapter实现了Callable接口，在call()中调用task.run()，将传入的result返回。 3.4 方法3.4.1 run()1234567891011121314151617181920212223242526272829303132333435public void run() { //代码1 if (state != NEW || !UNSAFE.compareAndSwapObject(this, runnerOffset, null, Thread.currentThread())) return; try { Callable&lt;V&gt; c = callable; if (c != null &amp;&amp; state == NEW) { //代码2 V result; boolean ran; try { result = c.call(); ran = true; } catch (Throwable ex) { result = null; ran = false; setException(ex); } if (ran) set(result); } } finally { // runner must be non-null until state is settled to // prevent concurrent calls to run() //代码3 runner = null; // state must be re-read after nulling runner to prevent // leaked interrupts int s = state; if (s &gt;= INTERRUPTING) handlePossibleCancellationInterrupt(s); } } 代码1：1.state!=NEW: 如果state不为NEW，即任务已经执行完毕或被取消，直接返回。2. 若state是NEW，则尝试将当前线程保存到runner中，即如果runner为空就将当前线程保存给runner，若runner不为空，则说明已经有线程在执行，直接return,否则进入try-catch。 代码2：1.定义V result保存callable的执行结果，置ran为true，代表执行成功。2.若出现异常，则在catch中捕获，将result置为null，ran置为false代表出现异常，同时通过setException(ex)设置异常。setException(ex)代码如下： 1234567protected void setException(Throwable t) { if (UNSAFE.compareAndSwapInt(this, stateOffset, NEW, COMPLETING)) { outcome = t; UNSAFE.putOrderedInt(this, stateOffset, EXCEPTIONAL); // final state finishCompletion(); } } 此方法中，尝试将state的值从NEW改为COMPLETING,如果成功，则将异常信息保存到outcome中，然后再将状态改为最终态EXCEPTIONAL，最后调用finishCompletion()移除并唤醒WaitNode中所有阻塞等待的线程，调用done()，并让callable无效，源码如下： 12345678910111213141516171819202122private void finishCompletion() { // assert state &gt; COMPLETING; for (WaitNode q; (q = waiters) != null;) { if (UNSAFE.compareAndSwapObject(this, waitersOffset, q, null)) { for (;;) { Thread t = q.thread; if (t != null) { q.thread = null; LockSupport.unpark(t); } WaitNode next = q.next; if (next == null) break; q.next = null; // unlink to help gc q = next; } break; } } done(); callable = null; } 如果ran为true，即正常执行，通过set(result)，set()源码如下： 1234567protected void set(V v) { if (UNSAFE.compareAndSwapInt(this, stateOffset, NEW, COMPLETING)) { outcome = v; UNSAFE.putOrderedInt(this, stateOffset, NORMAL); // final state finishCompletion(); } } 在set()中，尝试将状态从NEW变为COMPLETING中间态(这里再重新理解上面说的state的7个状态会更深刻一点)，并将结果保存给outcome，接着将state由COMPLETING转为NORMAL最终状态，同上调用 finishCompletion()。 代码3：1.在finally中重新将runner置空，表明当前线程运行完毕，在下一个线程进入到run()（代码1）方法时，便可通过CAS重新将线程保存到runner。2.若ran为false，即出现了异常，则调用handlePossibleCancellationInterrupt(state)处理异常， 1234567891011121314151617private void handlePossibleCancellationInterrupt(int s) { // It is possible for our interrupter to stall before getting a // chance to interrupt us. Let's spin-wait patiently. if (s == INTERRUPTING) while (state == INTERRUPTING) Thread.yield(); // wait out pending interrupt // assert state == INTERRUPTED; // We want to clear any interrupt we may have received from // cancel(true). However, it is permissible to use interrupts // as an independent mechanism for a task to communicate with // its caller, and there is no way to clear only the // cancellation interrupt. // // Thread.interrupted(); } 在该方法中，如果状态一直是INTERUPING，则一直进行yield()。 3.4.2 get()线程可调用get()方法获取任务执行的结果，如果当前任务尚未执行完毕，则阻塞调用get()方法的线程，直到任务执行结束。 123456789/** * @throws CancellationException {@inheritDoc} */ public V get() throws InterruptedException, ExecutionException { int s = state; if (s &lt;= COMPLETING) s = awaitDone(false, 0L); return report(s); } get()方法中首先判断当前的状态是否小于等于COMPLETING，即任务是否处于尚未开始或尚未结束或结果尚未保存到outcome的状态，如果是，则调用awaitDone(false, 0L);阻塞等待，否则调用report(s)返回执行结果。 report()12345678private V report(int s) throws ExecutionException { Object x = outcome; if (s == NORMAL) return (V)x; if (s &gt;= CANCELLED) throw new CancellationException(); throw new ExecutionException((Throwable)x); } 获取当前结果outcome，如果当前状态为NORMAL，则直接返回结果，如果当前状态大于等于CANCELLED，则抛出CancellationException()异常，其他状态则抛出ExecutionException()异常。 3.4.3 awaitDone()线程调用此方法阻塞等待任务执行结束。 123456789101112131415161718192021222324252627282930313233343536373839404142434445private int awaitDone(boolean timed, long nanos) throws InterruptedException { //若开启超时，则计算截止时间 final long deadline = timed ? System.nanoTime() + nanos : 0L; //创建一个WaitNode节点 WaitNode q = null; //是否进入阻塞队列 boolean queued = false; for (;;) { //代码1 if (Thread.interrupted()) { removeWaiter(q); throw new InterruptedException(); } int s = state; //代码2 if (s &gt; COMPLETING) { if (q != null) q.thread = null; return s; } //代码3 else if (s == COMPLETING) // cannot time out yet Thread.yield(); //代码4 else if (q == null) q = new WaitNode(); //代码5 else if (!queued) queued = UNSAFE.compareAndSwapObject(this, waitersOffset, q.next = waiters, q); //代码6 else if (timed) { nanos = deadline - System.nanoTime(); if (nanos &lt;= 0L) { removeWaiter(q); return state; } LockSupport.parkNanos(this, nanos); } else LockSupport.park(this); }} 方法的参数为 timed(是否开启超时时间)和nanos(若开启超时时间，则此参数为超时时间)（代码1到代码6在一个无限for循环中，不停的进行循环判断） 代码1：如果当前线程被中断，则将阻塞队列waitNode中的该节点给移除，并抛出InterruptedException()异常。代码2：判断当前阻塞线程的状态是否大于COMPLETING，如果大于，则该任务已经执行完毕，如果当前节点非空，则删除该节点的thread，并返回状态。代码3： 如果当前状态为COMPLETING，则说明任务执行完毕，但是执行结果尚未赋值给outcome，此时执行yield让出CPU。代码4：如果当前阻塞等待节点q为空，则新建一个节点。代码5：如果尚未入队列，则将上一个节点的next指向waiters，然后尝试让新的节点q替换waiters，如果尝试成功则queued为true，否则为false。代码6：如果开启了超时限制，则重新计算等待时间，如果 nanos&lt;=0L，即超时了，则移除等待队列中的该节点，并返回当前state；如果没有超时，则继续阻塞重新计算后的时间。如果没有开启超时限制，则直接阻塞等待直到被唤醒。 3.4.4 cancel()1234567891011121314151617181920212223public boolean cancel(boolean mayInterruptIfRunning) { //代码1 if (!(state == NEW &amp;&amp; UNSAFE.compareAndSwapInt(this, stateOffset, NEW, mayInterruptIfRunning ? INTERRUPTING : CANCELLED))) return false; try { //代码2 if (mayInterruptIfRunning) { try { Thread t = runner; if (t != null) t.interrupt(); } finally { // final state UNSAFE.putOrderedInt(this, stateOffset, INTERRUPTED); } } } finally { //代码3 finishCompletion(); } return true; } 代码1：1.如果state不等于NEW，则任务已经执行完毕或出现异常或被取消，直接返回false；2.如果任务尚未开始，则通过CAS尝试将状态从NEW改为mayInterruptIfRunning，若mayInterruptIfRunning为true，代表需要中断任务执行线程，则改为INTERRUPTING中间状态，否则改为CANCELLED最终状态，如果尝试更新成功，则返回true，否则返回false。代码2：如果进行了中断，则获取当前的线程runner，中断之。最后将状态由INTERRUPTING改为INTERRUPTED代码3：执行finishCompltion()(任务出现异常或正常执行完毕或成功取消任务都会调用该方法，上文已提到)，返回true 3.4.5 isCancelled()123public boolean isCancelled() { return state &gt;= CANCELLED; } 判断任务是否被取消。只要状态大于等于CANCELLED都返回true。 3.4.6 isDone()123public boolean isDone() { return state != NEW; } 只要不是NEW，都返回true，代表任务已完成。 四.Callable+Future示例12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455package com.wml.test2.future;import java.util.concurrent.*;/** * @author MaoLin Wang * @date 2020/1/2723:18 */public class FutureDemo { public static class Task implements Callable&lt;Integer&gt;{ private int sum; @Override public Integer call() throws Exception { System.out.println(\"Callable线程开始执行任务\"); Thread.sleep(1500); for (int i = 0; i &lt; 50; i++) { if (Thread.currentThread().isInterrupted()){ System.out.println(\"Callable线程计算任务中断\"); return null; } if (i%2==0){ sum=sum+i; System.out.println(\"sum=\"+sum); } } System.out.println(\"Callable线程执行完毕 计算结果为\"+sum); return sum; } } public static void main(String[] args) { Task task=new Task(); ExecutorService pool = new ThreadPoolExecutor(6,100,0L,TimeUnit.MILLISECONDS, new LinkedBlockingDeque&lt;&gt;()); Future&lt;Integer&gt;future=pool.submit(task); pool.shutdown(); try { Thread.sleep(3000L); System.out.println(\"主线程执行其他任务中.....\"); if (future.get()!=null){ System.out.println(\"主线程获取Callable执行结果:\"+future.get()); }else { System.out.println(\"尚未获取到结果\"); } } catch (InterruptedException e) { e.printStackTrace(); } catch (ExecutionException e) { e.printStackTrace(); } }} 结果： 1234567891011121314151617181920212223242526272829Callable线程开始执行任务sum=0sum=2sum=6sum=12sum=20sum=30sum=42sum=56sum=72sum=90sum=110sum=132sum=156sum=182sum=210sum=240sum=272sum=306sum=342sum=380sum=420sum=462sum=506sum=552sum=600Callable线程执行完毕 计算结果为600主线程执行其他任务中.....主线程获取Callable执行结果:600 五、Callable+FutureTask示例Task类同上 12345678910111213141516171819202122public static void main(String[] args) { ExecutorService pool = new ThreadPoolExecutor(6,100,0L, TimeUnit.MILLISECONDS, new LinkedBlockingDeque&lt;&gt;()); Task task=new Task(); //创建FutureTask任务 FutureTask futureTask=new FutureTask(task); pool.submit(futureTask); pool.shutdown(); try { Thread.sleep(3000L); System.out.println(\"主线程执行其他任务中.....\"); if (futureTask.get()!=null){ System.out.println(\"主线程获取Callable执行结果:\"+futureTask.get()); }else { System.out.println(\"尚未获取到结果\"); } } catch (InterruptedException e) { e.printStackTrace(); } catch (ExecutionException e) { e.printStackTrace(); } } 结果： 1234567891011Callable子线程开始计算！sum=0sum=1sum=3sum=6sum=10sum=15sum=21Cancel................. sum=28Callable子线程计算任务中断！","link":"/posts/20200127-runcalfutask.html"},{"title":"java多线程之CAS操作及相关原子操作类详解","text":"一、原子操作是什么原子操作即不可被中断（分割）的一个或一系列操作，如对于A,B两个操作，如果一个线程操作A，若另一个线程执行B操作时，要么将B执行到结束，要么完全不让B执行，此时对于A和B来说，就是原子的。 二、悲观锁和乐观锁如synchronized就是悲观锁，解决多线程并发问题，以保证事务的完整性。其是基于阻塞的锁机制，如果有一个线程拥有锁后，访问该资源的其他线程就需要阻塞等待，直到获得锁的线程释放锁。CAS操作即是乐观锁，每个线程都可以访问，只有在提交数据的时候检查是否违反了数据的完整性，即每次都尝试去完成某个操作，如果冲突和造成操作失败，就循环重试，直到操作成功为止。 使用synchronized会引出很多问题，如：获得锁的线程一直不释放锁；大量线程竞争资源，可能会造成死锁；被阻塞的线程可能优先级很高却一直无法获取锁。 因此实现原子操作可使用CAS指令。 三、CASCAS 即Compare and Swap，比较并交换。每个CAS操作过程都包括三个运算符：内存地址V、期望值A、新的值B如果操作的时候地址V上的值等于期望的值A，则将地址V上的值更新为B，否则不做任何操作，但要返回原值。循环CAS就是不断的进行CAS操作直到操作成功。可防止内存中共享变量出现脏读脏写的问题。CAS是通过硬件CPU和内存，利用CPU的多处理能力实现硬件层面的阻塞，再加上volatile变量的特性来实现基于原子操作的线程安全。 （1）get变量值(旧值)—–&gt;（2）计算后得到新值——&gt;（3）比较内存中变量值和旧值—–&gt;（4）如果（3）相等，则让新值替换旧值，否则继续（1） 四、CAS实现原子操作的三大问题4.1ABA问题由于CAS在操作值的时候需要检查旧值是否发生变化，如果未变化则更新值，但如果一个值原来是A，变成了B，然后又变为了A，这样虽然值已经发生了变化，但使用CAS进行检查时会发现它的旧值“未变化”。而要解决该问题，就是使用版本号。即给变量添加版本号，每次更新变量都去更新它的版本号，如刚刚A-&gt;B-&gt;A，便变成了 1A-&gt;2B-&gt;3A。就像在家里倒了一杯水，你还没来得及喝，但是被家人喝掉， 然后又给你接满了一杯水，这样如果在不知道的情况下，你会认为这仍然是之前那杯水。又或者你的资金被别人挪用了，然后又还给了你，虽然钱没有变，但造成的问题时那个人已经犯罪了。 4.2循环时间长，开销大如果CAS一直处于自旋不成功状态，CPU的开销会大大增加。 4.3只能保证一个共享变量的原子操作当对一个共享变量执行操作时，可使用循环 CAS 的方式来保证原子操作，但是对多个共享变量操作时，循环 CAS 就无法保证操作的原子性，当然可以用锁。也可以把多个共享变量合并成一个共享变量来操作。如，有两个共享变量 i＝a，j=b，合并一下 ij=ab，然后用 CAS 来操作 ij，然后通过AtomicReference 类来保证引用对象之间的原子性，便实现了多个变量放在一个对象里来进行 CAS 操作。 五、JDK中相关原子操作类的使用5.1概览更新基本类型类：AtomicBoolean，AtomicInteger，AtomicLong更新数组类：AtomicIntegerArray，AtomicLongArray，AtomicReferenceArray更新引用类型：AtomicReference，AtomicMarkableReference，AtomicStampedReference原子更新字段类： AtomicReferenceFieldUpdater，AtomicIntegerFieldUpdater，AtomicLongFieldUpdater 基本数据类型的原子操作类以AtomicInteger为例，其余差不多。 5.2 AtomicInteger常用方法如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112public class AtomicInteger extends Number implements java.io.Serializable { private static final long serialVersionUID = 6214790243416807050L; //获取指针类Unsafe private static final Unsafe unsafe = Unsafe.getUnsafe(); //内存偏移量 private static final long valueOffset; static { try { //通过objectFieldOffset()方法，获取对象属性的偏移量 valueOffset = unsafe.objectFieldOffset (AtomicInteger.class.getDeclaredField(\"value\")); } catch (Exception ex) { throw new Error(ex); } } //当前的变量值 private volatile int value; public AtomicInteger(int initialValue) { //初始化变量值 value = initialValue; } //value初始化为0 public AtomicInteger() { } //返回当前值 public final int get() { return value; } //设置当前值 public final void set(int newValue) { value = newValue; } //懒设置，使用Unsafe.putOrderedObject方法实现，实现非堵塞的写入，最终会将value置为newValue。 //该方法可能出现其他线程在未来很小的一段时间内无法获取到新值，但可获取到旧值 public final void lazySet(int newValue) { unsafe.putOrderedInt(this, valueOffset, newValue); } //以原子方式设置为给定值并返回旧值。 public final int getAndSet(int newValue) { return unsafe.getAndSetInt(this, valueOffset, newValue); } //以下是getAndSetInt源码，通过while循环重试更新值，直到成功，也是通过CAS实现(JDK8版本) /*public final int getAndSetInt(Object var1, long var2, int var4) { int var5; do { var5 = this.getIntVolatile(var1, var2); } while(!this.compareAndSwapInt(var1, var2, var5, var4)); return var5; }*/ //原子更新value，如果当前值等于expect，则设置为update public final boolean compareAndSet(int expect, int update) { return unsafe.compareAndSwapInt(this, valueOffset, expect, update); } //以原子方式将当前值增加一 //返回旧值，底层同getAndSetInt一样使用CAS操作 public final int getAndIncrement() { return unsafe.getAndAddInt(this, valueOffset, 1); } //以原子方式将当前值减一 //返回旧值，CAS操作 public final int getAndDecrement() { return unsafe.getAndAddInt(this, valueOffset, -1); } //以原子方式将给定值delta添加到当前值 //返回旧值，CAS操作 public final int getAndAdd(int delta) { return unsafe.getAndAddInt(this, valueOffset, delta); } //以原子方式将当前值加1，返回新值 public final int incrementAndGet() { return unsafe.getAndAddInt(this, valueOffset, 1) + 1; } //当前值减1，返回新值 public final int decrementAndGet() { return unsafe.getAndAddInt(this, valueOffset, -1) - 1; } //以原子方式将当前值增加delta，返回新值 public final int addAndGet(int delta) { return unsafe.getAndAddInt(this, valueOffset, delta) + delta; } //使用给定函数的结果以原子方式更新当前值，返回更新后的值。给的函数是无副作用的，因为当尝试更新由于线程之间的争用而失败时，它可能会重新应用 public final int updateAndGet(IntUnaryOperator updateFunction) { int prev, next; do { prev = get(); next = updateFunction.applyAsInt(prev); } while (!compareAndSet(prev, next)); return next; } //同上，使用给定函数的结果以原子方式更新当前值，返回更新前的值。应用该函数时，将当前值作为其第一个参数，并将给定的update作为第二个参数。 public final int getAndAccumulate(int x, IntBinaryOperator accumulatorFunction) { int prev, next; do { prev = get(); next = accumulatorFunction.applyAsInt(prev, x); } while (!compareAndSet(prev, next)); return prev; } //同getAndAccumulate，但返回更新后的值 public final int accumulateAndGet(int x, IntBinaryOperator accumulatorFunction) { int prev, next; do { prev = get(); next = accumulatorFunction.applyAsInt(prev, x); } while (!compareAndSet(prev, next)); return next; }} 使用演示： 123456789101112131415161718192021222324252627public class UseAtomicInt { static AtomicInteger atomicInteger = new AtomicInteger(10); public static void main(String[] args) { //返回旧值10 System.out.println(atomicInteger.getAndIncrement()); //返回新值12 System.out.println(atomicInteger.incrementAndGet()); atomicInteger.compareAndSet(12,1); //加24 返回25 System.out.println(atomicInteger.addAndGet(24)); //自定义函数 IntBinarOperImpl intBinarOper=new IntBinarOperImpl(); //传入自定义函数，传入更新值 atomicInteger.accumulateAndGet(1, intBinarOper); //返回26 System.out.println(atomicInteger.get()); }}//自定义函数，实现IntBinaryOperator接口public class IntBinarOperImpl implements IntBinaryOperator { @Override public int applyAsInt(int left, int right) { //简单定义原来的数加上要更新的数 return left+right; }} 5.3 AtomicIntegerArray是提供原子的方式更新数组里的整型，还包括高级原子操作。常用方法如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384public class AtomicIntegerArray implements java.io.Serializable { private static final long serialVersionUID = 2862133569453604235L; //同上 private static final Unsafe unsafe = Unsafe.getUnsafe(); //获取数组第一个元素的偏移地址 private static final int base = unsafe.arrayBaseOffset(int[].class); //存储移位个数 private static final int shift; //保存的数组 private final int[] array; static { //获取该类型的数组中元素的大小(字节)。 int scale = unsafe.arrayIndexScale(int[].class); //scale如果不是2的次幂则抛出异常 if ((scale &amp; (scale - 1)) != 0) throw new Error(\"data type scale not a power of two\"); //计算得到需要移位的个数，即scale的次幂数 shift = 31 - Integer.numberOfLeadingZeros(scale); } //返回第i个元素的地址 private static long byteOffset(int i) { //shift为偏移位数，base为第一个元素的地址，i移shift个位后+基位置得到第i个元素位置 return ((long) i &lt;&lt; shift) + base; } //先检测i是否越界，再调用byteOffset(i)返回 private long checkedByteOffset(int i) { if (i &lt; 0 || i &gt;= array.length) throw new IndexOutOfBoundsException(\"index \" + i); return byteOffset(i); } //构造初始化给定长度数组 public AtomicIntegerArray(int length) { array = new int[length]; } //创建一个新AtomicIntegerArray，其长度与传入数组相同，并从给定数组中复制所有元素。所以当 AtomicIntegerArray 对内部的数组元素进行修改时，不会影响传入的数组。 public AtomicIntegerArray(int[] array) { this.array = array.clone(); } //返回当前位置的元素 public final int get(int i) { //调用checkedByteOffset获取当前位置的元素地址 return getRaw(checkedByteOffset(i)); } //getIntVolatile方法获取数组中offset偏移地址对应的整型field的值,支持volatile load语义。返回该值。 private int getRaw(long offset) { return unsafe.getIntVolatile(array, offset); } //更新第i个位置的值，也需先计算当前位置的元素的offset public final void set(int i, int newValue) { unsafe.putIntVolatile(array, checkedByteOffset(i), newValue); } //同AtomicInteger的lazySet,这里更新第i个位置的元素 public final void lazySet(int i, int newValue) { unsafe.putOrderedInt(array, checkedByteOffset(i), newValue); } public final int getAndSet(int i, int newValue) { return unsafe.getAndSetInt(array, checkedByteOffset(i), newValue); } //如果当前值等于预期值，则以原子方式将数组位置 i 的元素设置成 update 值。 public final boolean compareAndSet(int i, int expect, int update) { return compareAndSetRaw(checkedByteOffset(i), expect, update); } private boolean compareAndSetRaw(long offset, int expect, int update) { return unsafe.compareAndSwapInt(array, offset, expect, update); } //原子的方式让第i个元素加1 public final int getAndIncrement(int i) { return getAndAdd(i, 1); } //原子的方式让第i个元素减1 public final int getAndDecrement(int i) { return getAndAdd(i, -1); } //原子的方式让第i个元素加delta public final int getAndAdd(int i, int delta) { return unsafe.getAndAddInt(array, checkedByteOffset(i), delta); } //还有其他一些方法都和Integer原子类基本一样 简单使用： 123456789101112131415161718192021public class AtomicArray { static int[] value = new int[] { 1, 2,3 }; static AtomicIntegerArray atomicIntegerArray = new AtomicIntegerArray(value); public static void main(String[] args) { //返回第一个位置的元素 2 System.out.println(atomicIntegerArray.get(1)); //更新第1个位置的元素 atomicIntegerArray.set(1,4); //返回4 System.out.println(atomicIntegerArray.get(1)); //设置第0个位置为3，返回更新前的值 1 System.out.println( atomicIntegerArray.getAndSet(0, 3)); //返回更新后的3 System.out.println(atomicIntegerArray.get(0)); //返回1，原数组不会变化 System.out.println(value[0]); atomicIntegerArray.compareAndSet(0,3,4); System.out.println(atomicIntegerArray.get(0)); }} 5.4 更新引用类型原子更新基本类型的 AtomicInteger，只能更新一个变量，如果要原子更新多个变量，就需要使用这个原子更新引用类型提供的类。Atomic 包提供了以下 3类。AtomicReference，AtomicStampedReference，AtomicMarkableReference 5.5 AtomicReference方法同前面几个类基本一样，但支持泛型，可传入对象,支持对对象的原子操作。 5.6 AtomicStampedReference和AtomicMarkableReferenceAtomicStampedReference 使用版本戳的记录每次改变后的版本号，这样的话就不会存在 ABA问题了。AtomicMarkableReference跟 AtomicStampedReference 基本相同，AtomicStampedReference 在Pair类 中使用 int类型的stamp 作为计数器，每次操作都更新版本，关注的的是动过几次。AtomicMarkableReference 在 Pair类 使用的是 boolean 类型的mark，关注的的是有没有被动过。 AtomicStampedReference源码如下： 首先定义了一个Pair内部类： 1234567891011private static class Pair&lt;T&gt; { final T reference; final int stamp; private Pair(T reference, int stamp) { this.reference = reference; this.stamp = stamp; } static &lt;T&gt; Pair&lt;T&gt; of(T reference, int stamp) { return new Pair&lt;T&gt;(reference, stamp); } } 该类将元素的值(reference)和版本号(stamp)都维护在自己身上。 成员变量 12345678910111213141516171819//声明Pair类型变量private volatile Pair&lt;V&gt; pair;//获取Unsafeprivate static final sun.misc.Unsafe UNSAFE = sun.misc.Unsafe.getUnsafe();//使用unsafe获取偏移量保存到pairOffsetprivate static final long pairOffset = objectFieldOffset(UNSAFE, \"pair\", AtomicStampedReference.class); static long objectFieldOffset(sun.misc.Unsafe UNSAFE, String field, Class&lt;?&gt; klazz) { try { return UNSAFE.objectFieldOffset(klazz.getDeclaredField(field)); } catch (NoSuchFieldException e) { // Convert Exception to corresponding Error NoSuchFieldError error = new NoSuchFieldError(field); error.initCause(e); throw error; //后面两个放在源码的最后，不太好找 构造方法 123public AtomicStampedReference(V initialRef, int initialStamp) { pair = Pair.of(initialRef, initialStamp); } 传入初始值和初值版本戳保存到pair。 方法 4.1. getReference()和getStamp()：返回元素值和返回版本戳 123456public V getReference() { return pair.reference; } public int getStamp() { return pair.stamp; } 4.2 get() 123456//返回当前元素的值，并将当前元素的版本号保存到传入的数组中的第一个位置public V get(int[] stampHolder) { Pair&lt;V&gt; pair = this.pair; stampHolder[0] = pair.stamp; return pair.reference; } 4.3 casPair() 12345//cmp:期望的pair,val：新的pair//CAS更新当前的pairprivate boolean casPair(Pair&lt;V&gt; cmp, Pair&lt;V&gt; val) { return UNSAFE.compareAndSwapObject(this, pairOffset, cmp, val); } 4.4 compareAndSet() 该方法首先判断期望的值和版本戳是否和当前的值和版本戳相同，如果不相同则直接返回false，如果相同则继续比较新的值和版本戳是否和当前值相同，如果相同则直接返回true，否则对当前的pair进行CAS操作。 12345678910111213141516171819/** * 原子的修改元素的值和版本戳 * @param 期望值 * @param 新值 * @param 期望版本戳 * @param 新版本戳 */ public boolean compareAndSet(V expectedReference, V newReference, int expectedStamp, int newStamp) { Pair&lt;V&gt; current = pair; return expectedReference == current.reference &amp;&amp; expectedStamp == current.stamp &amp;&amp; ((newReference == current.reference &amp;&amp; newStamp == current.stamp) || casPair(current, Pair.of(newReference, newStamp))); } 4.5 weakCompareAndSet() 其代码同compareAndSet无差别，但在JDK9中，两个方法都添加了@HotSpotIntrinsicCandidate注解，使用该注解的方法在JVM中都有一套基于CPU指令的高效的实现，且会在运行时会替代JDK的源码实现，从而获得更高的效率。即HotSpot可能会手动实现这个方法。参考：https://blog.csdn.net/lzcaqde/article/details/80868854的解读。 12345678// 同compareAndSet，但可能不能保证原子性public boolean weakCompareAndSet(V expectedReference, V newReference, int expectedStamp, int newStamp) { return compareAndSet(expectedReference, newReference, expectedStamp, newStamp); } 4.6 set() 12345678910/** * 源码解释无条件更新当前元素的值和版本戳 * @param newReference 新值 * @param newStamp 新版本戳 */public void set(V newReference, int newStamp) { Pair&lt;V&gt; current = pair; if (newReference != current.reference || newStamp != current.stamp) this.pair = Pair.of(newReference, newStamp); } 4.7 attemptStamp() 如果引用对象为期望值，则重新设置新的版本戳。 1234567public boolean attemptStamp(V expectedReference, int newStamp) { Pair&lt;V&gt; current = pair; return expectedReference == current.reference &amp;&amp; (newStamp == current.stamp || casPair(current, Pair.of(expectedReference, newStamp))); } 示例： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647public class UseAtomicStampedReference { /** * 设置初始值和初始版本戳 */ static AtomicStampedReference&lt;String&gt; asr = new AtomicStampedReference(\"wml\",0); public static void main(String[] args) throws InterruptedException { //拿到当前的版本号(旧) final int oldStamp = asr.getStamp(); final String oldReference = asr.getReference(); System.out.println(\"旧值：\"+oldReference+\"，旧版本戳：\"+oldStamp); Thread rightStampThread = new Thread(() -&gt; { System.out.println(Thread.currentThread().getName()+\":当前变量值：\" +oldReference + \"，当前版本戳：\" + oldStamp ); //更新引用对象值和版本戳 asr.compareAndSet(oldReference, \"wml222\", oldStamp, oldStamp + 1); int[] stampHolder=new int[2]; stampHolder[0]=0; //调用get，返回当前值，并将版本保存到stampHolder[0]中 asr.get(stampHolder); //打印当前版本 System.out.println(\"使用get()获取版本：\"+stampHolder[0]); }); Thread errorStampThread = new Thread(() -&gt; { String reference = asr.getReference(); System.out.println(Thread.currentThread().getName()+\":当前变量值：\" +reference + \"，当前版本戳：\" + asr.getStamp()); //更新引用对象值和版本戳 asr.compareAndSet(reference, \"wml333\", oldStamp, oldStamp + 1); }); rightStampThread.start(); rightStampThread.join(); errorStampThread.start(); errorStampThread.join(); System.out.println(\"Main线程:当前变量值：\" +asr.getReference() + \"，当前版本戳：\" + asr.getStamp()); asr.set(\"set新值\",3); System.out.println(\"使用set更新:当前变量值：\" +asr.getReference() + \"，当前版本戳：\" + asr.getStamp()); }} 线程errorStampThread没有使用更新后的版本戳作为期望版本，因此该线程CAS失败。 5.7 原子更新字段类atomic包提供了AtomicIntegerFieldUpdater，AtomicLongFieldUpdater，AtomicReferenceFieldUpdater三个类实现原子的更新某个类的某个字段。以AtomicReferenceFieldUpdater为例：更新字段类需要两步：1.由于原子更新字段类都是抽象类，每次必须使用静态方法 newUpdater()创建一个更新器，并且传入要更新的类，字段类型和字段名。2.更新类的字段（属性）必须使用 public volatile修饰符。其他注意点：1.变量不可使用static、final关键字。2.变量的描述符类型必须与调用者一致。否则调用者不能调用变量也就不能通过反射操作保证原子性。 每个更新字段类都是一个抽象类，内部有一个AtomicXXXXFieldUpdaterImpl实现类，相关代码如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485 private static final class AtomicReferenceFieldUpdaterImpl&lt;T,V&gt; extends AtomicReferenceFieldUpdater&lt;T,V&gt; { // 获取Unsafe private static final sun.misc.Unsafe U = sun.misc.Unsafe.getUnsafe(); // 当前变量的内存偏移量 private final long offset; // 如果要操作的类的字段被protected修饰，则cclass为调用者类的class对象，否则cclass为tclass。 private final Class&lt;?&gt; cclass; // 要操作的类的class对象 private final Class&lt;T&gt; tclass; // 要操作的类字段的class对象 private final Class&lt;V&gt; vclass; /** * @param tclass 即上面的tclass * @param vclass 要操作的类字段的class对象 * @param fieldName 被操作的字段名 * @param caller 调用者类的class对象 */ AtomicReferenceFieldUpdaterImpl(final Class&lt;T&gt; tclass, final Class&lt;V&gt; vclass, final String fieldName, final Class&lt;?&gt; caller) { //原子更新的字段 final Field field; //原子更新字段的class对象 final Class&lt;?&gt; fieldClass; //原子更新字段的修饰符 final int modifiers; try { //利用反射机制获取tclass的field field = AccessController.doPrivileged( new PrivilegedExceptionAction&lt;Field&gt;() { public Field run() throws NoSuchFieldException { return tclass.getDeclaredField(fieldName); } }); //获取该字段的修饰符 modifiers = field.getModifiers(); //检查该字段的访问权限，无法访问则抛出对应异常信息 sun.reflect.misc.ReflectUtil.ensureMemberAccess( caller, tclass, null, modifiers); //获取对应class的类加载器 ClassLoader cl = tclass.getClassLoader(); ClassLoader ccl = caller.getClassLoader(); if ((ccl != null) &amp;&amp; (ccl != cl) &amp;&amp; ((cl == null) || !isAncestor(cl, ccl))) { sun.reflect.misc.ReflectUtil.checkPackageAccess(tclass); } fieldClass = field.getType(); } catch (PrivilegedActionException pae) { throw new RuntimeException(pae.getException()); } catch (Exception ex) { throw new RuntimeException(ex); } if (vclass != fieldClass) throw new ClassCastException(); if (vclass.isPrimitive()) throw new IllegalArgumentException(\"Must be reference type\"); if (!Modifier.isVolatile(modifiers)) throw new IllegalArgumentException(\"Must be volatile type\"); //首先判断字段修饰符是否为protected // 再判断tclass和caller是否相同或者是另一个类的子类 this.cclass = (Modifier.isProtected(modifiers) &amp;&amp; tclass.isAssignableFrom(caller) &amp;&amp; !isSamePackage(tclass, caller)) ? caller : tclass; this.tclass = tclass; this.vclass = vclass; this.offset = U.objectFieldOffset(field); } //如果可以在第一个类加载器的委托链中找到第二个类加载器，则返回true private static boolean isAncestor(ClassLoader first, ClassLoader second) { ClassLoader acl = first; do { acl = acl.getParent(); if (second == acl) { return true; } } while (acl != null); return false; } 原子更新类的方法同atomic包下的其他类基本相同，但是该类在进行CAS前，需要先进行类型检查，如下： 123456789101112131415//检查目标参数是否是类的实例。失败时，抛出原因。 private final void accessCheck(T obj) { if (!cclass.isInstance(obj)) throwAccessCheckException(obj);}//检查目标参数是否是对应字段的类型，如果不是则抛出异常private final void valueCheck(V v) { if (v != null &amp;&amp; !(vclass.isInstance(v))) throwCCE(); } public final boolean compareAndSet(T obj, V expect, V update) { accessCheck(obj); valueCheck(update); return U.compareAndSwapObject(obj, offset, expect, update);} 使用示例： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849public class AtomicReferenceFieldUpdaterDemo { /** * 定义AtomicReferenceFieldUpdater，传入要操作的类User，以及原子操作的字段age的class对象Integer.class和字段名age，这里字段必须为引用类型，如果是int类型的则需使用 */ static AtomicReferenceFieldUpdater arf = AtomicReferenceFieldUpdater.newUpdater(User.class, Integer.class, \"age\"); /** * 定义AtomicIntegerFieldUpdater，传入要操作的类User，以及原子操作的字段名grade */ static AtomicIntegerFieldUpdater aif=AtomicIntegerFieldUpdater.newUpdater(User.class,\"grade\"); public static void main(String[] args) throws InterruptedException { User user = new User(); user.age=19; user.grade=0; //CAS修改为20 arf.compareAndSet(user, 19, 20); //输出20 System.out.println(arf.get(user)); //修改为21，返回修改前的 20 System.out.println(arf.getAndSet(user,21)); //修改后为21 System.out.println(user.age); ThreadPoolExecutor poolExecutor = new ThreadPoolExecutor(500, 1000, 0L, TimeUnit.MILLISECONDS, new LinkedBlockingDeque()); //开500个线程增加grade字段 for (int i = 0; i &lt; 500; i++) { poolExecutor.execute(()-&gt;{ aif.incrementAndGet(user); }); } poolExecutor.shutdown(); Thread.sleep(2000L); System.out.println(\"增加后的grade为:\"+aif.get(user)); aif.compareAndSet(user,500,1000); System.out.println(\"修改后的grade为\"+aif.get(user)); }}class User { protected volatile Integer age; protected volatile int grade;} 结果： 12345202021增加后的grade为:500修改后的grade为1000 参考：https://zhuanlan.zhihu.com/p/65240318","link":"/posts/20200130-atomicClass.html"},{"title":"java并发编程之显示锁Lock、Condition接口、LockSupport以及AQS（同步队列、条件等待队列）详解","text":"一、显式锁synchronized关键字是java内置的语言特性，使用synchronized关键字会隐式的获取锁，在获取锁的线程执行执行完任务或是执行过程中发生异常时会自动释放锁。但为什么还需要Lock呢？ 如，目前绝大多数的业务场景基本都是读多写少，如读写比例为10:1，倘若使用synchronized，若有一个线程在读，则因为其的独占性，其他的线程都只能等待，造成大量的资源浪费，但Lock的实现类ReentrantReadWriteLock读写锁便可以完美的解决这一问题。 又如，synchronized无法设置超时时间，而如果获取该锁的线程因为I/O请求或是其他原因导致一直无法释放锁，则其他线程便会进入“无限等待”的状态，而Lock获取锁时可设置超时时间，如果在截止时间之后仍未获取到锁，则返回。 但个人认为如果不使用lock.trylock或者lockInterruptbly()中断获取锁的线程等，尽量使用synchronized关键字，synchronized因为是一个语言特性，而Lock是一个类，使用就需要创建对象实例必然会比synchronized有所消耗，jdk对synchronized也进行了许多优化。 二、Lock先看lock的标准用法： 123456789101112private Lock lock = new ReentrantLock();private int num= 1; .............public void test() { lock.lock(); //如果中间抛了个异常，unlock就不会执行，因此释放锁必须放在finally中 try{ age++; }finally { lock.unlock(); }} 这里不能将获取锁放在try中，因为如果放在try中，当获取锁时发生了异常，必然会执行unlock()释放锁，而问题是当前并没有获取到锁，又必然会导致程序异常。 Lock的常用方法如下： lock() 获取锁，调用该方法的线程会获取到锁，如果获取到锁，从该方法返回，否则会进行等待。 void lockInterruptibly() throws InterruptedException;该方法支持中断的获取锁。即在获取锁时，如果锁已被其他线程获取，则当前线程只能进入阻塞等待状态，但 是可以调用该线程的interrupt()方法中断当前线程的等待状态，停止获取锁。 boolean tryLock() 该方法实现非阻塞的获取锁，即调用该方法会立即返回，如果获取到，则返回true，如果未获取到则返回false官方给出的范例如下： 12345678910Lock lock = ...; if (lock.tryLock()) { try { //如果获取到锁就处理相关任务 } finally { lock.unlock(); } } else { //未获取到执行其他任务 }} boolean tryLock(long time, TimeUnit unit) throws InterruptedException;同3一样，但增加了超时时间。当：（1）当前线程在超时时间内获取到锁，则直接返回true（2）当前线程在超时时间内被中断，则抛出中断异常（3）当前线程在超时时间内未获取到锁，返回false void unlock();释放锁。 Condition newCondition(); 返回一个Condition实例，该实例与调用其的的锁绑定，调用后，可使用condition的`await()`、`signal()`等方法对调用该方法的线程进行等待和唤醒，一个Lock对象可以使用多个`Condition`三、Conditionsynchronized关键字可通过wait()、notify()实现等待-通知的模式，而Lock也可以实现，但是其是借助Condition接口实现的，通过Lock.newCondition()就可以看出。与synchronized不同的是，一个Lock对象可以创建多个Condition实例，因此，每个Condition实例可以维护单独的线程，在调用condition.await()和signal()时，只会控制注册在该condition实例上的线程，signalAll()也不会像synchronized调用notifyAll()一样通知所有阻塞等待的线程，只是唤醒所有注册在该实例的线程。Condition的常用方法： void await() throws InterruptedException;与此Condition关联的锁会被原子释放，并且出于线程调度的目的，当前线程被禁用，进入等待状态，直到发生以下四种情况之一：1.其他一些线程调用此Condition的signal()或signalAll()方法，而当前线程恰好被选择为要唤醒的线程2.其他线程调用interrupt() 方法中断当前线程3.发生虚假唤醒如果 当前线程被唤醒，从await()方法返回，则意味着当前线程已经获取了该Condition对象绑定的锁。 void awaitUninterruptibly(); 同await()一样，但是不响应中断。即如果当前线程进入此方法时已设置其中断状态，或者在等待时其他线程调用`interrupt()` 方法，它仍继续等待直到收到signal()或signalAll()。当它最终从该方法返回时，其中断状态仍将被设置。 long awaitNanos(long nanosTimeout) throws InterruptedException; 当前线程进入等待状态直到被通知、中断或超出超时时间。 此方法返回剩余时间。因此如果返回小于等于0的数，说明已经超时。 boolean await(long time, TimeUnit unit) throws InterruptedException;同上，但如果超时返回false，否则返回true boolean awaitUntil(Date deadline) throws InterruptedException; 当前线程进入等待状态直到被通知、中断或超出截止时间。超时返回false，否则返回true。 void signal();唤醒一个等待队列中等待时间最长的线程。如果有线程在该Condition下等待，则选择一个线程唤醒。该线程从await()返回前，必须重新获取Conditon绑定的锁。 void signalAll(); 唤醒所有在该Condition上等待的线程。同样需要先获取绑定的锁。 Condition简单使用： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134package com.wml.test4.conditon;/** * @author Wang * @date 2020/2/117:27 */public class ConditionDemo { private static Delivery delivery = new Delivery(\"wml\", \"南京路1号\", \"德基广场三层\", 1000); public static void main(String[] args) throws InterruptedException { for (int i = 0; i &lt; 3; i++) { new Thread(() -&gt; { delivery.sms300(); }, \"distance\").start(); } for (int i = 0; i &lt; 3; i++) { new Thread(() -&gt; { delivery.smsArrived(); }, \"address\").start(); } System.out.println(\"配送中\"); Thread.sleep(3000L); delivery.arive300(); Thread.sleep(1000L); delivery.completeDelivery(); }}//配送类class Delivery { private Lock lock = new ReentrantLock(); //使用lock创建一个用于实现距离的等待通知的condition private Condition distConditon = lock.newCondition(); //使用lock创建一个用于实现地点的等待通知的condition private Condition addrCondition = lock.newCondition(); /** * 收餐人 */ private String recipient; /** * 配送地址 */ private String address; /** * 当前位置 */ private String currentAddress; /** * 距离 */ private int distance; public Delivery(String recipient, String address, String currentAddress, int distance) { this.recipient = recipient; this.address = address; this.currentAddress = currentAddress; this.distance = distance; } /** * 距离送餐地点还有300米，通知订餐人到指定地点取餐 */ public void arive300() { lock.lock(); try { this.distance = 300; //发送通知，唤醒等待线程 distConditon.signal(); } finally { lock.unlock(); } } /** * 完成配送，更新距离和位置，唤醒线程发送相关通知 */ public void completeDelivery() { lock.lock(); try { this.distance = 0; this.currentAddress = this.address; //唤醒当前condition实例的等待线程 addrCondition.signal(); } finally { lock.unlock(); } } /** * 到达300米处发送通知 */ public void sms300() { lock.lock(); try { while (this.distance &gt; 300) { try { distConditon.await(); System.out.println(\"到达300米处，distConditon执行signal唤醒了\" + Thread.currentThread().getName() + \"线程\"); } catch (InterruptedException e) { e.printStackTrace(); } } } finally { lock.unlock(); } System.out.println(\"亲爱的\" + this.recipient + \"先生/女士，您的外卖还有300米送达\"); } //订餐送达目的地 public void smsArrived() { lock.lock(); try { try { while (!this.currentAddress.equals(this.address)) { //指定超时时间 addrCondition.await(); System.out.println(\"addressCOndition的\" + Thread.currentThread().getName() + \"线程被唤醒\"); System.out.println(\"订餐已送至目的地:\" + this.address); } } catch (InterruptedException e) { e.printStackTrace(); } } finally { lock.unlock(); } System.out.println(\"完成配送\"); }} 结果： 123456配送中到达300米处，distConditon执行signal唤醒了distance线程亲爱的wml先生/女士，您的外卖还有300米送达addressCOndition的address线程被唤醒订餐已送至目的地:南京路1号完成配送 该例子使用Lock对象创建了一个距离condition和地址condition，外派配送至距离送餐点300米和送达到指定地点时都需要发送通知，发送通知需要分别调用距离和地址condition的await()方法等待，当到达300米和指定地点时再分别调用对应的condition.signal()唤醒一个等待中的线程。 四、LockSupport在将Lock的实现类前，需要先将AQS，但是了解AQS又需要先了解LockSupport。LockSupport 定义了一组以 park 开头的方法用来阻塞当前线程，以及unpark(Thread thread)方法来唤醒一个被阻塞的线程。 LockSupport类无法被实例化（从以下源码可看出，只有一个私有的构造函数）且所有方法都是静态的，这些方法提供了最基本的线程阻塞和唤醒功能。 123public class LockSupport { private LockSupport() {} } 再来看看LockSupport的成员变量： 123456private static final sun.misc.Unsafe UNSAFE;//挂起线程对象的偏移地址,对应Thread类的parkBlocker字段private static final long parkBlockerOffset;private static final long SEED;private static final long PROBE;private static final long SECONDARY; 对应的赋值在静态代码块中: 1234567891011121314static { try { UNSAFE = sun.misc.Unsafe.getUnsafe(); Class&lt;?&gt; tk = Thread.class; parkBlockerOffset = UNSAFE.objectFieldOffset (tk.getDeclaredField(\"parkBlocker\")); SEED = UNSAFE.objectFieldOffset (tk.getDeclaredField(\"threadLocalRandomSeed\")); PROBE = UNSAFE.objectFieldOffset (tk.getDeclaredField(\"threadLocalRandomProbe\")); SECONDARY = UNSAFE.objectFieldOffset (tk.getDeclaredField(\"threadLocalRandomSecondarySeed\")); } catch (Exception ex) { throw new Error(ex); } } 可以看到都是先获取Thread类下的对应的字段，如parkBlocker，然后通过UNFAFE的objectFieldOffset()方法获取对应字段的偏移量（某字段在其类中的内存偏移量是始终相同的） 再来看看LockSupport的静态方法： 说在前面：LockSupport的park()和unpark()底层在维护一个许可证，park相当于消费者，unpark相当于生产者（生产一个许可证），park在没被中断或其他原因导致停止等待的情况下，必须消费一个许可证才可以继续执行 1.park相关方法: 123public static void park() { UNSAFE.park(false, 0L); } 其底层调用的UNSAFE.park(boolean isAbsolute, long time)方法，其底层原理解析可参考此文章：https://juejin.im/post/5bdc1142e51d45052c6fede7#heading-1，简单的讲，就是其底层维护了一个volatile int _counter变量，该变量就相当于许可证，park()方法就是将其从1改为0消费掉。其会首先尝试获取许可，如果没有获取到，如果获取到则说明有线程调用unpark()释放了一个许可，再进行以下情况的判断： 当前线程被中断，直接返回 当前线程到期，直接返回，具体可分为（以下情况发生中断或出现未知原因也都会返回）:a.`isAbsolute`为true，如果`time`小于等于0，直接返回；如果大于0，进行粗精度超时计算，超时时间内未获取到许可则返回 b.`isAbsolute`为false，`time`为0L，不进行超时计算，一直等待unpark释放许可 c..`isAbsolute`为false，`time`大于0，进行细精度超时计算，如果在time时间内仍未获取到许可，则直接返回 超时相关方法： 1234567public static void parkUntil(long deadline) { UNSAFE.park(true, deadline);}public static void parkNanos(long nanos) { if (nanos &gt; 0) UNSAFE.park(false, nanos);} 2. 带有blocker的park相关方法: 123456public static void park(Object blocker) { Thread t = Thread.currentThread(); setBlocker(t, blocker); UNSAFE.park(false, 0L); setBlocker(t, null); } 该方法也是用于阻塞当前线程，其中blocker是用来标识当前线程在等待的对象（阻塞对象），用于问题的排查和系统监控。 setBlocker()方法如下： 123private static void setBlocker(Thread t, Object arg) { UNSAFE.putObject(t, parkBlockerOffset, arg); } 可以看到，该方法调用了UNSAFE.putObject()方法，实现将传入的blocker，（这里是arg），赋值给当前线程的parkBlocker对应偏移量下的数据。回过头看park(Object blocker) 方法，其在调用UNSAFE.park()前设置了blocker，在被唤醒后又调用了setBlocker将对应位置的blocker清空。因此当前线程在阻塞前，我们仍可以获取到当前的blocker。获取Blocker方法如下： 12345public static Object getBlocker(Thread t) { if (t == null) throw new NullPointerException(); return UNSAFE.getObjectVolatile(t, parkBlockerOffset); } 带blocker的超时的park()方法如下： 1234567891011121314public static void parkNanos(Object blocker, long nanos) { if (nanos &gt; 0) { Thread t = Thread.currentThread(); setBlocker(t, blocker); UNSAFE.park(false, nanos); setBlocker(t, null); } }public static void parkUntil(Object blocker, long deadline) { Thread t = Thread.currentThread(); setBlocker(t, blocker); UNSAFE.park(true, deadline); setBlocker(t, null); } 3.unpark相关方法: 1234public static void unpark(Thread thread) { if (thread != null) UNSAFE.unpark(thread); } 唤醒一个被阻塞的线程。底层就是将_counter变量设为1，如果_counter本来是0，则会唤醒在等待的线程。unpark可以在park之前使用，这样调用park时发现_counter为1，则可以直接消费使用；unpark()可以调用多次，但_counter值最多为1，不会累加，因此连续调用两次park()只有第一次调用时可以继续执行，第二次就会等待。 下面写一个小例子验证上面的说法： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273public class LockSupportDemo { /** * 测试blocker在对应线程被唤醒后清空 */ public static void testBlocker(){ Thread threadA = new Thread(()-&gt;{ System.out.println(\"ThreadA被阻塞前\"); LockSupport.park(\"threadA_Blocker\"); try { Thread.sleep(1000L); } catch (InterruptedException e) { e.printStackTrace(); } }); threadA.start(); new Thread(()-&gt;{ try { Thread.sleep(2000L); } catch (InterruptedException e) { e.printStackTrace(); } String blocker = (String) LockSupport.getBlocker(threadA); System.out.println(\"线程A即将被唤醒\"); System.out.println(\"获取到线程A的blocker:\"+blocker); //释放线程A LockSupport.unpark(threadA); System.out.println(\"线程A被唤醒了\"); System.out.println(\"再次获取线程A的blocker\"); String blocker2=(String)LockSupport.getBlocker(threadA); System.out.println(\"获取到线程A的blocker:\"+blocker2); }).start(); } public static void main(String[] args) throws InterruptedException { //testBlocker(); Thread thread = new Thread(() -&gt; { unparkFirst(); }); thread.start(); new Thread(()-&gt;{ try { Thread.sleep(2000L); } catch (InterruptedException e) { e.printStackTrace(); } System.out.println(\"第三次执行unpark\"); LockSupport.unpark(thread); }).start(); } /** * 测试先执行unpark，再park可继续执行，但是执行两次unpark，也只能执行一次park，第二次park被阻塞 */ public static Thread unparkFirst(){ Thread curThread = Thread.currentThread(); LockSupport.unpark(curThread); LockSupport.unpark(curThread); System.out.println(\"执行两次unpark后\"); LockSupport.park(); System.out.println(\"第一次执行park后\"); LockSupport.park(); System.out.println(\"第二次执行park后\"); return curThread; }} 执行testBlocker()结果： 123456ThreadA被阻塞前线程A即将被唤醒获取到线程A的blocker:threadA_Blocker线程A被唤醒了再次获取线程A的blocker获取到线程A的blocker:null 发现在线程A被唤醒后，对应的blocker为空执行unparkFirst()结果： 1234执行两次unpark后第一次执行park后第三次执行unpark第二次执行park后 发现第二次执行park后，线程被阻塞等待，只有再次执行unpark后，后面的代码才能继续执行，因此park和unpark应成对出现，否则线程会一直等待下去。 五、AQS讲完了LockerSupport，接下来就可以讲解AQS了。 5.1 CLH队列锁CLH 队列锁是一种基于链表的可扩展、高性能、公平的自旋锁，申请线程仅仅在本地变量上自旋，它不断轮询前驱的状态，假设发现前驱释放了锁就结束自旋，获取对应的锁。 CLH队列锁由一个前驱节点pre，一个当前节点curNode，一个tail尾节点和一个locked位构成 5.1.1 获取锁若当前线程A需要获取锁，则线程A创建一个新的QNode，先将其locked位设为true，表示需要获取锁，在调用tail.getAndSet(curNode)，CAS的方式将自己设为尾部（这样后面再有需要获取锁的就必须在线程A后排队），同时该方法返回原来的尾节点，让自己的前驱节点指向原尾节点（即指向前一个线程的node节点，如果是第一个获取锁的线程，则pre指向null，因为tail初始化为null），最后循环访问原尾节点的locked位，当其为false时，停止循环，即停止自旋，获得到锁。示意图如下：这样只要前面的线程使用锁结束，locked位变为false，后面排队的线程就可以获取到锁。 5.1.2 释放锁释放锁比较简单，直接将当前节点的locked位设为false，然后让当前节点设为前驱节点，代表出队。简单实现： 123456789101112131415161718192021222324252627282930313233/** * @author Wang * @date 2020/2/216:19 */public class CLH { private final AtomicReference&lt;QNode&gt; tail= new AtomicReference&lt;&gt;(new QNode());; private final ThreadLocal&lt;QNode&gt; pre; private final ThreadLocal&lt;QNode&gt; curNode; private static class QNode { volatile boolean locked = false; } public CLH() { curNode = ThreadLocal.withInitial(() -&gt; new QNode()); pre = ThreadLocal.withInitial(() -&gt; null); } public void lock() { QNode node = curNode.get(); node.locked = true; QNode pred = tail.getAndSet(node); pre.set(pred); while (pred.locked) {} } public void unlock() { QNode qnode = curNode.get(); qnode.locked = false; curNode.set(pre.get()); }} 5.2 AQS AQS即队列同步器，是用来构建锁和其他同步组件的基础框架，如即将要将的Lock的几个实现类，ReentrantLock、ReentrantReadWriteLock以及前面文章提到的CountDownLatch、Semaphore等都是基于AQS框架实现的，当然我们也可以借助AQS实现自己的同步器。使用方式：子类通过继承AQS，实现AQS提供的抽象方法来管理同步状态，在AQS中维护了一个int类型的state代表该状态，并提供了getState()、setState(int newState)和 compareAndSetState(int expect,int update)等方法实现对共享资源state的获取和释放；而该子类推荐使用静态内部类的方式实现，AQS只是定义了若干同步状态获取和释放的方法提供自定义同步组件使用，其支持独占式和共享式两种方式获取同步状态。同步器面向的是锁的实现者，它简化了锁的实现方式，屏蔽了同步状态管理、线程的排队、等待与唤醒等底层操作。锁和同步器很好地隔离了使用者和实现者所需关注的领域。实现者需要继承同步器并重写指定的方法，随后将同步器组合在自定义同步组件的实现中，并调用同步器提供的模板方法，而这些模板方法将会调用使用者重写的方法。 模板方法AQS的设计是基于模板方法模式的。那么什么是模板方法呢？简单的说就是在方法中只定义了该方法的骨架，但是具体的实现步骤放在了其子类中。如Spring中的各种各样的Template模板。如还不懂什么是模板方法，请看以下例子： 1.定义一个改卷子的抽象类： 12345678910111213141516171819202122232425262728293031public abstract class AbstractMarking { //改卷子 protected abstract void check(); //计算总分 protected abstract void compute(); //划分等第 protected abstract void rank(); /** * 批卷的模板方法 * 提供了以上三个抽象方法，具体实现在子类 */ public final void marking(){ check(); compute(); if (shouldRank()){ rank(); } } /** * 是否要打等级(有的科目根据分数要划分等级，有的则按分数评) * @return */ protected boolean shouldRank(){ return false; }} 2.分别定义数学、英语和实训类实现改卷子的抽象类 1234567891011121314151617181920212223242526272829303132333435363738public class English extends AbstractMarking { @Override protected void check() { System.out.println(\"改英语卷子\"); } @Override protected void compute() { System.out.println(\"计算英语分数\"); } @Override protected void rank() { System.out.println(\"不需打英语\"); }}public class Practical extends AbstractMarking { @Override protected void check() { System.out.println(\"改实训成果\"); } @Override protected void compute() { System.out.println(\"计算实训分数\"); } @Override protected void rank() { System.out.println(\"打实训等级\"); } @Override protected boolean shouldRank() { return true; }} 调用： 12345678910public class Main { public static void main(String[] args) { AbstractMarking englishMarking=new English(); englishMarking.marking(); AbstractMarking mathMarking=new Math(); mathMarking.marking(); AbstractMarking pracMarking=new Practical(); pracMarking.marking(); }} 结果： 1234567改英语卷子计算英语分数改高数卷子计算高数分数改实训成果计算实训分数打实训等级 AQS中的模板方法：实现自定义同步组件时，将会调用同步器提供的模板方法。 独占模式： void acquire(int arg)独占式获取同步状态，如果当前线程获取同步状态成功，则由该方法返回，否则进入同步队列等待，该方法会调用重写的tryAcquire(int arg)方法 void acquireInterruptibly(int arg)同上，但相应中断，当前线程未获取到同步状态而进入同步队列，但如果当前线程被中断，则该方法会抛出InterruptedException异常并返回。 boolean tryAcquireNanos(int arg, long nanosTimeout)同2，但增加了超时时间，如果当前线程在超时时间内未获得到同步状态，则返回false，反之返回true protected boolean tryAcquire(int arg)以及tryRelease(int arg) （可重写）tryAcquire独占式获取同步状态，实现该方法需要查询当前状态并判断同步转阿根廷是否符合预期，然后再进行CAS设置同步状态。获取成功返回true，反之返回false。tryRelease度展示释放同步状态，等待获取同步状态的线程将有机会获取同步状态 boolean release(int arg)独占式地释放同步状态，该方法会在释放同步状态后，将同步队列中第一个节点包含的线程唤醒。 共享模式：提供了与独占模式对应的带有Shared的共享式相关的方法。以void acquireShared(int arg)为例，共享式的获取同步状态，如果未获取到，则将当前线程加入同步队列等待，与独占式不同的是该方法允许同一时刻多个线程获取到同步状态。 AQS中的节点和同步队列数据结构在介绍CLH锁时候已经提到了，AQS是基于CLH的变种实现，对应的就是静态内部类Node，定义如下： 先看Node的两个等待模式和几个状态： 1234567891011121314151617static final class Node { //标明线程以共享模式等待锁，如读锁ReadLock static final Node SHARED = new Node(); //标明线程以独占模式等待锁，如可重入锁ReetrantLock(即一把锁一次只能由一个线程持有，而共享锁允许一把锁一次被多个线程持有) static final Node EXCLUSIVE = null; /** *以下几个是线程在队列中的状态 */ // 表示线程获取锁的请求已经 取消 static final int CANCELLED = 1; // 后驱节点入队等待后会更新前驱节点的状态为SIGNAL，等待前驱节点释放同步状态，前驱节点释放后会唤醒后驱节点 static final int SIGNAL = -1; //表示节点在等待队列中，当其他线程调用的condition.signal()后，CONDITION static final int CONDITION = -2; //在共享模式下，前驱节点在唤醒后驱节点的同时，也会无条件的唤醒后驱节点的后驱节点，一直传递下去 static final int PROPAGATE = -3; 除此之外。还有一个值为0的状态，代表初始化Node对象的默认值。从以上变量可看出，当值为负的时候，表示结点等待状态有效，而正值表示结点已被取消。因此可通过判断状态的值是否小于0来判定其是否正常。 成员变量： 1234567891011//线程在队列中的等待状态， 值为以上几个volatile int waitStatus;//当前节点的前驱节点volatile Node prev;//当前节点的后驱节点volatile Node next;//当前节点对应的线程volatile Thread thread;//Node作为同步队列节点时，nextWaiter有两个值：EXCLUSIVE、SHARED标识当前节点是独占模式还是共享模式//Node作为等待队列节点时，nextWaiter表示当前节点的后驱节点。Node nextWaiter; 另外，AQS还提供了头节点和尾节点的引用。 12private transient volatile Node head;private transient volatile Node tail; 但这里的head节点不保存线程信息。如下： 12345private void setHead(Node node) { head = node; node.thread = null; node.prev = null; } head节点是获取同步状态成功的节点，head节点的线程在释放同步状态时，会唤醒其后驱节点，而后驱节点将会在获取同步状态成功时将自己设置为head节点。设置首节点每次都是通过获取同步状态成功的那个线程实现的，因为一次只有一个线程能够成功获取到同步状态，所以设置头节点的方法并不需要使用 CAS ，只需要将头节点设置成为原头节点的后驱节点并断开与原头节点的连接。 独占式同步状态的获取和释放1.获取12345public final void acquire(int arg) { if (!tryAcquire(arg) &amp;&amp; acquireQueued(addWaiter(Node.EXCLUSIVE), arg)) selfInterrupt(); } 1.首先调用自定义同步器实现的 tryAcquire(int arg)方法，该方法需要保证线程安全的获取同步状态，若成功，则返回true，该方法直接返回，若失败，则返回false，继续执行后面的代码。2.如果同步状态获取失败，则构造同步节点并通过addWaiter(Node node)方法将该节点加入到同步队列的尾部。代码如下： 12345678910111213141516171819202122232425Node(Thread thread, Node mode) { this.nextWaiter = mode; this.thread = thread;}private Node addWaiter(Node mode) { //通过当前线程和mode（Node.EXCLUSIVE）构造一个Node节点，在上面的构造方法中可看出mode被赋值给nextWaiter，也印证了上面成员变量中对nextWaiter的解释 Node node = new Node(Thread.currentThread(), mode); //获取原来的尾节点 Node pred = tail; if (pred != null) { //尾节点不为空，让当前节点的前驱指向tail node.prev = pred; //通过CAS更新尾节点 if (compareAndSetTail(pred, node)) { //CAS成功，原tail节点的后驱指向当前节点，实现双向链表 pred.next = node; //返回当前节点 return node; } } //如果尾节点为空或CAS失败，则调用enq(node)将当前节点入队，返回node enq(node); return node; } 入队操作如下：通过一个死循环，不停的CAS设置尾节点 123456789101112131415161718private Node enq(final Node node) { for (;;) { Node t = tail; if (t == null) { //尾节点为空，初始化队列，构建一个新的头节点，并让尾节点等于头接地那 if (compareAndSetHead(new Node())) tail = head; } else { //尾节点不为空 node.prev = t; //CAS设置尾节点 if (compareAndSetTail(t, node)) { t.next = node; return t; } } } } 即入队时，如果当前线程是第一个加入同步队列，则通过compareAndSetHead(new Node())初始化队列头 否则，进行自旋不断CAS将节点插入尾节点 3.最后调用 acquireQueued(Node node,int arg)方法，使得该节点以“死循环”的方式获取同步状态。如果获取不到则阻塞节点中的线程，则只能等待前驱节点出队或阻塞线程被中断才能唤醒阻塞线程。 123456789101112131415161718192021222324252627final boolean acquireQueued(final Node node, int arg) { boolean failed = true; try { boolean interrupted = false; for (;;) { //获取前驱节点 final Node p = node.predecessor(); //只有前驱节点是头节点才可以tryAcquire if (p == head &amp;&amp; tryAcquire(arg)) { //如果获取同步状态成功，则将头节点换为当前节点 setHead(node); p.next = null; // help GC failed = false; //返回中断状态，此时不需要中断 return interrupted; } //前驱节点非头节点或获取同步状态失败 if (shouldParkAfterFailedAcquire(p, node) //判断获取同步状态失败后是否需要阻塞 &amp;&amp; parkAndCheckInterrupt())//如果需要阻塞， interrupted = true;//置中断标志为true } } finally { //如果获取失败，则将当前节点取消 if (failed) cancelAcquire(node); } } shouldParkAfterFailedAcquire如下： 12345678910111213141516171819private static boolean shouldParkAfterFailedAcquire(Node pred, Node node) { //获取前驱节点的状态 int ws = pred.waitStatus; //如果前驱节点是SIGNAL(前驱节点释放锁后会通知后驱节点)，则当前节点可以进行安全等待 if (ws == Node.SIGNAL) return true; //ws大于0即处于CANCEL状态 if (ws &gt; 0) { //循环将当前节点与前驱节点为非CANCEL状态的节点连接，即循环遍历找到有效状态节点 do { node.prev = pred = pred.prev; } while (pred.waitStatus &gt; 0); pred.next = node; } else { //处于其他状态时，将前驱节点的状态更新尾SIGNAL，然后返回false，会在acquireQueued中继续下一个循环，直到前驱节点状态为SIGNAL才会继续执行下一个方法 compareAndSetWaitStatus(pred, ws, Node.SIGNAL); } return false; } 可见，该方法只有在前驱节点状态为SIGNAL时才会返回true，可以进行安全等待。接着会调用parkAndCheckInterrupt()，阻塞当前线程，并返回中断状态 1234private final boolean parkAndCheckInterrupt() { LockSupport.park(this); return Thread.interrupted(); } 流程总结：1.调用tryAcquire尝试获取同步状态，如果获取成功则返回，否则进入 22.调用addWaiter将当前线程构造一个新节点加入同步等待队列，如果队列未初始化则先初始化，否则直接将新节点加入队尾3.接着调用acquireQueued让加入队列的节点开始自旋，只有该节点的前驱节点为head时才可以尝试获取状态（这里一是因为头节点是成功获取到同步状态的节点，头节点释放同步状态会唤醒后驱节点，所以要加此判断，二是因为队列的FIFO），否则跳过处于CANCEL状态的节点，并将前驱节点更新为SIGNAL，只有前驱节点状态为SIGNAL时，该节点才可以进行park等待，返回中断状态4. 如果被中断，则调用selfInterrupt()中断当前线程 2.释放释放同步状态通过release方法，释放后会唤醒后驱节点，让后驱节点重新尝试获取同步状态 12345678910public final boolean release(int arg) { if (tryRelease(arg)) {///调用模板方法释放同步状态，成功返回true，失败返回false 具体实现在子类 Node h = head; //头节点不为空且状态非0时唤醒后驱节点 if (h != null &amp;&amp; h.waitStatus != 0) unparkSuccessor(h); return true; } return false; } unparkSuccessor如下： 12345678910111213141516171819202122private void unparkSuccessor(Node node) { //获取头节点（要释放同步状态的节点）的状态 int ws = node.waitStatus; if (ws &lt; 0) //将状态改为0 compareAndSetWaitStatus(node, ws, 0); //获取后驱节点 Node s = node.next; //如果后驱节点为空或已经被取消 if (s == null || s.waitStatus &gt; 0) { //重新置为null s = null; //从尾部循环获取处于等待状态的节点作为后驱接地那 for (Node t = tail; t != null &amp;&amp; t != node; t = t.prev) if (t.waitStatus &lt;= 0) s = t; } if (s != null) //后驱节点非空时，唤醒该节点 LockSupport.unpark(s.thread); } 那么有一个问题，为什么要从尾部遍历呢？从Node类的源码给出如下解释：首先看一下之前讲的addWaiter 12345678910111213private Node addWaiter(Node mode) { Node node = new Node(Thread.currentThread(), mode); Node pred = tail; if (pred != null) { node.prev = pred; if (compareAndSetTail(pred, node)) { pred.next = node; return node; } } enq(node); return node; } 在插入到尾节点时，先执行的是node.prev=pred，将当前节点与前驱节点连接，然后compareAndSetTail(pred, node)原子更新尾节点后才执行pred.next = node;将前驱节点的next引用与新的尾节点连接起来，如果在该操作执行前调用了unparkSuccessor就无法从前往后完全遍历 共享模式同步状态的获取和释放获取以共享模式获取同步状态，忽略中断 12345public final void acquireShared(int arg) { if (tryAcquireShared(arg) &lt; 0) doAcquireShared(arg); } tryAcquireShared(int arg)模板方法返回值为 int 类型，当返回值大于等于 0 时，表示能够获取到同步状态。可以简单看一下Semphore中非公平锁对该方法的实现： 12345678910111213141516protected int tryAcquireShared(int acquires) { return nonfairTryAcquireShared(acquires); }final int nonfairTryAcquireShared(int acquires) { //通过一个死循环获取同步状态 for (;;) { //获取当前同步状态，这里表示当前可用许可数 int available = getState(); //减去本次申请许可数acquires，得到申请成功后的剩余许可数remaining int remaining = available - acquires; if (remaining &lt; 0 || //如果remaining小于0，则本次申请没有获取成功，直接返回，后续加入等待队列 //如果remaining&gt;0，则CAS地重新设置状态，更新尾remaining，返回remaining compareAndSetState(available, remaining)) return remaining; } } 回到acquireShared()，如果获取同步失败，则执行doAcquireShared()进入同步队列等待，自旋获取 1234567891011121314151617181920212223242526272829303132333435private void doAcquireShared(int arg) { //构造一个共享模式的节点加入到同步队列尾部 final Node node = addWaiter(Node.SHARED); //获取成功否 boolean failed = true; try { //是否被中断 boolean interrupted = false; for (;;) { //获取前驱节点 final Node p = node.predecessor(); if (p == head) { //只有前驱节点是head节点时才可以尝试获取同步状态，原因前面已讲过 int r = tryAcquireShared(arg); //返回值大于0代表获取成功 if (r &gt;= 0) { //将当前节点设为头节点，并且如果还有剩余资源，则继续传播唤醒后驱节点中属于共享模式的节点 setHeadAndPropagate(node, r); p.next = null; // help GC if (interrupted) selfInterrupt(); failed = false; return; } } //获取失败，则判断当前节点是否应该阻塞，如果应该阻塞，则将其阻塞并检查中断 if (shouldParkAfterFailedAcquire(p, node) &amp;&amp; parkAndCheckInterrupt()) interrupted = true; } } finally { if (failed) cancelAcquire(node); } } 总体逻辑和独占式的相同，但因是共享式的，所有在获取了同步状态后需要继续唤醒后驱节点，无条件传播下去。接下来看setHeadAndPropagate的实现： 12345678910111213private void setHeadAndPropagate(Node node, int propagate) { //获取旧的头节点后面会用到 Node h = head; //将当前节点设为新的头节点 setHead(node); //propagate &gt; 0 代表还有剩余同步状态 if (propagate &gt; 0 || h == null || h.waitStatus &lt; 0 || (h = head) == null || h.waitStatus &lt; 0) { Node s = node.next; if (s == null || s.isShared()) doReleaseShared(); } } 关于为什么不只用propagate &gt; 0 来判断，以及PROPAGATE的意义，另一个博主的这篇文章做了很详细的解释：https://www.cnblogs.com/micrari/p/6937995.html 释放：1234567public final boolean releaseShared(int arg) { if (tryReleaseShared(arg)) {//尝试释放同步状态 doReleaseShared(); return true; } return false; } doReleaseShared() 如下：共享模式下，可能会有多个线程释放同步状态 1234567891011121314151617181920212223private void doReleaseShared() { for (;;) { Node h = head; //头节点非空且不等于尾节点 if (h != null &amp;&amp; h != tail) { //获取头节点状态 int ws = h.waitStatus; //如果状态为SIGNAL，则CAS将其状态改为0，如果CAS失败，则一直循环，如果成功则唤醒后驱节点 if (ws == Node.SIGNAL) { if (!compareAndSetWaitStatus(h, Node.SIGNAL, 0)) continue; unparkSuccessor(h); } else if (ws == 0 &amp;&amp; //如果状态为0，则改为PROPAGATE，以确保释放后继续传播 !compareAndSetWaitStatus(h, 0, Node.PROPAGATE)) continue; // loop on failed CAS } //这里，如果头节点在改变了，则继续循环，否则直接break if (h == head) break; } } AQS中的条件队列ConditionObject前面已经介绍了Condition接口，而ConditionObject是Condition的一个实现类，为单向链表。该条件队列的节点也是使用了内部类Node，可以在不满足某个条件的时候挂起线程等待，直到满足某个条件的时候在唤醒线程。下面看一下该类的成员变量： 12345678//等待队列的头节点private transient Node firstWaiter;//等待队列的尾节点private transient Node lastWaiter; //在退出等待时重新中断 private static final int REINTERRUPT = 1;//在退出等待时抛出InterruptedExceptionprivate static final int THROW_IE = -1; 一个 Condition 包含一个等待队列。Condition.await()方法，将会以当前线程构造节点，并将节点从尾部加入等待队列。 1.先看await()方法：12345678910111213141516171819202122232425262728public final void await() throws InterruptedException { //1,如果中断，直接抛出异常 if (Thread.interrupted()) throw new InterruptedException(); //2.将当前线程加入条件等待队列 Node node = addConditionWaiter(); //3.释放当前锁，并唤醒后驱节点，返回释放前的同步状态 int savedState = fullyRelease(node); int interruptMode = 0; //4.循环判断当前node是否已经转移到AQS队列中，直到成功转移到AQS队列结束循环 while (!isOnSyncQueue(node)) { //4.1 阻塞当前线程，直到被unpark或中断 LockSupport.park(this); //4.2如果发生了中断，则要检查中断，并检查节点已经加入到同步队列，如已加入，则break if ((interruptMode = checkInterruptWhileWaiting(node)) != 0) break; } if (acquireQueued(node, savedState) //5.死循环重新获取同步状态（刚刚释放了多少这里就获取多少），返回false获取成功，返回true获取失败 &amp;&amp; interruptMode != THROW_IE) //6.如果被signal后发生中断 interruptMode = REINTERRUPT;//将中断模式改为REINTERRUPT if (node.nextWaiter != null) //7. 删除取消的后驱节点 unlinkCancelledWaiters(); if (interruptMode != 0) //8.如果线程中断了，则抛出异常，如果为REINTERRUPT则中断当前线程 reportInterruptAfterWait(interruptMode); } 添加到等待队列的方法addConditionWaiter()： 1234567891011121314151617181920212223242526Node(Thread thread, int waitStatus) { // Used by Condition this.waitStatus = waitStatus; this.thread = thread; } private Node addConditionWaiter() { //获取尾节点 Node t = lastWaiter; //如果尾节点状态为CANCEL，则移除它 if (t != null &amp;&amp; t.waitStatus != Node.CONDITION) { //清除CANCEL的节点，将所有CONDITION的节点连接起来 unlinkCancelledWaiters(); //重新指向lastWaiter t = lastWaiter; } //构建一个新的condition类型Node加入条件等待队列 Node node = new Node(Thread.currentThread(), Node.CONDITION); //如果尾节点此时为空，则重新初始化首尾相同的队列 if (t == null) firstWaiter = node; else //将尾节点的后驱引用指向当前节点 t.nextWaiter = node; //更新尾节点 lastWaiter = node; return node; } 上述节点引用更新的过程并没有使用 CAS 保证，原因在于调用 await()方法的线程必定是获取了锁的线程，也就是说该过程是由锁来保证线程安全的。 unlinkCancelledWaiters()源码： 123456789101112131415161718192021222324252627private void unlinkCancelledWaiters() { //获取首节点 Node t = firstWaiter; //保存当前节点的前驱节点的引用 Node trail = null; while (t != null) { //获取后驱节点 Node next = t.nextWaiter; //如果当前节点的状态非CONDITION，则移除并将整个链表连接起来 if (t.waitStatus != Node.CONDITION) { //断开当前节点的后驱引用 t.nextWaiter = null; if (trail == null) //首节点指向下当前节点的后驱节点 firstWaiter = next; else //前驱节点存在，则让前驱节点直接跨过当前节点指向当前节点的后驱节点 trail.nextWaiter = next; if (next == null) lastWaiter = trail; } else //当前节点状态为CONDITION，则让trail指向当前节点，当前节点顺为下个节点 trail = t; t = next; } } 彻底释放锁fullyRelease(Node node)即无论多少次重入，通通清零 12345678910111213141516171819final int fullyRelease(Node node) { boolean failed = true; try { //获取当前同步状态 int savedState = getState(); //调用release方法释放并唤醒下一个同步队列的线程 if (release(savedState)) { failed = false; return savedState; } else { //如果释放失败，则抛出异常 throw new IllegalMonitorStateException(); } } finally { if (failed) //如果失败，则取消当前节点 node.waitStatus = Node.CANCELLED; } } isOnSyncQueue(Node node):如果该节点之前在条件等待队列，但现在在同步队列中，则返回true；如果不在同步队列返回false 12345678910111213141516171819202122//node为当前尾节点final boolean isOnSyncQueue(Node node) { //node的状态为CONDITION或node的前驱为空，则说明不在同步队列中，因为队列除头节点外的其他节点的前驱节点都不为 if (node.waitStatus == Node.CONDITION || node.prev == null) return false; //如果当前node 有后继节点，则说明其在同步队列中 if (node.next != null) return true; //到此方法就说明当前尾节点前驱不为空，且后驱为空，此时可以认为node正处于放入同步队列enq方法中的compareAndSetTail(t, node)操作中，前面已经分析过，此时已经连接好了pre但没有连接next，而这个CAS操作有可能失败，所以通过findNodeFromTail再尝试一次判断。 return findNodeFromTail(node); } //该方法中通过一个死循环从同步队列的尾到前遍历寻找当前节点，如果找到返回ture，否则返回false private boolean findNodeFromTail(Node node) { Node t = tail; for (;;) { if (t == node) return true; if (t == null) return false; t = t.prev; } } checkInterruptWhileWaiting(Node node)检查是否中断，如果在signal之前中断，则返回THROW_IE，如果在signal之后，则返回REINTERRUPT，如果没有中断，则为0。 123456private int checkInterruptWhileWaiting(Node node) { return Thread.interrupted() ? //如果发生了中断需要调用transferAfterCancelledWait保证中断的线程已经加入到同步队列 (transferAfterCancelledWait(node) ? THROW_IE : REINTERRUPT) : 0; } transferAfterCancelledWait(Node node)保证中断的线程已经加入到同步队列，判断中断的时候，是否有signal方法的调用，如果返回false表示在中断前被signal，之后checkInterruptWhileWaiting返回REINTERRUPT重新中断；如果返回true表示在中断后被signal，之后checkInterruptWhileWaiting返回THROW_IE 抛出中断异常。 12345678910111213final boolean transferAfterCancelledWait(Node node) { //将当前节点的状态从CONDITION改为0（从这也可以看出isOnSyncQueue方法中通过判断状态是否为CONDITION来判断是否被转移到同步队列） if (compareAndSetWaitStatus(node, Node.CONDITION, 0)) { //如果CAS成功，说明没有被signal，如果被signal，其状态会改为SIGNAL（后边会讲到），则加入同步队列 enq(node); return true; } //如果状态CAS失败，即node状态不为CONDITION，说明已经被signal或被中断，但不能保证先后顺序，通过while循环等待node已经转移到同步队列 while (!isOnSyncQueue(node)) Thread.yield(); //返回false重新中断 return false; } await的带超时时间的其他几个方法同这个基本一样，只是加了超时时间，具体作用看上面的Condition的介绍 2.再看signal相关 将等待时间最长的线程（如果存在）,从条件等待队列移至拥有锁的等待队列。 12345678public final void signal() { //1.首先判断当前线程是不是独占模式，如果不是则抛出异常 if (!isHeldExclusively()) throw new IllegalMonitorStateException(); Node first = firstWaiter; if (first != null) doSignal(first); } doSignal(Node first)会从从首节点开始遍历，把第一个非空、没取消的节点转移到同步队列 123456789private void doSignal(Node first) { do { //删除first接地那 if ( (firstWaiter = first.nextWaiter) == null) lastWaiter = null; first.nextWaiter = null; } while (!transferForSignal(first) &amp;&amp; (first = firstWaiter) != null); } transferForSignal(Node node) 会将节点从条件队列转移到AQS队列 123456789101112131415final boolean transferForSignal(Node node) { //尝试将Node的状态从CONDITION改为0, if (!compareAndSetWaitStatus(node, Node.CONDITION, 0)) //如果CAS失败，说明节点在signal前被取消，返回false，转移失败 return false; //CAS成功，则将该节点加入AQS队列尾部，并返回之前的tail Node p = enq(node); //获取之前的tail的状态 int ws = p.waitStatus; if (ws &gt; 0 //&gt;0，即之前的tail被取消， 则直返回唤醒当前节点的线程 || !compareAndSetWaitStatus(p, ws, Node.SIGNAL))//如果没有被取消，则将原tail节点状态设为SIGNAL,如果失败了则直接唤醒当前线程，如果成功了则前驱节点被设为SIGNAL LockSupport.unpark(node.thread);//唤醒当前节点，当前线程可从await()中的park()返回 return true; } 另外还有signalAll()方法。实现将Condition队列上的所有节点转移到AQS同步队列去竞争锁（独占）。 总结：一个同步器拥有一个同步队列（双向）和多个等待队列（单向）。调用 await()相关的方法，会让当前线程进入等待队列并释放锁，同时线程进入等待状态。从 await()方法返回时，当前线程一定获取了 Condition 绑定的锁。1.调用 await()相关方法时，将同步队列的首节点的线程获取到了锁，将通过addConditionWaiter()方法把当前线程构造成一个新的节点并加入等待队列中，然后释放同步状态，唤醒同步队列中的后驱节点，随后当前线程会进入等待状态。2.等待队列中的节点通过其他线程调用Condition.signal()方法被唤醒后，被唤醒的线程开始尝试获取同步状态。如果是通过中断唤醒，则会抛出InterruptedException，如果不是，将中断模式设为REINTERRUPT，并将被取消的后驱节点清除。3.调用signal()方法，会唤醒在等待队列中等待时间最长的节点（首节点），在唤醒节点之前，会将该节点转移到同步队列中。但当前线程必须是获取了锁 。4.接着获取等待队列的首节点，将其全地转移到同步队列后并使用 LockSupport .unpark唤醒该节点中的线程。5.被唤醒的线程就会从 await()方法中的 while (!isOnSyncQueue(node))循环中退出。（isOnSyncQueue(Node node)方法返回 true，节点已经在同步队列中），6.然后调用 acquireQueued()方法加入到获取同步状态的竞争中。成功获取同步状态（或者说锁）之后，被唤醒的线程将从先前调用的 await()方法返回，此时该线程已经成功地获取了锁。 （部分分析可能有瑕疵，还请指正，感谢~） 下一篇讲Lock的实现类： java并发编程之ReentrantLock和读写锁","link":"/posts/20200204-lcAQS.html"},{"title":"java并发编程之ReentrantLock和读写锁ReentrantReadWriteLock","text":"在前文java并发编程之显示锁Lock、Condition接口、LockSupport以及AQS（同步队列、条件等待队列）详解已经对Lock、Condition以及AQS相关进行了介绍，接下来就要讲一讲Lock接口的几个实现类：ReentrantLock、ReentrantReadWriteLock及其内部类ReadLock和WriteLock。本文中带△△的标注代表前文已讲过，不详述。 首先了解下锁的可重入的概念： 一、锁的可重入“重入“是指线程在获取到锁之后能够再次获取该锁而不会被阻塞，因此：1）线程再次获取锁时，需要去识别获取锁的线程是否为当前持有锁的线程，如果是，则再次成功获取。2）线程获取了几次锁，就需要释放几次锁，只有全部释放完毕，其他线程才能获得锁，因此需要对锁的获取进行自增计算，自增次数表示当前锁被重复获取的次数，而锁被释放时，每次释放该计数都自减1直到减到0时表示成功释放锁。 二、ReentrantLock2.1 类图从上图可以看出：1.ReentrantLock实现了Lock接口2.内部类Sync继承了AQS3. FairSync和NocfairSync继承了Sync 另外，ReentrantLock是可重入的独占锁，因此一次只能有一个线程可获取锁，而其他线程会被阻塞在AQS队列，针对获取锁，其提供了公平和非公平的实现，而公平模式和非公平模式主要通过ReentrantLock的构造方法确定的，如下： 123456public ReentrantLock() { sync = new NonfairSync();}public ReentrantLock(boolean fair) { sync = fair ? new FairSync() : new NonfairSync();} 默认构造函数中，实现了非公平的实现，而带参的构造函数，参数fair为true时为公平实现，为false时为非公平实现。 ReentrantLock的成员变量只有一个Sync对象： 1private final Sync sync; 其成员函数除了实现Lock接口提供的几个方法外（如下），其他方法都是很简单，如获取等待队列长度、获取等待的线程等待。（这几个方法的介绍在上一篇文章有介绍）而对这几个方法的具体实现，都是根据Sync实现了公平锁还是非公平锁。 下面先讲非公平锁的相关方法： 2.2 非公平模式以下是非公平锁的lock()方法： 2.2.1 lock()123456final void lock() { if (compareAndSetState(0, 1)) setExclusiveOwnerThread(Thread.currentThread()); else acquire(1);} 该方法中：1.首先调用compareAndSetState(0, 1)尝试将状态值从0改为1，如果CAS成功，表示锁已经被当前线程占用，则将当前线程设为有独占访问权的线程2.如果CAS失败，表示锁已经被其他线程占用，则调用acquire(1)方法尝试获取锁。 △△acquire(1)为AQS中的方法： 12345public final void acquire(int arg) { if (!tryAcquire(arg) &amp;&amp; acquireQueued(addWaiter(Node.EXCLUSIVE), arg)) selfInterrupt(); } 其中tryAcquire()为尝试获取锁的模板方法，这里的具体实现就是调用了NonfairSync下的非公平实现方法： 12345678910111213141516171819202122232425262728293031323334protected final boolean tryAcquire(int acquires) { return nonfairTryAcquire(acquires); }final boolean nonfairTryAcquire(int acquires) { //获取当前线程 final Thread current = Thread.currentThread(); //当前当前同步状态 int c = getState(); //如果状态为0，表示当前没有线程持有锁 if (c == 0) { //重复lock()中的第一个if语句 if (compareAndSetState(0, acquires)) { setExclusiveOwnerThread(current); return true; } } //如果状态不为0，代表当前有线程持有锁 // 则判断当前持有锁的线程是否为当前线程 else if (current == getExclusiveOwnerThread()) { // 如果是当前线程持有锁 // 1.让当前状态加上acquires(可重入就在这里体现，进行自增) int nextc = c + acquires; //2. 如果加上acquires后的状态值仍小于0 if (nextc &lt; 0) //说明溢出了，抛出异常 throw new Error(\"Maximum lock count exceeded\"); // 如果大于0，则更新当前状态 setState(nextc); //返回true return true; } // 如果不是当前线程，则返回false，尝试获取失败 return false; } 简单总结一下流程：1.首先判断当前状态值state是否等于0，如果等于0则说明没有线程持有锁，进入2，否则进入32. CAS更新状态值，并将当前线程设为独占的3.判断当前持有锁的线程是否为当前线程，如果是则自增状态值，否则返回false；自增状态时需检查自增后的状态值，如果大于0，则更新state，如果小于0，说明溢出，抛出异常。 而如果获取失败了则会执行AQS的acquireQueued(addWaiter(Node.EXCLUSIVE), arg))方法，将当前线程构造为一个独占模式的节点加入同步队列，如果前驱节点为首节点，才可以尝试获取锁，否则跳过处于CANCEL状态的节点，并将前驱节点更新为SIGNAL阻塞自身等待唤醒。以上就是lock()的非公平实现，了解了其可重入的实现核心，如果我们想实现一个自己的不可重入的独占锁，就很简单了。主要就是修改tryAcquire(int arg) 方法，如果CAS成功，则将当前线程设为独占的，否则直接返回false，不进行持有锁是否为当前线程的判断等相关操作。 123456789/*获得锁*/ @Override protected boolean tryAcquire(int arg) { if(compareAndSetState(0,1)){ setExclusiveOwnerThread(Thread.currentThread()); return true; } return false; } 2.2.2 unlock()ReentrantLock的unlock()也是直接调用了AQS的△△release()方法： 123456789101112（ReentrantLock）public void unlock() { sync.release(1); }（AQS）public final boolean release(int arg) { if (tryRelease(arg)) { Node h = head; if (h != null &amp;&amp; h.waitStatus != 0) unparkSuccessor(h); return true; } return false;} 该方法的tryRelease(arg)也是模板方法，在ReentrantLock的实现如下：（非公平和公平模式只是针对lock过程，release的实现是相同的） 12345678910111213141516171819protected final boolean tryRelease(int releases) { // 计算当前状态减去releases后的值 int c = getState() - releases; // 如果当前线程不是独占模式的，则抛出异常 if (Thread.currentThread() != getExclusiveOwnerThread()) throw new IllegalMonitorStateException(); // 可以理解为是否彻底释放 boolean free = false; // 如果c为0，说明当前线程已经将锁释放完毕，即重入的次数都已释放 if (c == 0) { // 置为true，表示已彻底释放 free = true; // 将当前独占线程清空 setExclusiveOwnerThread(null); } // 如果自减一后的state不为0，说明尚未释放完毕，返回false setState(c); return free; } 流程简单的将就是：如果当前状态自减1后为0，则说明锁释放完毕，情况独占锁；如果不为0，则说明重入锁未释放完毕，仍持有资源 如果返回false，就会继续执行release()的△△unparkSuccessor(h);方法唤醒后驱节点。而后驱节点被唤醒后就会再次执行acquireQueued() 1234567891011121314final boolean acquireQueued(final Node node, int arg) { .............. boolean interrupted = false; for (;;) { final Node p = node.predecessor(); if (p == head &amp;&amp; tryAcquire(arg)) { setHead(node); p.next = null; // help GC failed = false; return interrupted; } ............. } } 此时p==head成立，将当前节点设为head，与原head断开，并返回中断标志，此时如没有被中断，就直接从acquire()方法返回，否则中断当前线程。 2.3 公平模式lock()方法：该lock方法也是实现了AQS的acquire()方法，但是是在FairSync实现了公平模式获取锁： 1234567891011121314151617181920protected final boolean tryAcquire(int acquires) { final Thread current = Thread.currentThread(); int c = getState(); if (c == 0) { if (!hasQueuedPredecessors() &amp;&amp; compareAndSetState(0, acquires)) { setExclusiveOwnerThread(current); return true; } } else if (current == getExclusiveOwnerThread()) { int nextc = c + acquires; if (nextc &lt; 0) throw new Error(\"Maximum lock count exceeded\"); setState(nextc); return true; } return false; } } 从源码可以看出，只是在当前状态值为0时，即没有线程持有锁时增加了一个hasQueuedPredecessors()判断，源码如下： 12345678public final boolean hasQueuedPredecessors() { Node t = tail; Node h = head; Node s; return h != t &amp;&amp; //1.头尾节点不相同，说明队列非空，如果队列空，则返回false，说明没有线程在等待 ((s = h.next) == null || s.thread != Thread.currentThread());//2. 队列非空，如果等待线程不是当前线程，则返回true，如果是当前线程，则返回true } 该方法返回当前等待队列是否有其他线程等待，true表示有其他线程在等待，false表示没有如果返回false，则继续进行后面的步骤，同非公平步骤相同 可见，公平锁会考虑线程等待的优先顺序，而非公平锁不考虑顺序，谁来谁就去争夺锁。 三、读写锁ReentrantReadWriteLock在读多写的场景下，该锁就非常适用。该类维护了一个读锁ReadLock和一个写锁WriteLock。 关于写锁：1.写锁是一个支持可重入的排它锁。如果当前线程已经获取了写锁，则增加写状态。如果当前线程在获取写锁时，读锁已经被获取（读状态不为 0）或者该线程不是已经获取写锁的线程，则当前线程进入等待状态。2.如果读锁被获取，则写锁不能被获取。 因为读写锁要保证写锁的操作对读锁可见，如果读锁已被获取，又对写锁获取，那么其他读线程就无法感知到当前写线程的操作。因此，写锁被当前线程获取的前提是其他读线程全部释放读锁，3.写锁一旦被获取，则其他读写线程的访问均被阻塞。关于读锁：1.读锁是一个支持重进入的共享锁，它能够被多个线程同时获取。2.在写锁没有被获取时，读锁可以被多次获取。获取成功则安全地增加读状态（该状态是所有线程获取读锁的次数和，但每个线程获取读锁的次数保存在ThreadLocal中）3.如果在获取读锁时，写锁被其他线程获取，则当前线程阻塞等待 关于锁的升降级：1.锁降级指的是写锁降级为读锁：当前持有写锁，同时再去获取读锁，最后再释放写锁2.锁升级指的是读锁升级为写锁：当前持有读锁，获取写锁，最后释放读锁，但RentrantReadWriteLock不支持锁的升级，因为如果多个线程持有读锁，任意一个线程升级到了写锁，这样就不能保证写线程的更新对其他读线程的可见性。 3.1 类结构从图中可以见出：1.ReentrantReadWriteLock实现了ReadWriteLock接口，在该接口中提供了一个读锁和一个写锁，其具体实现就ReentrantReadWriteLock中的读锁和写锁。2.ReentrantReadWriteLock有5个内部类，分别为ReadLock、WriteLock、FairSync、NonfairSync和Sync，其中FairSync和NonfairSync是Sync的公平和非公平的实现，Sync实现了AQS，读锁和写锁实现了Lock接口。3.在Sync下又有两个内部类：ThreadLocalHoldCounter和HoldCounter 3.2 Sync首先看Sync类：它的两个内部类源码如下： 123456789101112static final class HoldCounter { int count = 0; final long tid = getThreadId(Thread.currentThread()); }static final class ThreadLocalHoldCounter extends ThreadLocal&lt;HoldCounter&gt; { public HoldCounter initialValue() { return new HoldCounter(); } } 其中HoldCounter 内部维护了一个count变量和一个tid，其中count表示一个读线程重入的次数，tid表示持有读锁的当前线程的id，唯一标识一个线程。而ThreadLocalHoldCounter继承了ThreadLocal，并且将HoldCounter作为泛型，重写了ThreadLocal的initialValue()方法，可直接通过get获取当前线程的count值。 在看起类属性前，先了解其读写状态的设计： 读写状态的设计：ReentrantLock 中，同步状态表示锁被一个线程重复获取的次数，而读写锁的自定义同步器需要在同步状态（整型变量）上维护多个读线程和一个写线程的状态，因此就需要对该遍历进行“按位切割使用”。同步状态的高 16 位表示读（读锁线程数），低 16 位表示写（写锁重入此数）读写锁通过位运算确定当前状态。假设当前同步状态值为 S，写状态等于 S&amp;0x0000FFFF（将高 16 位全部抹去），读状态等于 S&gt;&gt;&gt;16（无符号补 0 右移 16 位）。当写状态增加1时，等于S+1，当读状态增加1时，等于S+(1&lt;&lt;16)，也就是S+0x00010000。根据状态的划分能得出一个推论：S 不等于 0 时，当写状态（S&amp;0x0000FFFF）等于 0 时，则读状态（S&gt;&gt;&gt;16）大于 0，即读锁已被获取。（图片来源于网络） Sync的成员属性如下： 123456789101112131415161718192021222324252627 读写锁共用同步状态，高16用于读，低16位用于写 static final int SHARED_SHIFT = 16;// 读锁的单位（因为读锁是高16位，因此每次要加上2^16） static final int SHARED_UNIT = (1 &lt;&lt; SHARED_SHIFT); // 写锁的最大可重入次数或读锁允许的最大线程数 static final int MAX_COUNT = (1 &lt;&lt; SHARED_SHIFT) - 1; // 写锁掩码，用于状态的低16位有效值 static final int EXCLUSIVE_MASK = (1 &lt;&lt; SHARED_SHIFT) - 1; //读锁的计数，当前同步状态右移16位获取读锁计数 static int sharedCount(int c) { return c &gt;&gt;&gt; SHARED_SHIFT; } //获取写线程的数量（获取写锁的重入次数） static int exclusiveCount(int c) { return c &amp; EXCLUSIVE_MASK; }// 保存本地线程获取读锁的重入次数，当前线程的计数变为0时删除之 private transient ThreadLocalHoldCounter readHolds; // 表示最后一个成功获取读锁的线程的计数的缓存 /* 获取和释放读锁的时候，需要更新HoldCount，会先检测缓存的是否为空，如果不为空，则判断线程ID是否和当前线程ID相同 如果相同，就直接通过缓存更新HoldCount 否则，从readHolds中获取HoldCounter对象，赋值给该缓存，最后再更新HoldCounter的计数（不理解的话需要先看下面的源码分析，回头再看就理解了） */ private transient HoldCounter cachedHoldCounter; //第一个获得读取锁的线程。（这里使用此变量应该就是为了提高效率，当只有一个线程获取读锁时，可直接从此变量获取，不需要操作readHolds.get()了） private transient Thread firstReader = null; //是firstReader的重入数。 private transient int firstReaderHoldCount; Sync的构造函数： 123456Sync() { // 初始化本地线程计数器 readHolds = new ThreadLocalHoldCounter(); //确保readHolds的可见性 setState(getState()); } Sync是公平的还是非公平的是在ReentrantReadWriteLock的构造中确定的： 12345public ReentrantReadWriteLock(boolean fair) { sync = fair ? new FairSync() : new NonfairSync(); readerLock = new ReadLock(this); writerLock = new WriteLock(this); } fair为true时实现公平模式，为false时实现非公平模式，同时初始化读锁和写锁。 写锁：写锁内部就维护了一个Sync，其具体实现由ReentrantReadWriteLock中的sync决定： 123456789public static class WriteLock implements Lock, java.io.Serializable { private static final long serialVersionUID = -4992448646407690164L; private final Sync sync; protected WriteLock(ReentrantReadWriteLock lock) { sync = lock.sync; }} 写锁的lock():lock()也是调用了AQS的lock()方法，具体实现为Sync下的tryAcquire() 12345678910111213141516171819202122232425262728293031protected final boolean tryAcquire(int acquires) { //获取当前线程 Thread current = Thread.currentThread(); //获取同步状态 int c = getState(); // 获取写线程数量 int w = exclusiveCount(c); //状态不为0，表示已有其他线程获取读锁或写锁 if (c != 0) { //a.而如果此时w==0即写锁没有被占用，说明读锁被占用，因此直接返回false，获取失败 if (w == 0 || //b.如果当前写锁被持有，则判断持有锁的线程是否为当前线程，如果不是则返回false，如果是则继续 current != getExclusiveOwnerThread()) return false; //如果持有写锁的线程为当前线程 // 则重新计算当前写锁重入次数后是否大于最大重入次数(2^16-1) if (w + exclusiveCount(acquires) &gt; MAX_COUNT) //如果超出最大重入次数，则抛出异常 throw new Error(\"Maximum lock count exceeded\"); //否则更新同步状态，即自增重入次数 setState(c + acquires); return true; } //如果状态为0，表示没有线程获取读写锁 if (writerShouldBlock() || //是否应该阻塞当前获取写锁的线程 !compareAndSetState(c, c + acquires))//如果不需要阻塞，则CAS更新同步状态 return false; //CAS成功，将当前线程设为独占的 setExclusiveOwnerThread(current); return true; } writerShouldBlock()的公平实现需要调用hasQueuedPredecessors判断有没有已经在等待获取写锁的线程，如果有则阻塞当前线程，如果没有则返回true；而非公平实现直接返回false 1234567891011static final class NonfairSync extends Sync { final boolean writerShouldBlock() { return false; }}static final class FairSync extends Sync { final boolean writerShouldBlock() { return hasQueuedPredecessors(); } } 流程总结：获取当前同步状态state，和写锁重入次数w 如果state不为0.说明读锁或写锁被占用1.1 如果w为0说明写锁被持有，因此读锁已经被持有，直接返回false1.2 如果w不为0，说明当前写锁被持有，则判断当前写锁线程是否为当前线程，如果是则判断重入次数是否溢出，如果没溢出则更新同步状态返回true；如果不是则直接返回false 如果为0，说明读写锁都没有被占用，则根据sync是公平还是非公平实现判断当前线程是否需要阻塞，如果不需要阻塞则CAS更新同步状态，成功后将当前线程设为独占的，并返回true，获取写锁成功 写锁的unlock():同样调用AQS的unlock，tryRelease的实现如下： 12345678910111213protected final boolean tryRelease(int releases) { //1.如果当前线程不是持有写锁的线程，直接抛出异常 if (!isHeldExclusively()) throw new IllegalMonitorStateException(); //2.计算当前状态减去releases后的值 int nextc = getState() - releases; boolean free = exclusiveCount(nextc) == 0; if (free) //如果重入次数为0，则直接清空锁的持有者。因此重入锁必须将重入次数全部释放后才可真正释放锁,返回true setExclusiveOwnerThread(null); //否则更新重入次数，返回false setState(nextc); return free; 流程总结：1.如果当前线程不是持有写锁的线程直接抛出异常2.如果获取写锁数量为0表示成功释放，置独占线程为空，返回true2.如果不为0，则更新同步状态，返回false 读锁：结构同写锁相同 读锁的lock():对应Sync的tryAcquireShared ： 12345678910111213141516171819202122232425262728293031323334353637383940414243protected final int tryAcquireShared(int unused) { //获取当前线程 Thread current = Thread.currentThread(); // 获取当前状态 int c = getState(); // 如果当前写锁被持有，且不是当前线程,返回-1，小于0表示获取失败 // 而如果写锁被持有，且是当前线程持有，说明正在进行锁降级 if (exclusiveCount(c) != 0 &amp;&amp; getExclusiveOwnerThread() != current) return -1; // 获取当前获取读锁的线程数量 int r = sharedCount(c); if (!readerShouldBlock() &amp;&amp; //具体根据公平或非公平原则判断是否需要阻塞当前线程 r &lt; MAX_COUNT &amp;&amp; //读锁线程小于最大值 compareAndSetState(c, c + SHARED_UNIT)) {//CAS更新成功 if (r == 0) { //持有读锁线程为0 // 将当前线程设为第一个持有读锁的线程，即将读锁状态从0变为1 firstReader = current; firstReaderHoldCount = 1; } else if (firstReader == current) {//当前线程是第一个线程，即该线程重入 //重入数自增 firstReaderHoldCount++; } else {//当前线程不是第一个线程 //先查取缓存，获取缓存计数 HoldCounter rh = cachedHoldCounter; //1.缓存为空 //2.缓存不为空，但对应的线程id非当前正在运行的线程id if (rh == null || rh.tid != getThreadId(current)) // 从threadLocal中获取计数 cachedHoldCounter = rh = readHolds.get(); //如果计数为0 else if (rh.count == 0) //则加入到readHolds中 readHolds.set(rh); //计数自增 rh.count++; } //获取成功，返回1 return 1; } return fullTryAcquireShared(current); } 如果当前线程需要阻塞，或读线程超过最大值，或CAS失败，进入fullTryAcquireShared方法，循环获取读锁 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556final int fullTryAcquireShared(Thread current) { HoldCounter rh = null; //死循环自旋 for (;;) { //获取当前状态 int c = getState(); if (exclusiveCount(c) != 0) {//有线程持有写锁 if (getExclusiveOwnerThread() != current) //且不是当前线程，则返回-1 return -1; } else if (readerShouldBlock()) {//如果需要阻塞 if (firstReader == current) {///当前线程为第一个获取读锁的 // assert firstReaderHoldCount &gt; 0; } else {//当前线程不是第一个获取读锁的 if (rh == null) { //计数为空，则将缓存赋值给它 rh = cachedHoldCounter; //缓存为空或运行线程tid不是当前运行的线程 if (rh == null || rh.tid != getThreadId(current)) { //从threadlocal中获取 rh = readHolds.get(); if (rh.count == 0) readHolds.remove(); } } if (rh.count == 0) return -1; } } // 读锁线程超过最大值，抛出异常 if (sharedCount(c) == MAX_COUNT) throw new Error(\"Maximum lock count exceeded\"); //CAS更新状态值 if (compareAndSetState(c, c + SHARED_UNIT)) { //下面逻辑跟上面基本相同，不赘述 if (sharedCount(c) == 0) { firstReader = current; firstReaderHoldCount = 1; } else if (firstReader == current) { firstReaderHoldCount++; } else { if (rh == null) rh = cachedHoldCounter; if (rh == null || rh.tid != getThreadId(current)) rh = readHolds.get(); else if (rh.count == 0) readHolds.set(rh); rh.count++; cachedHoldCounter = rh; // cache for release } return 1; } } } 读锁的unlock():涉及的类如下： 123456789101112131415161718192021222324252627282930313233343536373839protected final boolean tryReleaseShared(int unused) { Thread current = Thread.currentThread(); //如果第一个读锁的线程是当前线程 if (firstReader == current) { //如果只重入一次 if (firstReaderHoldCount == 1) //直接置空 firstReader = null; else //否则计数自减 firstReaderHoldCount--; } else {//当前线程非第一个读锁线程 //获取缓计数 HoldCounter rh = cachedHoldCounter; if (rh == null || rh.tid != getThreadId(current)) //缓存为空或非当前线程则从threadlocal获取 rh = readHolds.get(); //获取当前线程的获取读锁次数 int count = rh.count; if (count &lt;= 1) {//如果计数小于等于1 readHolds.remove();//彻底释放资源 if (count &lt;= 0)//小于等于-时抛出异常 throw unmatchedUnlockException(); } // 当前线程的读锁的可重入次数自减 --rh.count; } for (;;) { //获取当前状态 int c = getState(); //释放后的状态 int nextc = c - SHARED_UNIT; //cas更新状态 if (compareAndSetState(c, nextc)) //如果为0，表示彻底释放，返回ture，否则返回false return nextc == 0; } } 释放流程：1.如果当前线程是第一个获取读锁的线程，则判断其占有的资源是否为1，即是否只重入一次，如果是，则让第一个读锁的线程置空，否则让第一个读锁的线程的重入次数自减一2.如果当前线程非第一个读锁线程，则首先获取缓存计数，如果为空或非当前线程，则从threadLocal中获取当前线程的计数，如果计数小于等于1，则移除计数，如果≤0，则抛出异常；最后再让count自减一3.进入死循环CAS更新同步状态","link":"/posts/20200207-reentrant_read_write_lock.html"}],"tags":[{"name":"elasticsearch","slug":"elasticsearch","link":"/tags/elasticsearch/"},{"name":"docker","slug":"docker","link":"/tags/docker/"},{"name":"centos7","slug":"centos7","link":"/tags/centos7/"},{"name":"firewall","slug":"firewall","link":"/tags/firewall/"},{"name":"linux","slug":"linux","link":"/tags/linux/"},{"name":"gulp,压缩静态资源","slug":"gulp-压缩静态资源","link":"/tags/gulp-%E5%8E%8B%E7%BC%A9%E9%9D%99%E6%80%81%E8%B5%84%E6%BA%90/"},{"name":"jib","slug":"jib","link":"/tags/jib/"},{"name":"文件上传","slug":"文件上传","link":"/tags/%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0/"},{"name":"fdfs","slug":"fdfs","link":"/tags/fdfs/"},{"name":"排序","slug":"排序","link":"/tags/%E6%8E%92%E5%BA%8F/"},{"name":"数据结构","slug":"数据结构","link":"/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"二叉树","slug":"二叉树","link":"/tags/%E4%BA%8C%E5%8F%89%E6%A0%91/"},{"name":"调度算法","slug":"调度算法","link":"/tags/%E8%B0%83%E5%BA%A6%E7%AE%97%E6%B3%95/"},{"name":"分治","slug":"分治","link":"/tags/%E5%88%86%E6%B2%BB/"},{"name":"并发编程","slug":"并发编程","link":"/tags/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"},{"name":"fork/join","slug":"fork-join","link":"/tags/fork-join/"},{"name":"CountDownLatch","slug":"CountDownLatch","link":"/tags/CountDownLatch/"},{"name":"CyclicBarrier","slug":"CyclicBarrier","link":"/tags/CyclicBarrier/"},{"name":"Semaphore","slug":"Semaphore","link":"/tags/Semaphore/"},{"name":"Runnable","slug":"Runnable","link":"/tags/Runnable/"},{"name":"Callable","slug":"Callable","link":"/tags/Callable/"},{"name":"Future","slug":"Future","link":"/tags/Future/"},{"name":"FutureTask","slug":"FutureTask","link":"/tags/FutureTask/"},{"name":"多线程","slug":"多线程","link":"/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"},{"name":"CAS","slug":"CAS","link":"/tags/CAS/"},{"name":"原子操作类","slug":"原子操作类","link":"/tags/%E5%8E%9F%E5%AD%90%E6%93%8D%E4%BD%9C%E7%B1%BB/"},{"name":"AtomicXXX","slug":"AtomicXXX","link":"/tags/AtomicXXX/"},{"name":"AQS","slug":"AQS","link":"/tags/AQS/"},{"name":"显示锁Lock","slug":"显示锁Lock","link":"/tags/%E6%98%BE%E7%A4%BA%E9%94%81Lock/"},{"name":"LockSupport","slug":"LockSupport","link":"/tags/LockSupport/"},{"name":"ReentrantLock","slug":"ReentrantLock","link":"/tags/ReentrantLock/"},{"name":"ReentrantReadWriteLock","slug":"ReentrantReadWriteLock","link":"/tags/ReentrantReadWriteLock/"},{"name":"读写锁","slug":"读写锁","link":"/tags/%E8%AF%BB%E5%86%99%E9%94%81/"}],"categories":[{"name":"docker","slug":"docker","link":"/categories/docker/"},{"name":"linux","slug":"linux","link":"/categories/linux/"},{"name":"工具","slug":"工具","link":"/categories/%E5%B7%A5%E5%85%B7/"},{"name":"springboot","slug":"springboot","link":"/categories/springboot/"},{"name":"数据结构","slug":"数据结构","link":"/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"排序","slug":"数据结构/排序","link":"/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%8E%92%E5%BA%8F/"},{"name":"二叉树","slug":"数据结构/二叉树","link":"/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E4%BA%8C%E5%8F%89%E6%A0%91/"},{"name":"操作系统","slug":"操作系统","link":"/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"},{"name":"并发编程","slug":"并发编程","link":"/categories/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"},{"name":"并发工具类","slug":"并发编程/并发工具类","link":"/categories/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/%E5%B9%B6%E5%8F%91%E5%B7%A5%E5%85%B7%E7%B1%BB/"},{"name":"原子操作CAS","slug":"并发编程/原子操作CAS","link":"/categories/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/%E5%8E%9F%E5%AD%90%E6%93%8D%E4%BD%9CCAS/"},{"name":"显示锁和AQS","slug":"并发编程/显示锁和AQS","link":"/categories/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/%E6%98%BE%E7%A4%BA%E9%94%81%E5%92%8CAQS/"}]}