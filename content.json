{"pages":[{"title":"文章分类","text":"","link":"/categories/index.html"},{"title":"标签","text":"","link":"/tags/index.html"},{"title":"gallery","text":"","link":"/gallery/index.html"}],"posts":[{"title":"centos7查看防火墙以及开放和关闭端口","text":"查看某个端口是否开放 1firewall-cmd --query-port=22122/tcp yes/no 开放/未开放 开放指定端口1firewall-cmd --add-port=22122/tcp --permanent firewall-cmd –zone=public –add-port=80/tcp –permanent-zone #作用域-permanent 没有该参数重启后失效 重新加载端口： 1firewall-cmd --reload 3.关闭某个端口 1firewall-cmd --permanent --remove-port=22122/tcp 重新加载 4. 查看防火墙状态 123firewall-cmd --state或者:systemctl status firewalld 打开/关闭防火墙 启动：systemctl start firewalld关闭： systemctl stop firewalld开机启用 ： systemctl enable firewalld禁止firewall开机启动 ：systemctl disable firewalld.service启动服务：systemctl start firewalld.service关闭服务：systemctl stop firewalld.service重启服务：systemctl restart firewalld.service 查看端口占用情况 1netstat -anp 查看防火墙已开放的端口 1firewall-cmd --list-ports","link":"/posts/20200107-centos7_firewall.html"},{"title":"docker安装ES","text":"123456789101112131415161718192021222324docker pull elasticsearch:6.4.0 //再低就是5.x了1.vim /etc/security/limits.d/90-nproc.conf 添加：soft nproc 40962. vim /etc/sysctl.conf 添加vm.max_map_count=655360 执行sysctl -p刷新配置//根据自己的内存大小适当调整，太大会启动失败3.docker run -e ES_JAVA_OPTS=\"-Xms512m -Xmx512m\" -d -p 9200:9200 -p 9300:9300 --name=myES 容器id4.docker exec -it 容器名 /bin/bash 进入容器命令行5.vim config/elasticsearch.yml 地址改为0.0.0.0可能会vim不可用 执行 yum update yum install -y vim6.安装ik分词器先上传到宿主机，再使用以下命令copy到容器中docker cp 宿主机ik分词器地址 容器名:/usr/share/elasticsearch/plugins/ik","link":"/posts/20200106-docker_es.html"},{"title":"jib打包项目到阿里镜像","text":"​ Jib 将处理将应用打包到容器镜像过程中的所有步骤，它直接与 Maven 和 Gradle Java 开发环境集成，不需要你编写 Dockerfile 或安装 Docker（但想要运行还是要本地安装docker） ，只需将其作为插件添加到你的构建中，就可以立即将 Java 应用容器化。 图片来源于https://www.oschina.net/news/97892/google-opensource-jib 一、在pom文件中引入jib插件1234567891011121314151617181920212223242526272829303132333435363738394041424344&lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt; &lt;/plugin&gt; &lt;plugin&gt; &lt;groupId&gt;com.google.cloud.tools&lt;/groupId&gt; &lt;artifactId&gt;jib-maven-plugin&lt;/artifactId&gt; &lt;version&gt;1.7.0&lt;/version&gt; &lt;configuration&gt; &lt;!--拉取的镜像的配置，默认为gcr.io/distroless/java--&gt; &lt;from&gt; &lt;image&gt;基础镜像地址&lt;/image&gt; &lt;auth&gt; &lt;username&gt;阿里云用户名&lt;/username&gt; &lt;password&gt;阿里云密码&lt;/password&gt; &lt;/auth&gt; &lt;/from&gt; &lt;to&gt; &lt;image&gt;基础镜像地址&lt;/image&gt; &lt;auth&gt; &lt;username&gt;阿里云用户名&lt;/username&gt; &lt;password&gt;阿里云密码&lt;/password&gt; &lt;/auth&gt; &lt;tags&gt; &lt;tag&gt;版本号&lt;/tag&gt; &lt;/tags&gt; &lt;/to&gt; &lt;allowInsecureRegistries&gt;true&lt;/allowInsecureRegistries&gt; &lt;/configuration&gt; &lt;executions&gt; &lt;execution&gt; &lt;phase&gt;package&lt;/phase&gt; &lt;goals&gt; &lt;goal&gt;build&lt;/goal&gt; &lt;/goals&gt; &lt;/execution&gt; &lt;/executions&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/build&gt; 版本号这里一开始指定的自定义版本，但是使用jib:build时报错，说找不到latest版本，不知道是不是默认拉取latest，但是网上其他博主好像并没有这个情况，这里就只好将tag设为latest了 二、github创建仓库添加Dockerfile文件 三、阿里云创建镜像仓库3.1 创建仓库点击下一步，根据提示选择Dockerfile所在仓库 进入新创建的仓库，点击添加规则这里版本起名latest，原因上面解释了，有知道的伙伴还请告知 感谢~ 点击构建，等待一会，下方日志中会显示构建的镜像和状态 最后返回基本信息，复制公网地址，放在from和to的image中，一定要填写username和password最后执行 jib:build即可成功 成功! 最后在docker中拉取就可以了 1docker run -d --name testjib-p 8081:8081 刚刚复制的公网地址:latest(对应的镜像版本号)","link":"/posts/20200106-jib_ali.html"},{"title":"mavon-editor+springboot+fdfs上传文件","text":"一、安装mavon直接npm install下就可以了，然后在main.js引入：12import mavonEditor from 'mavon-editor'Vue.use(mavonEditor) 二、页面使用1234567891011&lt;mavon-editor v-show=\"!articleModal\" id=\"editor\" v-model=\"value\" fontSize=\"16px\" ref=\"md\" @imgAdd=\"$imgAdd\" @imgDel=\"$imgDel\" @change=\"handleChange\" @fullScreen=\"handleFullScreen\" /&gt; 这里只需要关注@imgAdd，为添加图片的事件 三、上传文件这里使用的是批量上传，所以每触发一次@imgAdd就向文件集合添加一次 1234567/** * 添加文件到文件集合中 */ $imgAdd(pos, $file) { // 缓存图片信息 this.img_file[pos] = $file; }, data中定义如下： 1img_file: {}, //文件集合 上传文件方法： 123456789101112131415161718192021222324/** * 上传文件 */ uploadimg($e) { var formdata = new FormData(); for (var _img in this.img_file) { formdata.append(\"files\", this.img_file[_img]); } uploadApi.uploadFileList(formdata).then(res =&gt; { console.log(res); const resData = res.data.data; /** * 例如：返回数据为 res = [[pos, url], [pos, url]...] * pos 为原图片标志（0） * url 为上传后图片的url地址 */ // 第二步.将返回的url替换到文本原位置![...](0) -&gt; ![...](url) for (var i = 0; i &lt; resData.length; i++) { this.$refs.md.$img2Url(i + 1, resData[i]); } }); } 然后在需要上传的时候调用一下这个方法就可以啦 四、后台进行上传4.1Controller123456789101112131415/** * 文章多文件上传 * @param files * @return 返回图片地址 */ @PostMapping(value = \"/files\",produces = MediaType.APPLICATION_JSON_UTF8_VALUE) public Result uploadMultiFiles(@RequestParam(\"files\") MultipartFile[] files){ try { List&lt;String&gt; resultList = uploadService.uploadMultiFiles(files); return new Result(true,StatusCode.OK,\"上传成功\",resultList); }catch (Exception e){ return new Result(false,StatusCode.ERROR,\"啊哦~图片上传出现了点小错误，请稍后再上传\"); } } 4.2、Service123456789101112131415161718192021222324252627282930313233343536/** * 批量上传 * @param files */ public List&lt;String&gt; uploadMultiFiles(MultipartFile[] files) { List&lt;String&gt; resultList=new ArrayList&lt;&gt;(); for (MultipartFile file : files) { try { //校验文件内容 BufferedImage image = ImageIO.read(file.getInputStream()); if (image == null) { throw new MyException(ExceptionEnum.INVALID_FILE_TYPE); } //获取拓展名 String extension = StringUtils.substringAfterLast(file.getOriginalFilename(), \".\"); //上传到FastDFS StorePath storePath = storageClient.uploadFile(file.getInputStream(), file.getSize(), extension, null); //不加http://前端无法显示 resultList.add(\"http://\"+uploadProperties.getBaseUrl() + storePath.getFullPath()); //返回路径 } catch (IOException e) { //上传失败 LOGGER.error(\"[文件上传]文件\"+file.getOriginalFilename()+\"上传失败!\", e); throw new MyException(ExceptionEnum.UPLOAD_FILE_ERROR); } } return resultList; } Fdfs的相关配置在这篇文章写啦(不好意思比较懒)：https://blog.csdn.net/weixin_43696529/article/details/102727220","link":"/posts/20200106-mavon_boot_fdfs.html"},{"title":"冒泡排序---------java实现","text":"一、冒泡排序 平均时间复杂度: O(n²)最差时： O(n²)是否稳定： 稳定空间开销：O（1）适合n较小时 原始数组：3 ， 9， -1， 8, 2 第一趟排序：（1） 3， 9， -1， 8，2（2） 3， -1， 9，8， 2（3） 3， -1， 8， 9， 2（4）3， -1， 8， 2， 9 9确定 第二趟排序：（1）-1，3， 8， 2， 9（2）-1, 3， 8， 2， 9（3）-1，3，2， 8， 9 8 , 9确定第三趟排序：（1）-1，3 ，2 ，8 ， 9（2）-1， 2， 3 ，8 ，9 3， 8， 9确定第四趟排序：（1）-1， 2， 3， 8， 9 (2， 3， 8， 9确定) 实现： 123456789101112131415161718int[] array = {3, 9, -1, 8, 2}; int temp=0; for (int i=0; i&lt; array.length-1;i++){ System.out.println(\"开始第\"+(i+1)+\"趟排序\"); for (int j=0;j&lt;array.length-1-i;j++){ if (array[j]&gt;array[j+1]){ temp=array[j]; array[j]=array[j+1]; array[j+1]=temp; } System.out.println(Arrays.toString(array)); } System.out.println(\"第\"+(i+1)+\"趟排序结果：\"); System.out.println(Arrays.toString(array)); System.out.println(\"------------------\"); } 结果：1234567891011121314151617181920212223242526开始第1趟排序[3, 9, -1, 8, 2][3, -1, 9, 8, 2][3, -1, 8, 9, 2][3, -1, 8, 2, 9]第1趟排序结果：[3, -1, 8, 2, 9]------------------开始第2趟排序[-1, 3, 8, 2, 9][-1, 3, 8, 2, 9][-1, 3, 2, 8, 9]第2趟排序结果：[-1, 3, 2, 8, 9]------------------开始第3趟排序[-1, 3, 2, 8, 9][-1, 2, 3, 8, 9]第3趟排序结果：[-1, 2, 3, 8, 9]------------------开始第4趟排序[-1, 2, 3, 8, 9]第4趟排序结果：[-1, 2, 3, 8, 9]------------------ 总结：1.共进行数组大小-1次循环2.每次排序的次数逐渐减少 优化：若一趟排序中没有一次交换，则停止循环增加标志变量flag=false，发生交换时，置flag为true，一次循环后判断flag，若为true，则重置flag为false继续循环，否则break； 1234567891011121314151617181920212223242526272829int[] array = {3, 9, -1, 8, 2}; boolean flag=false; int temp=0; for (int i=0; i&lt; array.length-1;i++){ System.out.println(\"开始第\"+(i+1)+\"趟排序\"); for (int j=0;j&lt;array.length-1-i;j++){ if (array[j]&gt;array[j+1]){ temp=array[j]; array[j]=array[j+1]; array[j+1]=temp; flag=true; } System.out.println(Arrays.toString(array)); } System.out.println(\"第\"+(i+1)+\"趟排序结果：\"); System.out.println(Arrays.toString(array)); System.out.println(\"------------------\"); if (!flag){ //未发生一次交换，flag为false break; }else { //发生了交换，flag被置为true flag=false; //重置flag，继续循环 } } 这里因为数据原因仍然执行了4次可以换一组数据:{3,9,-1,8,10}结果： 123456789101112131415161718192021开始第1趟排序[3, 9, -1, 8, 10][3, -1, 9, 8, 10][3, -1, 8, 9, 10][3, -1, 8, 9, 10]第1趟排序结果：[3, -1, 8, 9, 10]------------------开始第2趟排序[-1, 3, 8, 9, 10][-1, 3, 8, 9, 10][-1, 3, 8, 9, 10]第2趟排序结果：[-1, 3, 8, 9, 10]------------------开始第3趟排序[-1, 3, 8, 9, 10][-1, 3, 8, 9, 10]第3趟排序结果：[-1, 3, 8, 9, 10]------------------ 可以看到只执行了三次排序 测试十万条数据执行时间:12345678910111213//创建50000个随机数组 int[] array =new int[100000]; for (int i=0;i&lt;100000;i++){ array[i]=(int)(Math.random()*100000); } long begintime=System.currentTimeMillis(); System.out.println(\"开始时间\"+begintime); bubbleSort(array); long endtime=System.currentTimeMillis(); System.out.println(\"结束时间\"+endtime); System.out.println(\"用时：\"+(endtime-begintime)+\"ms\"); 结果： 123开始时间1572061280770结束时间1572061302883用时：22113ms 当然每次执行时间不一样，但当数据大的时候总体效率还是很低的","link":"/posts/20200107-bubbleSort.html"},{"title":"基数排序-------------java实现","text":"一、基本思想1.基数排序(Radix Sort)属于分配式排序（distribution sort），又称”桶子法”(Bucket Sort或Bin Sort)，它是通过键值的各个位的值，将要排序的元素分配至某些“桶”中，达到排序的作用。2.基数排序属于稳定的排序，基数排序法的是效率高的稳定性排序法 3.基数排序(Radix Sort)是桶排序的扩展4.将所有待比较数值统一为同样的数位长度，数位较短的数前面补零。然后，从最低位开始，依次进行一次排序。这样从最低位排序一直到最高位排序完成以后, 数列就变成一个有序序列。 平均时间复杂度： O(n+k) 最优情况： O(n+k) 最坏情况： O(n²) 空间复杂度: O(n+k) 稳定性： 稳定 二、举例说明现有一组数据：{43,3,535,738,14,21,0} 第一轮排序： 第1轮排序后：0,21,43,4,14,535,738 第二轮排序：第二轮排序结果：0,4，14,21,535,738,43 第三轮排序：第三轮排序结果：0,4，14,21,43,535,738 三、代码实现1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768package com.wml.sort;import java.util.Arrays;/** * @author MaoLin Wang * @date 2019/10/3012:53 */public class RadixSort { public static void main(String[] args) { int[] arr={53,3,542,748,14,21,0}; radixSort(arr); } public static void radixSort(int[] arr){ //求最大数的位数 int max = arr[0]; for (int i = 1;i &lt; arr.length; i++){ if (arr[i] &gt;max){ max = arr[i]; } } //得到最大数的位数 int maxLength = (max+\"\").length(); //为防止数据溢出，应将列数设为数组长度 int [][] bucket=new int[10][arr.length]; //记录每个桶中实际存放了多少数据 int[] bucketElementCounts=new int[10]; /** * n代表位数，初始化为1，代表个位 */ for (int i=0 ,n = 1;i&lt; maxLength;i++,n *=10){ for (int j=0;j&lt;arr.length;j++){ //取出个位的值 int value= arr[j] /n %10; //放入个位值为value的桶的第bucketElementCounts[value]个位置，刚开始bucketElementCounts[value]为0，每放入一个数据就+1 bucket[value][bucketElementCounts[value]]=arr[j]; bucketElementCounts[value]++; } int index = 0;//原始数组下边，初始为0 // System.out.println(Arrays.toString(bucketElementCounts)); //遍历每个桶，将桶中数据放回原来数组 for (int k=0;k&lt;bucketElementCounts.length;k++){ //第k个桶 不等于0，即该桶有数据 if (bucketElementCounts[k] !=0){ //遍历该桶数据，放入原数组 for (int m=0;m&lt;bucketElementCounts[k];m++){ //取出元素放到arr arr[index++] = bucket[k][m]; } } //第i+1轮处理后，需要将每个bucketElementCounts[k] = 0 bucketElementCounts[k]=0; } System.out.println(\"第\"+(i+1)+\"轮结果\"+ Arrays.toString(arr)); } }} 结果：第1轮结果[0, 21, 542, 53, 3, 14, 748]第2轮结果[0, 3, 14, 21, 542, 748, 53]第3轮结果[0, 3, 14, 21, 53, 542, 748] 测试80w条数据耗时12345678910111213int[] arr =new int[800000]; for (int i=0;i&lt;800000;i++){ arr[i]=(int)(Math.random()*800000); } long begintime=System.currentTimeMillis(); System.out.println(\"开始时间\"+begintime); radixSort(arr); long endtime=System.currentTimeMillis(); System.out.println(\"结束时间\"+endtime); System.out.println(\"用时：\"+(endtime-begintime)+\"ms\"); 结果：开始时间1572416316975结束时间1572416317084用时：109ms 很明显比之前的归并、快速排序都快的多，但是其缺点也是很明显的，对于任何位数上的基数进行“装桶”操作时，都需要n+k个临时空间(k为桶数)，非常耗费空间","link":"/posts/20200107-jishuSort.html"},{"title":"希尔排序-----------java实现","text":"首先看一下之前使用简单插入排序存在的问题： 当存在一个数组，其最后一个数据为最小值，如：arr={5,6,16,34,33,2} 这样的话需要循环到最后一次，也就是第6次的时候，才可以将2排到前边，效率非常低 但是希尔排序可以很好的解决这个问题，其是简单插入排序改进后的一个效率较高的排序方式，也叫缩小增量排序 复杂度： 平均时间： O（nlogn） 最差: O(n²) 最优: O(n^1/3) 空间复杂度：O(1) 稳定性： 不稳定 一、基本思想希尔排序按某个增量分组，对每个分组使用直接插入排序实现，随着增量逐渐减小，每组数据逐渐增加，当增量减少至1时，仅剩下完整的一组，排序结束。 二、排序分析) 图片引用自https://blog.csdn.net/qq_28081081/article/details/80598960 三、代码实现1234567891011121314151617181920212223242526272829303132/** * 希尔排序 * @author MaoLin Wang * @date 2019/10/2817:43 */public class ShellSort { public static void main(String[] args) { int[] arr={214,32,11,2,3,2,66,33,54,12}; shellSort(arr); } public static void shellSort(int[]arr){ int temp=0; int count=0; for (int group =arr.length/2;group&gt;0;group/=2){ for (int i=group;i&lt;arr.length;i++){ for (int j=i-group;j&gt;=0;j-=group){ if (arr[j]&gt;arr[j+group]){ temp=arr[j]; arr[j]=arr[j+group]; arr[j+group]=temp; } } } System.out.println(\"第\"+(++count)+\"次排序结果：\"); System.out.println(Arrays.toString(arr)); } }} 结果： 123456第1次排序结果：[2, 32, 11, 2, 3, 214, 66, 33, 54, 12]第2次排序结果：[2, 2, 3, 12, 11, 32, 54, 33, 66, 214]第3次排序结果：[2, 2, 3, 11, 12, 32, 33, 54, 66, 214] 测试100000条数据耗时： 123456789101112int[] arr =new int[100000];for (int i=0;i&lt;100000;i++){ arr[i]=(int)(Math.random()*100000);}long begintime=System.currentTimeMillis();System.out.println(\"开始时间\"+begintime);shellSort(arr);long endtime=System.currentTimeMillis();System.out.println(\"结束时间\"+endtime);System.out.println(\"用时：\"+(endtime-begintime)+\"ms\"); 结果： 123开始时间1572260920132结束时间1572260930389用时：10257ms 发现用了10000多ms，不但没有提高效率，反而低了非常多，这是为什么呢？ 仔细看我们的代码进行交换的条件，发现只要满足arr[j]&gt;arr[j+group]就要进行交换，无疑增加了系统开销 接下来对代码进行优化： 123456789101112131415161718192021222324252627282930313233public static void shellSort2(int arr[]) { for (int group = arr.length / 2; group &gt; 0; group /= 2) { for (int i = group; i &lt; arr.length; i++) { int j = i; int temp = arr[j]; if (arr[j] &lt; arr[j - group]) { while ((j - group) &gt;= 0 &amp;&amp; temp &lt; arr[j - group]) { /** * 开始移动，将比arr[j]大的arr[j-group]、arr[j-group-group]......按顺序移动到后一个增量的位置 * 如 3, 2, 11, 21, 66, 32, 214, 4 * 在group减少到2，比较32和4的时候 * 1. 4&lt;32 且满足while条件， 所以将32移动到4,temp=4，j=5，指向32的位置 * 此时的数据为:3, 2, 11, 21, 66, 32, 214, 32 * 2.继续while循环 * j-group=3&gt;0 temp=4&lt;arr[3]=21，满足while条件 * 执行arr[j]=arr[j-group] -&gt; 将21的位置移动到32,temp仍然为一开始的4,j=3，指向21的位置 * 此时数据为：3, 2, 11, 21, 66, 21, 214, 32 * 3.继续循环while * j-group=1&gt;0 temp=4&gt;arr[1]=2 不满足while条件，退出循环 * 4.此时j=3，将temp=4赋值给arr[j] * 此时数据为：3, 2, 11, 4, 66, 21, 214, 32 */ arr[j] = arr[j - group]; j -= group; } //结束while循环后，将temp插入到arr[j] arr[j] = temp; } } } } 同样测试10000条数据排序的耗时： 123开始时间1572264172662结束时间1572264172692用时：30ms 耗时从1w多ms减小到30ms，多次测试上下波动也不会超过20ms","link":"/posts/20200107-shellSort.html"},{"title":"归并排序-------------java实现","text":"归并排序采用分治策略实现 平均时间复杂度 : O（nlogn） 最差时间复杂度: O(nlogn) 稳定性： 稳定 空间复杂度：O(n) 归并排序时以空间换时间的排序方法，空间消耗很大，一般内部排序使用快速排序较多 假设有这样一组数据：[10,4,8,7,1,3,2,9] 一、分) 如上将8个数组分成8个单独的数据 二、合1.将 10和 4合并 ) 2.将8和7合并 ) 3. 将4,10和7,8合并 )、 4.同样将右半部分也按此合并得到如下两组数据 ) 5.最后将两组数据合并在一起 ) 三、代码实现12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879package com.wml.sort;import java.util.Arrays;/** * @author * @date 2019/10/2919:17 */public class MergeSort { public static void main(String[] args) { int arr[] = {10,4,8,7,1,3,2}; int[] temp=new int[arr.length]; mergeSort(arr,0,arr.length-1,temp); System.out.println(Arrays.toString(arr)); } public static void mergeSort(int[] arr,int left,int right,int[] temp){ if (left &lt; right){ int mid= (left + right ) / 2; //向左递归分解 mergeSort(arr,left,mid,temp); //向右递归分解 mergeSort(arr,mid+1,right,temp); //合并 merge(arr,left,right,mid,temp); } } /** * * @param arr 待排序数组 * @param left 左边有序序列的初始索引 * @param right 右边索引 * @param mid * @param temp 临时数组 */ public static void merge(int[] arr,int left, int right,int mid,int[] temp){ int l = left; //初始化i，左边有序序列的初始索引 int r = mid+1; //右边有序序列的初始索引 int current = 0; // 指向临时数组的当前索引 //1.先把左边两边的有序数据按规则填充到临时数组，直到任意一方处理完毕 while ( l&lt;= mid &amp;&amp; r &lt;= right){ if (arr[l] &lt;= arr[r]){ //当前左边的元素小于等于右边的，将左边的数据拷贝到临时数组 temp[current] = arr[l]; current +=1; //current后移 l +=1; //左边指针右移 }else { //右边的元素移到临时数组 temp[current] = arr[r]; current += 1; r +=1; } } //2.将有剩余的一边全部移动到临时数组 while ( l &lt;= mid){//左边有剩余 temp[current] = arr[l]; current+=1; l+=1; } while ( r &lt;= right){//右边有剩余 temp[current] = arr[r]; current+=1; r+=1; } //3.将临时数组拷贝到原始数组 current = 0; int tempLeft=left; while (tempLeft &lt;= right){ arr[tempLeft] = temp[current]; current+=1; tempLeft +=1; } }} 结果： [1, 2, 3, 4, 7, 8, 10]","link":"/posts/20200107-guibingSort.html"},{"title":"快速排序-------------java实现","text":"一、基本思想选择一个基准数，通过一趟排序将待排序数据分成两个独立的部分，其中一部分的所有数都比基准数小，另一部分都比基准数大，然后再使用此方法递归对两部分数据进行快排，最终实现整个数据的有序。 二、详解排序过程现有待排序数据： 1{-21, 312, 44, 11, -23, 2, 10}; 蓝色为左哨兵，记为left，黄色为右哨兵记为right，红色为基数 基数=(左哨兵坐标+右坐标)/2 第一轮排序： ​ ↓ ↓ ​ -21， 312， 44， 11， -23， 2， 10 ​ 左哨兵找到第一个比基数11大的数停止，即在312停止，此时left=1 ​ 右哨兵找到第一个比基数小的数停止，即在10停止，此时right=6 ​ 此时两个哨兵尚未相遇，交换 312 和 10 交换后： ​ ↓ ↓ ​ -21， 10， 44， 11， -23， 2， 312 左哨兵继续移动，到比11大的44时停止，此时left=2 右哨兵继续移动，到比11小的2处停止，此时right=5 两个哨兵仍然未相遇 ，不需要break；交换 44 和 2 交换后： ​ ↓ ↓ ​ -21， 10， 2， 11， -23， 44， 312 左哨兵继续移动，到基数11停止，因为左边已经没有比11小的数了，此时left=3 右哨兵继续移动，到比 11小的 -23处停止，此时right = 4 交换11 和-23 交换后： ​ ↓ ↓ ​ -21， 10， 2， -23， 11， 44， 312 此时再继续移动，两个哨兵相遇，一轮结束 当哨兵相遇时，让right–，left++，分别指向-23 和44 此时左半部分为：-21, 10, 2, -23 left为-21，right为-23 右半部分为： 44， 312 left为44，right为312 两边继续按上述步骤递归排序 三、代码实现：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667/** * 快速排序 * @author * @date 2019/10/2917:06 */public class QuickSort { public static void main(String[] args) { int[] arr={-21,312,44,11,-23,2,10}; quickSort(arr,0,arr.length-1); System.out.println(Arrays.toString(arr)); } public static void quickSort(int[] arr, int left, int right) { int l = left; int r = right; //基准数 int pivot = arr[(left + right) / 2]; int temp=0;//临时变量 //让比基数小的放在左边，比基数大的放在右边 while (l &lt; r){ //在基数左边找到大于等于基数的值才退出 while (arr[l] &lt; pivot){ l += 1; } //在基数右边找到小于等于基数的值才退出 while (arr[r] &gt; pivot){ r -=1; } //左右两个哨兵相遇，即说明基数左边的数已经全部小于基数，右边的数已经全部大于基数 if( l &gt;= r){ break; } //否则进行交换 temp = arr[l]; arr[l] = arr[r]; arr[r] = temp; //如果交换完后，发现arr[l] == 基数，r向左移 if (arr[l] == pivot){ r -= 1; } //如果交换完后，发现arr[r] == 基数，l向右移 if (arr[r] == pivot){ l += 1; } } if (l == r){ l +=1; r -=1; } //向左递归 if (left&lt;r){ quickSort(arr,left,r); } //向右递归 if (right &gt; l){ quickSort(arr,l,right); } }} 结果： [-23, -21, 2, 10, 11, 44, 312] 四、测试10W条数据耗时123456789101112int[] arr =new int[100000];for (int i=0;i&lt;100000;i++){ arr[i]=(int)(Math.random()*100000);}long begintime=System.currentTimeMillis();System.out.println(\"开始时间\"+begintime);quickSort(arr,0,arr.length-1);long endtime=System.currentTimeMillis();System.out.println(\"结束时间\"+endtime);System.out.println(\"用时：\"+(endtime-begintime)+\"ms\"); 结果： 123开始时间1572344644967结束时间1572344645031用时：64ms 此时与希尔排序看不出很大的差距，将数据增加到80W条测试结果： 希尔： 开始时间1572344777821结束时间1572344778134用时：313ms 快速： 开始时间1572344758536结束时间1572344758711用时：175ms 经过多次测试，偶尔会有希尔排序比快速快的情况，但是多数情况下还是快速比希尔快","link":"/posts/20200107-quickSort.html"},{"title":"插入排序-----------java实现","text":"一、复杂度12345平均时间复杂度： O(n²)最差时： O(n²)是否稳定： 稳定空间开销： O(1)在大部分数据已经排好序时性能较好 二、基本思想将n个待排序元素看成一个有序表和一个无序表，开始有序表只有一个元素，每次排序从无需表中取第一个元素，将它的值依此和有序表元素的数据比较，插入到有序表的适当位置，形成新的有序表 详解： 初始数据：18, 5, 54, 2, 33, 12 第一次排序：5， 18， 54， 2， 33，12 第二次排序：2，5， 18， 54， 33，12 第三次排序：2，5，12 18， 54， 33 第四次排序：2，5，12 18，33， 54 第五次排序：2，5，12 18，33，54 三、代码实现12345678910111213141516171819202122232425262728293031323334353637/** * 插入排序 * @author ** * @date 2019/10/2816:55 */public class InsertSort { public static void main(String[] args) { int[] arr= {213,43,22,11,324,11,4}; insertSort(arr); } public static void insertSort(int[] arr){ for (int i=1;i&lt;arr.length;i++){ //待插入数据 int insertVal=arr[i]; //待插入位置下标 int insertIndex=i-1; /** * 如果待插入下标小于零，说明待插入数据最小，应放在第一个位置 * 如果待插入值大于arr[inserIndex]，则停止循环，说明待插入值在有序表中是最大的，应插入到当前insertIndex后一个位置 */ while (insertIndex&gt;=0 &amp;&amp; insertVal&lt;arr[insertIndex]){ arr[insertIndex+1]=arr[insertIndex]; insertIndex--; } arr[insertIndex+1]=insertVal; System.out.println(\"第\"+i+\"次排序结果：\"); System.out.println(Arrays.toString(arr)); } }} 结果： 123456789101112第1次排序结果：[43, 213, 22, 11, 324, 11, 4]第2次排序结果：[22, 43, 213, 11, 324, 11, 4]第3次排序结果：[11, 22, 43, 213, 324, 11, 4]第4次排序结果：[11, 22, 43, 213, 324, 11, 4]第5次排序结果：[11, 11, 22, 43, 213, 324, 4]第6次排序结果：[4, 11, 11, 22, 43, 213, 324] 四、测试100000条数据耗时123456789101112131415161718192021222324252627282930313233343536373839404142434445464748package com.wml.sort;import java.util.Arrays;/** * @author *** * @date 2019/10/2816:55 */public class InsertSort { public static void main(String[] args) { int[] array =new int[100000]; for (int i=0;i&lt;100000;i++){ array[i]=(int)(Math.random()*100000); } long begintime=System.currentTimeMillis(); System.out.println(\"开始时间\"+begintime); insertSort(array); long endtime=System.currentTimeMillis(); System.out.println(\"结束时间\"+endtime); System.out.println(\"用时：\"+(endtime-begintime)+\"ms\"); } public static void insertSort(int[] arr){ for (int i=1;i&lt;arr.length;i++){ //待插入数据 int insertVal=arr[i]; //待插入位置下标 int insertIndex=i-1; /** * 如果待插入下标小于零，说明待插入数据最小，应放在第一个位置 * 如果待插入值大于arr[inserIndex]，则停止循环，说明待插入值在有序表中是最大的，应插入到当前insertIndex后一个位置 */ while (insertIndex&gt;=0 &amp;&amp; insertVal&lt;arr[insertIndex]){ arr[insertIndex+1]=arr[insertIndex]; insertIndex--; } arr[insertIndex+1]=insertVal; } }} 结果： 123开始时间1572254640158结束时间1572254641586用时：1428ms 相比上一篇的选择排序的5811ms总体又快了许多","link":"/posts/20200107-insertSort.html"},{"title":"选择排序  ------java实现","text":"一、选择排序的思想第一次从arr[0]~arr[n-1]中选取最小值与arr[0]交换，第二次从arr[1]到arr[n-1]中选取最小值与arr[1]交换，第三次从arr[2]到arr[n-1]中选取最小值与arr[2]交换，以此类推，总共循环n-1次，得到一个从小到大的有序序列。 二、思路详解待排序元素： [34] 54 123 55 11 22 第一次排序： [11,34] 54 123 55 22第二次排序 : [11,22,34] 54 123 55第三次排序： [11,22,34,54] 123 55第四次排序： [11,22,34,54,55] 123 说明(这里按从小到大)： 1.选择排序共进行数组大小-1次排序2.每次排序中，先设当前的数是最小值，然后依次和后面的数进行比较，如果发现有比这个数小的，就让最小的数为这个数，得到最小值下标，遍历一个循环后，得到最小值和下标3.如果该小标与一开始的不一样，说明存在比开始设定的最小的数还小的数，将二者交换，进行下一次循环 三、代码实现12345678910111213141516171819202122232425public static void selectSort(int[] arr){ for (int i=0;i&lt;arr.length-1;i++){ int minIndex=i; int min=arr[i]; for (int j=i+1;j&lt;arr.length;j++){ if (min&gt;arr[j]){ min=arr[j]; minIndex=j; } } //将最小值放在arr[0]。即交换 if (minIndex!=i){ arr[minIndex]=arr[i]; arr[i]=min; } System.out.println(\"第\"+(i+1)+\"轮后结果\"); System.out.println(Arrays.toString(arr)); } } public static void main(String[] args) { int[] array={101,222,119,1}; SelectSort.selectSort(array); } 结果： 123456第1轮后结果[1, 222, 119, 101]第2轮后结果[1, 101, 119, 222]第3轮后结果[1, 101, 119, 222] 测试100000条数据执行时间： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748package com.wml.sort;import java.util.Arrays;/** * 选择排序 * @author MaoLin Wang * @date 2019/10/2811:24 */public class SelectSort { public static void main(String[] args) { //int[] array={101,222,119,1}; int[] array =new int[100000]; for (int i=0;i&lt;100000;i++){ array[i]=(int)(Math.random()*100000); } long begintime=System.currentTimeMillis(); System.out.println(\"开始时间\"+begintime); SelectSort.selectSort(array); long endtime=System.currentTimeMillis(); System.out.println(\"结束时间\"+endtime); System.out.println(\"用时：\"+(endtime-begintime)+\"ms\"); } public static void selectSort(int[] arr){ for (int i=0;i&lt;arr.length-1;i++){ int minIndex=i; int min=arr[i]; for (int j=i+1;j&lt;arr.length;j++){ if (min&gt;arr[j]){ min=arr[j]; minIndex=j; } } //将最小值放在arr[0]。即交换 if (minIndex!=i){ arr[minIndex]=arr[i]; arr[i]=min; } //System.out.println(\"第\"+(i+1)+\"轮后结果\"); //System.out.println(Arrays.toString(arr)); } }} 结果：用时： 123开始时间1572251978745结束时间1572251984556用时：5811ms 相比上一篇冒泡排序的22113ms快了许多 平均时间： O(n²)最差： O（n²）是否稳定： 不稳定空间复杂度： O（1）备注： n小时较好","link":"/posts/20200107-selectSort.html"},{"title":"Linux命令整理-------------文件管理相关(一)","text":"cat说明：用来显示文本内容(小文件)，对于大文件推荐使用more命令 格式： cat +选项+指定文件 ​ 选项： 123&gt; -n 或 --number：显示行号；&gt; -b 或 --number-nonblank：编号时忽略空白行&gt; -A：显示不可打印字符，行尾显示“$”； 如： 1234567echo xxx&gt;test 若test不存在，则自动创建test并写入xxx，否则直接写入cat 123.txt 屏幕显示123.txt内容cat 文本1 文本2 ... 显示多个文本内容cat 文本1 文本2 &gt; 文本3 将文本1和2的内容合并到文本3中cat 文本1 &gt; 文本2 将文本1内容拷贝到文本2cat /dev/null &gt; 文本1 清空文本1的内容cat &gt;test1.txt &lt;&lt;stop 向test1.txt写入内容，输入stop结束 注意：每次合并时，文本3的内容会被重新覆盖 more全屏幕显示文本文件内容 选项：12345-数字：每屏显示指定行-c：不进行滚屏操作。每次刷新这个屏幕；-s：将多个空行压缩成一行显示；-u：禁止下划线；+数字：从指定数字的行开始显示。 查看时可用命令： Space键：显示文本的下一屏内容。 Enter键：每次刷新一行 H键：显示相关的帮助信息 B键：查看上一屏 q键：退出 ​​ cd1.cd : 进入目录 2.cd ~: 进入用户目录 3.cd - : 进入历史上一级目录，即进此目录之前的那个目录 4.cd .. ：返回上级目录 cd ../../ 有几个.../就返回上几级目录 ls 显示目标列表 选项 -a 显示所有文件（在linux中以.开头的文件为隐藏文件） -l 显示文本的详情包括(权限、拥有者、文件大小、最后修改时间等) -r 将文件反序显示(默认按照英文字母顺序) -t 按照创建时间列出 -A 同 -a ，但不列出 &quot;.&quot; (目前目录) 及 &quot;..&quot; (父目录) -F 在文件名称后加一个符号： *：代表可执行档 /： 代表目录 -R 有文件的目录，也会将其子文件列出 ​ -R举例： -F举例：test2是一个目录。所以在后边显示了一个/ pwd 显示当前工作目录（绝对路径） head 显示指定文件前N行 选项： -n：指定显示前n行 -v：显示文件名的头信息； -q：不显示文件名的头信息。 tail 显示指定文件的末尾N行，默认10行 选项： -c,–bytes=：显示文件尾部的N（N为整数）个字节内 -f&lt;name/descriptor&gt;：动态显示文件尾部内容，如某个动态更新的日志，可以使用-f查看最新的内容 -n：输出文件的尾部N（N位数字）行内容。 –pid=&lt;进程号&gt;：与“-f”选项连用，当指定的进程号的进程终止时退出该命令-q,–quiet,–silent：当有多个文件参数时，不输出各个文件名； -s&lt;秒数&gt;,–sleep-interal=&lt;秒数&gt;：与“-f”连用，指定文件变化时间隔(s) -v,–verbose：当有多个文件参数时，总是输出各个文件名； –help：帮助信息 –version：指令版本 举例： 12345tail test 不指定行数默认显示文件test的最后10行tail -n +10 test 从第10行到最后tail -c 10 test 显示该文件的最后10个字符tail -25 nginx.log 显示最后的 25 行tail -f nginx.log 动态刷新该文件最后的内容 chmod修改文件或目录的权限 权限范围：u: –&gt; User ，当前文件/目录的拥有者g: –&gt; Group ， 所属组o: –&gt; Other ， 除User和所属群组之外的所有用户a: –&gt; All ， 所有用户r: –&gt; 读权限，数字 4w:–&gt; 写权限，数字 2x: 执行/切换权限，数字 1- 无权限，数字 0 语法： chmod [options][参数] 选项： 1234567891011121314151617+ 添加某些权限- 取消某些权限= 指定文件权限r 读权限w 写权限x 可执行权限- 无权限X 给可执行文件设置可执行权限t 只有目录或文件的所有者才可以删除目录下的文件-c ,--changes 效果类似“-v”参数，但仅回报更改的部分，如果文件权限已经改变，显示其操作信息；-f , --quiet, --silent 操作过程中不显示任何错误信息；-R, --recursive 以递归更改其本身及子目录-v, --verbose 显示详情信息--reference=&lt;参考文件或目录&gt; 指定参考文件，非自定义权限--help 显示帮助信息--version 显示版本信息 权限结构： 1-rwxr--r-- 1 user staff 651 Nov 11 11:02 .ignore 第一个 -: 代表是普通文件，若是 d，则代表目录 第一组rwx：即上边的rw-,表示u属组 第二组rwx: 即上边中间的r–，表示g属组 第三组rwx: 即上边最后的r–， 表示其他人的权限 r:读 4 w：写 2 x：执行 1 举例: 1234567chmod u+w,g+r test1 为test1设置当前用户可写，组可读的权限chmod u=rwx,g=rw,o=r test1 当前用户可读写执行，组可读写，其他用户只能读chmod 764 test1 当前用户读写执行，组读写，其他只可读chmod a+r test1 所有用户都只可读test1chmod ugo-r test1 所有用户减掉可读权限 chmod -R 755 /usr/local/test/ 递归修改test目录下的子文件的权限为 755,7即4+2+1，5即4+1chown john:student test1 把test1给John，添加到student组 chown 改变文件或目录的拥有者或所属群组 可以给某个用户授权，使该用户变成指定文件的所有者或者改变文件所属的组。 语法： chown [options][参数] 选项： 12345-c，--changes：显示修改的部分；-f ：不显示错误信息；-h：只对符号连接的文件作修改，而不更改其他任何相关文件；-R：递归处理指定目录下的所有文件及子目录-v：显示指令执行过程信息 123chown -R wml:mygroup /usr/local/test1 将/usr/local/test下面的所有文件以及子目录的文件拥有者改为wml,群组为mygroup - ## cmp 比较两个二进制文件是否有差异，若无差异则不显示任何信息，若有差异则显示第一个不同的地方的字符和列数 **语法：** cmp [options][参数] **选项：** 12-l：对于每处不同，显示十进制的字节数和八进制的不同字节。；-s，--quit，--silent：不显示错误信息； **举例:** 123.txt ： 我是123 222 222.txt: 我是222 222 1cmp 123.txt 222.txt --结果--&gt;123.txt 222.txt differ: byte 1, line 1 - ## diff 比较两个文件的不同，该命令是采取逐行比较的方式， **选项：** 12345678910111213-&lt;行数&gt;：指定显示多少行的文本-a，--text：将文件当做文本文件处理-b：忽略空格字符造成的不同；-B，--ignore-blank-lines：忽略空白行；-c：显示两个文件的全部内容，并标出不同之处-H，--speed-large-files：加速大文件检索-i，--ignore-case：忽略大小写不同-l或——paginate：分页-q或--brief：仅显示有无差异，不显示详细的信息 有不同的结果:Files 123.txt and 222.txt differ-r，--recursive：比较子目录中的文件-T：每行对齐输出-y：并列打印 举例： ![在这里插入图片描述](https://img-blog.csdnimg.cn/20191028231857879.png) - ## file 检测目标文件类型 **选项：** 1234-b：不显示文件名称L-L：直接显示符号连接所指向的文件类别；-v：显示版本信息；-z：尝试去解读压缩文件的内容。 **举例：** 123[admin@ test]$ file 123.txt 222.txt123.txt: UTF-8 Unicode text222.txt: UTF-8 Unicode text find查询指定目录下的文件选项： 123456789101112131415161718192021-depth：从指定目录的最深层的子目录开始查找-maxdepth&lt;目录深度&gt;：最大目录深度-mindepth&lt;目录深度&gt;：最小目录层级；-empty：查找大小为0 的文件或空目录-exec&lt;要执行的指令&gt;：若find指令返回True，就执行目标指令(如找到空的就执行rm删除目标文件)-fstype&lt;文件系统类型&gt;：只寻找该文件系统类型下的文件或目录；-ls：将文件或目录名称列出到标准输出(权限信息，所属用户、组，时间信息等)-name&lt;inputname&gt;，-iname：查询名称符合inputname的文件，-iname忽略大小写-anewer test : 比文件 file 更晚被读取过的文件-path&lt;testPath&gt;，-ipath&lt;testPath&gt;：路径符合testPath的文件,-ipath 忽略大小写-perm&lt;权限值&gt;：查找符合指定的权限数值的文件-print：将文件或目录名称列出到标准输出。格式为每列一个名称，每个名称前皆有“./”字符串；-printf&lt;输出格式&gt;：自定义格式输出-size&lt;文件大小&gt;：查找符合指定大小的文件-type&lt;文件类型&gt;：指定的文件类型的文件-user&lt;拥有者名称&gt;：指定用户拥有的文件 举例： 1.find. 列出当前目录的所有文件及其子文件 123456789 find . 结果：../333.txt./222.txt./test2./test2/123.txt./123.txt./empty.txt 2.find /usr/test -name “*.txt”：查找test目录下后缀名为txt的文件 1234567find /usr/test -name \"*.txt\"结果：/usr/test/333.txt/usr/test/222.txt/usr/test/test2/123.txt/usr/test/123.txt/usr/test/empty.txt 3.find /usr/test ! -name “*.txt”：查找test目录下后缀名不是txt的文件 4.根据文件类型查找 -type: 1find . -type 参数 类型参数： f ：普通文件 l ：符号连接 d ：目录 c ：字符设备 b ：块设备 s ：套接字 p ：Fifo 5.查找小于3k的文件 1find . -size -3k 结果： ./333.txt ./222.txt ./test2/123.txt ./123.txt ./empty.txt 6.查找大小为0的文件 12[root@ test] find -empty./empty.txt 7.查找指定权限的文件 首先给123.txt赋予77权限： 1chmod 777 123.txt 查看下结果： 12345-rwxrwxrwx 1 777 root 21 Oct 28 23:08 123.txt-rw-r--r-- 1 root root 15 Oct 28 22:57 222.txt-rw-r--r-- 1 root root 23 Oct 27 22:46 333.txt-rw-r--r-- 1 root root 0 Oct 29 15:20 empty.txtdrwxr-xr-x 2 root root 4096 Oct 27 19:52 test2 只有123.txt的权限为777, 执行查找： 1find -perm 777 结果： 1./123.txt ​ 持续更新………","link":"/posts/20200106-linux_file_1.html"},{"title":"（复习）二叉树的三种遍历方式、查找和删除----------Java实现","text":"一、概念：二叉树二叉树的每个节点最多只能由两个子节点 性质： 二叉树的第 i 层最多有 2 ^ (i-1) 个节点 深度为 k （ k≥0 ）的二叉树最少有 k 个节点(一层一个)，最多有 （2^k ）-1 个节点 （空树k=0，只有一个根节点k=1） 对于任意一个非空二叉树，若其 叶子节点数为 n，度为2的非叶子节点数为 m，则 ==n=m+1==，（度 即节点所拥有的子树的个数） 如果节点总数为 2^n-1 且所有叶子节点都在最后一层，则该树为==满二叉树== 如果该二叉树的所有叶子节点都在最后一层或者倒数第二层，而且最后一层的叶子节点在左边连续，倒数第二层的叶子节点在右边连续，则称为==完全二叉树==。如下： 二、三种遍历方式2.1前序遍历根节点 —&gt; 左孩子 —&gt; 右孩子以上图为例，前序遍历结果为：11，21,14,81,91,15,31，61,71 2.2 中序遍历左孩子 –&gt; 根节点 —&gt; 右孩子 上图为例，结果为：81,14,91,21,15,11,61,31,71 2.3 后序遍历左孩子 –&gt; 右孩子 —&gt; 根节点 上图为例，结果为：81,91,14,15,21,61,71,31,11 三、代码实现遍历3.1首先创建TreeNode类作为数节点这里方便使用直接都设为了public 12345678910111213141516171819class TreeNode { public int no;//节点编号 public TreeNode lchild;//左孩子 public TreeNode rchild;//右孩子 public TreeNode() { } public TreeNode(int no) { this.no = no; } @Override public String toString() { return \"TreeNode{\" + \"no=\" + no + '}'; }} 3.2 创建二叉树类12345678//定义二叉树class BinaryTree { private TreeNode root; public void setRoot(TreeNode root) { this.root = root; }} 3.3 前序遍历方法： 1.首先输出根节点 2.左孩子非空时，递归遍历左孩子 3.右孩子非空时，递归遍历右孩子 1234567891011121314/** * 前序遍历： 根节点-&gt;左节点-&gt;右节点 */ public void preOrder() { System.out.println(this);//先输出父节点 //向左递归 if (this.lchild != null) { this.lchild.preOrder(); } //向右递归 if (this.rchild != null) { this.rchild.preOrder(); } } 3.4 中序遍历方法： 1.左孩子非空时，递归遍历左孩子 2.首先输出根节点 3.右孩子非空时，递归遍历右孩子 123456789101112131415/** * 中序遍历： 左节点-&gt;根节点-&gt;右节点 */ public void midOrder() { //向左递归 if (this.lchild != null) { this.lchild.midOrder(); } System.out.println(this);//输出根节点 //向右递归 if (this.rchild != null) { this.rchild.midOrder(); } } 3.5 后序遍历方法： 1.左孩子非空时，递归遍历左孩子 2.右孩子非空时，递归遍历右孩子 3.首先输出根节点 12345678910111213141516/** * 后序遍历： 左节点-&gt;右节点-&gt;根节点 */ public void postOrder() { //向左递归 if (this.lchild != null) { this.lchild.postOrder(); } //向右递归 if (this.rchild != null) { this.rchild.postOrder(); } System.out.println(this);//输出根节点 } 其实就是把输出根节点的位置按先中后的顺序换来换去 3.6 在二叉树中调用一下方法应先判断根节点是否为空，不为空时才遍历 123456789101112131415161718192021222324//前序遍历 public void preOrder(){ if (this.root!=null){ this.root.preOrder(); }else { System.out.println(\"二叉树为空\"); } } //中序遍历 public void midOrder(){ if (this.root!=null){ this.root.midOrder(); }else { System.out.println(\"二叉树为空\"); } } //后续遍历 public void postOrder(){ if (this.root!=null){ this.root.postOrder(); }else { System.out.println(\"二叉树为空\"); } } 测试按照一开始的那个图创建二叉树： 12345678910111213141516171819202122232425262728293031BinaryTree binaryTree=new BinaryTree(); //创建根节点 TreeNode root = new TreeNode(11); TreeNode treeNode2 = new TreeNode(21); TreeNode treeNode3 = new TreeNode(31); TreeNode treeNode4 = new TreeNode(14); TreeNode treeNode5 = new TreeNode(15); TreeNode treeNode6 = new TreeNode(61); TreeNode treeNode7 = new TreeNode(71); TreeNode treeNode8 = new TreeNode(81); TreeNode treeNode9 = new TreeNode(91); root.lchild =treeNode2; root.rchild =treeNode3; treeNode3.rchild =treeNode7; treeNode3.lchild =treeNode6; treeNode2.lchild =treeNode4; treeNode2.rchild =treeNode5; treeNode4.lchild =treeNode8; treeNode4.rchild =treeNode9; binaryTree.setRoot(root); System.out.println(\"中序-------\"); binaryTree.midOrder(); System.out.println(\"前序--------\"); binaryTree.preOrder(); System.out.println(\"后续--------\"); binaryTree.postOrder(); 结果： 123456789101112131415161718192021222324252627282930中序-------TreeNode{no=81}TreeNode{no=14}TreeNode{no=91}TreeNode{no=21}TreeNode{no=15}TreeNode{no=11}TreeNode{no=61}TreeNode{no=31}TreeNode{no=71}前序--------TreeNode{no=11}TreeNode{no=21}TreeNode{no=14}TreeNode{no=81}TreeNode{no=91}TreeNode{no=15}TreeNode{no=31}TreeNode{no=61}TreeNode{no=71}后续--------TreeNode{no=81}TreeNode{no=91}TreeNode{no=14}TreeNode{no=15}TreeNode{no=21}TreeNode{no=61}TreeNode{no=71}TreeNode{no=31}TreeNode{no=11} 四、三种遍历查询某个节点返回节点编号4.1 前序遍历方法：1.判断当前节点是否满足，满足的话返回该节点，不满足进行 22.判断当前节点的左孩子是否为空，不为空的话递归前序遍历左孩子3.判断当前节点的右孩子是否为空，不为空的话递归前序遍历右孩子实现： 1234567891011121314151617181920212223242526272829303132/** * 前序遍历查找 * @param no * @return */ public TreeNode preOrderFind(int no){ if (this.no==no){ return this; } TreeNode treeNode=null; /** * 判断当前当前节点的左孩子是否为空，不为空 -&gt; 递归前序遍历查找， * 若找到，就返回 */ if (this.lchild !=null){ treeNode=this.lchild.preOrderFind(no); } if (treeNode!=null){ return treeNode; } /** * 判断右孩子是否为空，不为空-&gt;递归前序遍历，无论找没找到都返回treeNode */ if (this.rchild !=null){ treeNode=this.rchild.preOrderFind(no); } return treeNode; } 4.2 中序遍历方法：将当前节点放在左孩子和右孩子中间就好了，其他同上实现： 1234567891011121314151617181920212223242526272829303132/** * 中序遍历查找 * @param no * @return */ public TreeNode midOrderFind(int no){ TreeNode treeNode=null; /** * 判断当前当前节点的左孩子是否为空，不为空 -&gt; 递归前序遍历查找， * 若找到，就返回 */ if (this.lchild !=null){ treeNode=this.lchild.midOrderFind(no); } if (treeNode!=null){ return treeNode; } if (this.no==no){ return this; } /** * 判断右孩子是否为空，不为空-&gt;递归前序遍历，无论找没找到都返回treeNode */ if (this.rchild !=null){ treeNode=this.rchild.midOrderFind(no); } return treeNode; } 4.3 后序遍历方法：将当前节点的比较放在最后就好了，其他同上实现： 1234567891011121314151617181920212223242526272829303132333435363738/** * 后序遍历查找 * @param no * @return */ public TreeNode postOrderFind(int no){ TreeNode treeNode=null; /** * 判断当前当前节点的左孩子是否为空，不为空 -&gt; 递归前序遍历查找， * 若找到，就返回 */ if (this.lchild !=null){ treeNode=this.lchild.postOrderFind(no); } if (treeNode!=null){ return treeNode; } /** * 判断右孩子是否为空，不为空-&gt;递归前序遍历，无论找没找到都返回treeNode */ if (this.rchild !=null){ treeNode=this.rchild.postOrderFind(no); } if (treeNode!=null){ return treeNode; } //左右孩子都没找到，找根节点 if (this.no==no){ return this; } return treeNode; } 4.4 二叉树调用查找方法12345678910111213141516171819202122232425262728293031323334353637/** * 前序遍历查找 * @param no * @return */ public TreeNode preOrderFind(int no){ if (root!=null){ return root.preOrderFind(no); }else { return null; } } /** * 中序遍历查找 * @param no * @return */ public TreeNode midOrderFind(int no){ if (root!=null){ return root.midOrderFind(no); }else { return null; } } /** * 后序遍历查找 * @param no * @return */ public TreeNode postOrderFind(int no){ if (root!=null){ return root.postOrderFind(no); }else { return null; } } 测试：查找6112345678910111213141516171819202122232425//前序遍历查找 System.out.println(\"前序遍历查找==============\"); TreeNode treeNode = binaryTree.preOrderFind(61); if (treeNode!=null){ System.out.println(\"找到了：编号为\"+treeNode.no); }else { System.out.println(\"没找到\"); } //中序遍历查找 System.out.println(\"中序遍历查找====================\") TreeNode midOrderFind = binaryTree.midOrderFind(61); if (midOrderFind!=null){ System.out.println(\"找到了：编号为：\"+midOrderFind.no); }else { System.out.println(\"没找到\"); } //后序遍历查找 System.out.println(\"后序遍历查找=============\"); TreeNode postOrderFind = binaryTree.postOrderFind(61); if (postOrderFind!=null){ System.out.println(\"找到了：编号为\"+postOrderFind.no); }else { System.out.println(\"没找到\"); } 结果： 123456前序遍历查找==============找到了：编号为61中序遍历查找====================找到了：编号为：61后序遍历查找=============找到了：编号为61 五、删除节点当节点为叶子节点时直接删除当节点为非叶子节点时连同其子树一起删除；(不删除子树的方法后续补充)方法：每次的比较对象为当前节点的左右孩子，当左孩子非空且编号与目标节点相同，让左孩子为null当右孩子非空且编号与目标节点相同，让右孩子为null当左右孩子非空时，递归遍历 12345678910111213141516171819/** * 递归删除 */ public void deleteNode(int no){ if (this.lchild !=null &amp;&amp; this.lchild.no==no){ this.lchild =null; return; } if (this.rchild !=null &amp;&amp;this.rchild.no==no){ this.rchild =null; return; } if (this.lchild !=null){ this.lchild.deleteNode(no); } if (this.rchild !=null){ this.rchild.deleteNode(no); } }","link":"/posts/20200107-binarytree.html"},{"title":"模拟先来先服务、短作业优先、时间片轮转以及最高响应比优先调度算法的JAVA实现","text":"这里记录一下操作系统的实验，几个调度算法的原理很好理解，网上也有很多解释，这里不再解释，直接上代码。 一、JCB类1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950public class JCB { public int id; /** * 剩余服务时间 */ public int leftTime; /** * 要求服务时间 */ public int serviceTime; /** * 到达时间 */ public int arriveTime; /** * 开始时间 */ public int beginTime; /** * 结束时间 */ public int finishTime; /** * 优先权 */ public float priority; public JCB(int id, int serviceTime, int arriveTime,float priority) { this.id = id; this.leftTime = serviceTime; this.serviceTime = serviceTime; this.arriveTime = arriveTime; beginTime =0; this.priority=priority; finishTime=0; } @Override public String toString() { return \"JCB{\" + \"id=\" + id + \", serviceTime=\" + serviceTime + \", arriveTime=\" + arriveTime + \", priority=\" + priority + '}'; }} 二、定义所需数据结构1234567891011121314151617181920212223242526272829303132333435363738394041424344454647/** * 时间片轮转算法 * * @author MaoLin Wang * @date 2019/11/3020:03 */public class SchedulingAlgorithm { /** * 就绪队列 */ LinkedList&lt;JCB&gt; readyQueue = null; /** * 结束调度队列 */ LinkedList&lt;JCB&gt; finishQueue = null; /** * 时间段 */ private int cpuTime; /** * 时间片大小 */ private int timeSize; /** * 作业数 */ private int jobNum; private String dispatchName;//调度算法名 /** * 作业周转时间 */ private int[] turnoverTime; /** * 作业带权周转时间· */ private float[] turnoverTimeWithWeight; /** * 平均带权周转时间 */ private float ave;} 三、初始化这里将最高响应比的初始化拉了出来，因为要设置响应比 12345678910111213141516171819202122232425262728293031323334353637383940414243444546/** * 初始化 */ public void init(int jobNum, int timeSize, String dispatchName) { System.out.println(\"开始\" + dispatchName + \"调度\"); readyQueue = new LinkedList&lt;&gt;(); finishQueue = new LinkedList&lt;&gt;(); this.turnoverTime = new int[jobNum]; this.turnoverTimeWithWeight = new float[jobNum]; this.cpuTime = 0; JCB jcb; for (int i = 1; i &lt;= jobNum; i++) { jcb = new JCB(i, (int) (Math.random() * 10 + 1), i - 1, 0); readyQueue.offer(jcb); } this.timeSize = timeSize; this.jobNum = jobNum; this.dispatchName = dispatchName; printInitQueue(); } /** * 初始化高响应比优先队列 * * @param jobNum * @param timeSize * @param dispatchName */ public void HRNInit(int jobNum, int timeSize, String dispatchName) { System.out.println(\"开始\" + dispatchName + \"调度\"); readyQueue = new LinkedList&lt;&gt;(); finishQueue = new LinkedList&lt;&gt;(); this.turnoverTime = new int[jobNum]; this.turnoverTimeWithWeight = new float[jobNum]; this.cpuTime = 0; JCB jcb; for (int i = 1; i &lt;= jobNum; i++) { float v = (float) (Math.random() * 5 + 1); jcb = new JCB(i, (int) (Math.random() * 10 + 1), i - 1, (float) (Math.random() * 5 + 1)); readyQueue.offer(jcb); } this.timeSize = timeSize; this.jobNum = jobNum; this.dispatchName = dispatchName; printInitQueue(); } 作业id默认为序号i，所需服务时间随机生成，到达时间默认从0开始，响应比其他调度算法为0，高响应比算法为随机生成。 四、高响应比优先算法实现逻辑很简单，使用递归实现，参数初始为0，每次取出对头作业，因为这里所有的作业在初始化时数据都初始化好了，所以需判断作业到达时间是否小于cpu时间片，因为只有小于时间片，说明其实际是到达的。 如果小于，则设置其开始时间为cpu当前时间，结束时间为开始时间+服务时间，剩余时间设为0，同时增加cpu时间，将该作业加入已完成队列中，否则，递归调用该算法，参数为index+1，一轮结束后，对作业按响应比排序，继续递归，知道就绪队列为空。 12345678910111213141516171819202122232425262728293031323334 /** * 最高响应比优先算法 */public void HRNAlgorithm(int index) { if (readyQueue.size() == 0) { System.out.println(\"就绪队列为空，调度完毕!\"); return; } JCB head = readyQueue.get(index); if (head.arriveTime &lt;= cpuTime) { readyQueue.poll(); System.out.println(\"-----------------------------------------------------\"); System.out.println(\"时间片: \" + cpuTime + \"开始调度作业:\" + head.id + \", 剩余服务时间: \" + head.leftTime); head.beginTime = cpuTime; head.finishTime = head.beginTime + head.serviceTime; head.leftTime = 0; cpuTime += head.serviceTime; finishQueue.offer(head); System.out.println(\"时间片: \" + cpuTime + \"结束调度作业:\" + head.id + \", 剩余服务时间: \" + head.leftTime); } else { HRNAlgorithm(index++); } sortByPriority(); HRNAlgorithm(0);}/** * 根据响应比排序 */private void sortByPriority() { readyQueue.sort((o1, o2) -&gt; o1.priority &gt; o2.priority ? -1 : 1);} 五、短作业优先调度算法同高响应比优先类似，只是按照要求服务时间排序。 123456789101112131415161718192021222324252627282930313233343536/** * 短作业优先调度算法 */ public void SJFAlgorithm(int index) { if (readyQueue.size() == 0) { System.out.println(\"就绪队列为空，调度完毕！\"); return; } JCB head = readyQueue.get(index); if (head.arriveTime &lt;= cpuTime) { readyQueue.poll(); System.out.println(\"-----------------------------------------------------\"); System.out.println(\"时间片: \" + cpuTime + \"开始调度作业:\" + head.id + \", 剩余服务时间: \" + head.leftTime); head.beginTime = cpuTime; head.finishTime = head.beginTime + head.serviceTime; head.leftTime = 0; cpuTime += head.serviceTime; finishQueue.offer(head); System.out.println(\"时间片: \" + cpuTime + \"结束调度作业:\" + head.id + \", 剩余服务时间: \" + head.leftTime); } else { sortByServiceTime(); SJFAlgorithm(index++); } sortByServiceTime(); SJFAlgorithm(0); } /** * 根据要求服务时间从小到大排序 */ private void sortByServiceTime() { readyQueue.sort((o1, o2) -&gt; o1.serviceTime &lt; o2.serviceTime ? -1 : 1); } 六、先来先服务 最简单的一个算法，直接按顺序取出队头作业执行。 12345678910111213141516171819202122/** * 先来先服务调度算法 */ public void FCFSAlgorithm() { if (readyQueue.size() == 0) { System.out.println(\"就绪队列为空，调度完毕！\"); return; } JCB head = readyQueue.poll(); System.out.println(\"-----------------------------------------------------\"); System.out.println(\"时间片: \" + cpuTime + \"开始调度作业:\" + head.id + \", 剩余服务时间: \" + head.leftTime); head.beginTime = cpuTime; head.leftTime = 0; head.finishTime = head.beginTime + head.serviceTime; cpuTime += head.serviceTime; finishQueue.offer(head); System.out.println(\"时间片: \" + cpuTime + \"结束调度作业:\" + head.id + \", 剩余服务时间: \" + head.leftTime); FCFSAlgorithm(); } 七、时间片轮转算法 这里需要根据作业剩余需要服务的时间跟时间片大小做对比，代码很好理解。 123456789101112131415161718192021222324252627282930313233343536/** * 时间片轮转算法 */ public void RRAlgorithm() { if (readyQueue.size() == 0) { System.out.println(\"就绪队列为空，调度完毕！\"); return; } JCB head = readyQueue.poll(); System.out.println(\"-----------------------------------------------------\"); System.out.println(\"时间片: \" + cpuTime + \"开始调度作业:\" + head.id + \", 剩余服务时间: \" + head.leftTime); head.beginTime = cpuTime; if (head.leftTime &gt; timeSize) { //服务时间大于时间片大小 head.leftTime -= timeSize; //重新加入到就绪队列尾部 readyQueue.offer(head); cpuTime += timeSize; } else if (head.leftTime == timeSize) { //服务时间等于时间片大小 cpuTime += timeSize; head.finishTime = cpuTime; head.leftTime = 0; //加入结束队列 finishQueue.offer(head); } else { //服务时间小于时间片大小 head.finishTime = cpuTime + head.leftTime; head.leftTime = 0; cpuTime += head.leftTime; finishQueue.offer(head); } System.out.println(\"时间片: \" + cpuTime + \"结束调度作业:\" + head.id + \", 剩余服务时间: \" + head.leftTime); RRAlgorithm(); } 八、计算周转时间和带权周转时间12345678910111213141516171819/** * 计算周转时间和带权周转时间 * @param finishQueue */ public void R_Dis(Queue&lt;JCB&gt; finishQueue) { Queue&lt;JCB&gt;temp=finishQueue; JCB tempJcb; float sum = 0; for (int i = 0; i &lt; jobNum; i++) { tempJcb=temp.poll(); turnoverTime[i] = tempJcb.finishTime - tempJcb.arriveTime; turnoverTimeWithWeight[i] =(float) turnoverTime[i] / tempJcb.serviceTime; sum += turnoverTimeWithWeight[i]; temp.offer(tempJcb); } float ave = sum / jobNum; this.ave = ave; } 九、打印结果123456789101112131415161718192021222324252627282930313233343536public void printResult(boolean isHRN) { R_Dis(this.finishQueue); System.out.println(\"=====================\" + this.dispatchName + \"调度结果为=========================\"); if (isHRN) { System.out.println(\"进程名\\t\" + \"到达时间\\t\" + \"要求服务时间\\t\" + \"响应比\\t\" + \"开始时间\\t\" + \"完成时间\\t\" + \"周转时间\\t\" + \"带权周转时间\\t\"+\"平均带权周转时间\\t\"); } else { System.out.println(\"进程名\\t\" + \"到达时间\\t\" + \"要求服务时间\\t\" + \"开始时间\\t\" + \"完成时间\\t\" + \"周转时间\\t\" + \"带权周转时间\\t\"+\"平均带权周转时间\\t\"); } int count = 0; for (JCB jcb : this.finishQueue) { if (isHRN) { System.out.println(\" \" + jcb.id + \"\\t\\t\\t\" + jcb.arriveTime + \"\\t\\t\" + jcb.serviceTime + \"\\t\\t\" + jcb.priority + \"\\t\\t\" + jcb.beginTime + \"\\t\\t\" + jcb.finishTime + \"\\t\\t\" + turnoverTime[count] + \"\\t\\t\" + turnoverTimeWithWeight[count]+\"\\t\\t\"+this.ave); count = count + 1; } else { System.out.println(\" \" + jcb.id + \"\\t\\t\\t\" + jcb.arriveTime + \"\\t\\t\" + jcb.serviceTime + \"\\t\\t\" + jcb.beginTime + \"\\t\\t\" + jcb.finishTime + \"\\t\\t\" + turnoverTime[count] + \"\\t\\t\" + turnoverTimeWithWeight[count]+\"\\t\\t\"+this.ave); count = count + 1; } } } /** * 打印初始化队列 */ private void printInitQueue() { System.out.println(\"当前就绪队列为:\"); for (JCB jcb2 : readyQueue) { System.out.println(jcb2); } } 测试1234567891011121314151617181920212223public class Test { public static void main(String[] args) { SchedulingAlgorithm schedulingAlgorithm = new SchedulingAlgorithm(); schedulingAlgorithm.init(5, 2,\"轮转\"); schedulingAlgorithm.RRAlgorithm(); schedulingAlgorithm.printResult(false); schedulingAlgorithm.init(5,3,\"先来先服务\"); schedulingAlgorithm.FCFSAlgorithm(); schedulingAlgorithm.printResult(false); schedulingAlgorithm.init(5,3,\"短作业优先服务\"); schedulingAlgorithm.SJFAlgorithm(0); schedulingAlgorithm.printResult(false); schedulingAlgorithm.HRNInit(5,3,\"高响应比优先\"); schedulingAlgorithm.HRNAlgorithm(0); schedulingAlgorithm.printResult(true); }} 结果：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141开始轮转调度当前就绪队列为:JCB{id=1, serviceTime=1, arriveTime=0, priority=0.0}JCB{id=2, serviceTime=5, arriveTime=1, priority=0.0}JCB{id=3, serviceTime=4, arriveTime=2, priority=0.0}JCB{id=4, serviceTime=6, arriveTime=3, priority=0.0}JCB{id=5, serviceTime=6, arriveTime=4, priority=0.0}-----------------------------------------------------时间片: 0开始调度作业:1, 剩余服务时间: 1时间片: 0结束调度作业:1, 剩余服务时间: 0-----------------------------------------------------时间片: 0开始调度作业:2, 剩余服务时间: 5时间片: 2结束调度作业:2, 剩余服务时间: 3-----------------------------------------------------时间片: 2开始调度作业:3, 剩余服务时间: 4时间片: 4结束调度作业:3, 剩余服务时间: 2-----------------------------------------------------时间片: 4开始调度作业:4, 剩余服务时间: 6时间片: 6结束调度作业:4, 剩余服务时间: 4-----------------------------------------------------时间片: 6开始调度作业:5, 剩余服务时间: 6时间片: 8结束调度作业:5, 剩余服务时间: 4-----------------------------------------------------时间片: 8开始调度作业:2, 剩余服务时间: 3时间片: 10结束调度作业:2, 剩余服务时间: 1-----------------------------------------------------时间片: 10开始调度作业:3, 剩余服务时间: 2时间片: 12结束调度作业:3, 剩余服务时间: 0-----------------------------------------------------时间片: 12开始调度作业:4, 剩余服务时间: 4时间片: 14结束调度作业:4, 剩余服务时间: 2-----------------------------------------------------时间片: 14开始调度作业:5, 剩余服务时间: 4时间片: 16结束调度作业:5, 剩余服务时间: 2-----------------------------------------------------时间片: 16开始调度作业:2, 剩余服务时间: 1时间片: 16结束调度作业:2, 剩余服务时间: 0-----------------------------------------------------时间片: 16开始调度作业:4, 剩余服务时间: 2时间片: 18结束调度作业:4, 剩余服务时间: 0-----------------------------------------------------时间片: 18开始调度作业:5, 剩余服务时间: 2时间片: 20结束调度作业:5, 剩余服务时间: 0就绪队列为空，调度完毕！=====================轮转调度结果为=========================进程名 到达时间 要求服务时间 开始时间 完成时间 周转时间 带权周转时间 平均带权周转时间 1 0 1 0 1 1 1.0 2.3733335 3 2 4 10 12 10 2.5 2.3733335 2 1 5 16 17 16 3.2 2.3733335 4 3 6 16 18 15 2.5 2.3733335 5 4 6 18 20 16 2.6666667 2.3733335开始先来先服务调度当前就绪队列为:JCB{id=1, serviceTime=3, arriveTime=0, priority=0.0}JCB{id=2, serviceTime=10, arriveTime=1, priority=0.0}JCB{id=3, serviceTime=7, arriveTime=2, priority=0.0}JCB{id=4, serviceTime=1, arriveTime=3, priority=0.0}JCB{id=5, serviceTime=1, arriveTime=4, priority=0.0}-----------------------------------------------------时间片: 0开始调度作业:1, 剩余服务时间: 3时间片: 3结束调度作业:1, 剩余服务时间: 0-----------------------------------------------------时间片: 3开始调度作业:2, 剩余服务时间: 10时间片: 13结束调度作业:2, 剩余服务时间: 0-----------------------------------------------------时间片: 13开始调度作业:3, 剩余服务时间: 7时间片: 20结束调度作业:3, 剩余服务时间: 0-----------------------------------------------------时间片: 20开始调度作业:4, 剩余服务时间: 1时间片: 21结束调度作业:4, 剩余服务时间: 0-----------------------------------------------------时间片: 21开始调度作业:5, 剩余服务时间: 1时间片: 22结束调度作业:5, 剩余服务时间: 0就绪队列为空，调度完毕！=====================先来先服务调度结果为=========================进程名 到达时间 要求服务时间 开始时间 完成时间 周转时间 带权周转时间 平均带权周转时间 1 0 3 0 3 3 1.0 8.154286 2 1 10 3 13 12 1.2 8.154286 3 2 7 13 20 18 2.5714285 8.154286 4 3 1 20 21 18 18.0 8.154286 5 4 1 21 22 18 18.0 8.154286开始短作业优先服务调度当前就绪队列为:JCB{id=1, serviceTime=8, arriveTime=0, priority=0.0}JCB{id=2, serviceTime=10, arriveTime=1, priority=0.0}JCB{id=3, serviceTime=1, arriveTime=2, priority=0.0}JCB{id=4, serviceTime=10, arriveTime=3, priority=0.0}JCB{id=5, serviceTime=1, arriveTime=4, priority=0.0}-----------------------------------------------------时间片: 0开始调度作业:1, 剩余服务时间: 8时间片: 8结束调度作业:1, 剩余服务时间: 0-----------------------------------------------------时间片: 8开始调度作业:3, 剩余服务时间: 1时间片: 9结束调度作业:3, 剩余服务时间: 0-----------------------------------------------------时间片: 9开始调度作业:5, 剩余服务时间: 1时间片: 10结束调度作业:5, 剩余服务时间: 0-----------------------------------------------------时间片: 10开始调度作业:2, 剩余服务时间: 10时间片: 20结束调度作业:2, 剩余服务时间: 0-----------------------------------------------------时间片: 20开始调度作业:4, 剩余服务时间: 10时间片: 30结束调度作业:4, 剩余服务时间: 0就绪队列为空，调度完毕！=====================短作业优先服务调度结果为=========================进程名 到达时间 要求服务时间 开始时间 完成时间 周转时间 带权周转时间 平均带权周转时间 1 0 8 0 8 8 1.0 3.72 3 2 1 8 9 7 7.0 3.72 5 4 1 9 10 6 6.0 3.72 2 1 10 10 20 19 1.9 3.72 4 3 10 20 30 27 2.7 3.72开始高响应比优先调度当前就绪队列为:JCB{id=1, serviceTime=1, arriveTime=0, priority=5.41018}JCB{id=2, serviceTime=6, arriveTime=1, priority=5.1338425}JCB{id=3, serviceTime=6, arriveTime=2, priority=3.1670618}JCB{id=4, serviceTime=6, arriveTime=3, priority=2.0463989}JCB{id=5, serviceTime=1, arriveTime=4, priority=4.711568}-----------------------------------------------------时间片: 0开始调度作业:1, 剩余服务时间: 1时间片: 1结束调度作业:1, 剩余服务时间: 0-----------------------------------------------------时间片: 1开始调度作业:2, 剩余服务时间: 6时间片: 7结束调度作业:2, 剩余服务时间: 0-----------------------------------------------------时间片: 7开始调度作业:5, 剩余服务时间: 1时间片: 8结束调度作业:5, 剩余服务时间: 0-----------------------------------------------------时间片: 8开始调度作业:3, 剩余服务时间: 6时间片: 14结束调度作业:3, 剩余服务时间: 0-----------------------------------------------------时间片: 14开始调度作业:4, 剩余服务时间: 6时间片: 20结束调度作业:4, 剩余服务时间: 0就绪队列为空，调度完毕!=====================高响应比优先调度结果为=========================进程名 到达时间 要求服务时间 响应比 开始时间 完成时间 周转时间 带权周转时间 平均带权周转时间 1 0 1 5.41018 0 1 1 1.0 2.1666665 2 1 6 5.1338425 1 7 6 1.0 2.1666665 5 4 1 4.711568 7 8 4 4.0 2.1666665 3 2 6 3.1670618 8 14 12 2.0 2.1666665 4 3 6 2.0463989 14 20 17 2.8333333 2.1666665","link":"/posts/20200107-OS_dispatch.html"}],"tags":[{"name":"centos7","slug":"centos7","link":"/tags/centos7/"},{"name":"firewall","slug":"firewall","link":"/tags/firewall/"},{"name":"linux","slug":"linux","link":"/tags/linux/"},{"name":"elasticsearch","slug":"elasticsearch","link":"/tags/elasticsearch/"},{"name":"docker","slug":"docker","link":"/tags/docker/"},{"name":"jib","slug":"jib","link":"/tags/jib/"},{"name":"文件上传","slug":"文件上传","link":"/tags/%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0/"},{"name":"fdfs","slug":"fdfs","link":"/tags/fdfs/"},{"name":"排序","slug":"排序","link":"/tags/%E6%8E%92%E5%BA%8F/"},{"name":"数据结构","slug":"数据结构","link":"/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"二叉树","slug":"二叉树","link":"/tags/%E4%BA%8C%E5%8F%89%E6%A0%91/"},{"name":"调度算法","slug":"调度算法","link":"/tags/%E8%B0%83%E5%BA%A6%E7%AE%97%E6%B3%95/"}],"categories":[{"name":"linux","slug":"linux","link":"/categories/linux/"},{"name":"docker","slug":"docker","link":"/categories/docker/"},{"name":"springboot","slug":"springboot","link":"/categories/springboot/"},{"name":"数据结构","slug":"数据结构","link":"/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"排序","slug":"数据结构/排序","link":"/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%8E%92%E5%BA%8F/"},{"name":"二叉树","slug":"数据结构/二叉树","link":"/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E4%BA%8C%E5%8F%89%E6%A0%91/"},{"name":"操作系统","slug":"操作系统","link":"/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"}]}